<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[几道面试题]]></title>
      <url>%2Fblog%2F2017%2F05%2F03%2F0503%2F</url>
      <content type="text"><![CDATA[几道java面试题。 1.数据库中的行转列，列转行。 ①.行转列建立tb_rtc表。 123456CREATE TABLE tb_rtc(NAME VARCHAR(10),JDBC INT,Hibernate INT,Spring INT); 向该表插入数据。 1234INSERT INTO tb_rtc VALUES('tom',20,50,80);INSERT INTO tb_rtc VALUES('marry',30,60,70);select * from tb_rtc 在oracle与mysql都可用下面方法翻转： 12345678(SELECT NAME,'JDBC' COURSE,JDBC grade FROM tb_rtc)UNION(SELECT NAME,'Hibernate' COURSE,Hibernate grade FROM tb_rtc)UNION(SELECT NAME,'Spring' COURSE,Spring grade FROM tb_rtc)ORDER BY NAME DESC;-- SELECT 'JDBC' COURSE FROM tb_rtc 意思是显示一列名称为course，内容全为"JDBC" UNION与UNION ALL的区别：union与union all 都是查询结果的并集，但是union多了一步去重复数据，所以效率上没union all高，另外union会对查询结果做排序。 ②.列转行建立tb_ctr表。 12345678DROP TABLE IF EXISTS `tb_ctr`;CREATE TABLE `tb_ctr` ( `Id` int(11) NOT NULL AUTO_INCREMENT, `Name` varchar(20) DEFAULT NULL, `Date` date DEFAULT NULL, `Scount` int(11) DEFAULT NULL, PRIMARY KEY (`Id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8; 向该表插入数据。 12345678910INSERT INTO `tb_ctr` VALUES ('1', '篮球', '2017-05-01', '10000');INSERT INTO `tb_ctr` VALUES ('2', '排球', '2017-05-01', '20000');INSERT INTO `tb_ctr` VALUES ('3', '篮球', '2017-05-02', '30000');INSERT INTO `tb_ctr` VALUES ('4', '排球', '2017-05-02', '35000');INSERT INTO `tb_ctr` VALUES ('5', '篮球', '2017-05-03', '31000');INSERT INTO `tb_ctr` VALUES ('6', '排球', '2017-05-03', '36000');INSERT INTO `tb_ctr` VALUES ('7', '篮球', '2017-05-04', '35000');INSERT INTO `tb_ctr` VALUES ('8', '排球', '2017-05-04', '38000');SELECT * from tb_ctr ; 用下面的方法翻转(mysql)。 12345SELECT Date ,MAX(CASE NAME WHEN '篮球' THEN Scount ELSE 0 END ) 篮球,MAX(CASE NAME WHEN '排球' THEN Scount ELSE 0 END ) 排球 FROM tb_ctr GROUP BY Date 用下面的方法可以达到上面相同的结果(mysql)。 12345SELECT Date,MAX(IF(NAME='篮球',Scount,0)) 篮球,MAX(IF(NAME='排球',Scount,0)) 排球FROM tb_ctr GROUP BY Date; 在oracle中可以使用下面的方法。 12345SELECT Date,MAX(DECODE(NAME='篮球',Scount,0)) 篮球,MAX(DECODE(NAME='排球',Scount,0)) 排球FROM tb_ctr GROUP BY Date; ③.统计数据 1234select Date,group_concat(NAME,'总量:',Scount) as Statistic from tb_ctr group by Date 1234select Date,NAME, group_concat(NAME,'总量:',Scount) as Statisticfrom tb_ctr group by Date,NAME 2.Spring中IOC和AOP的应用场景。 AOP：AOP适合于那些具有横切逻辑的应用：如性能监测，访问控制，对象池管理、事务管理、日志记录以及缓存。AOP将这些分散在各个业务逻辑中的代码通过横向切割的方式抽取到一个独立的模块中。AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。 具体应用场景：Authentication 权限Caching 缓存Context passing 内容传递Error handling 错误处理Lazy loading 懒加载Debugging 调试logging, tracing, profiling and monitoring 记录跟踪 优化 校准Performance optimization 性能优化Persistence 持久化Resource pooling 资源池Synchronization 同步Transactions 事务 参考：Spring aop 原理及各种应用场景 IOC：通过使用Spring框架，开发人员将不在自己的代码中维护对象之间的依赖关系，只需要在配置文件中进行设定就可以，Spring会自动地依据配置信息来维护对象之间的依赖关系，将被依赖关系的对象设置给依赖对象。 3.抽象类和接口的区别 接口是public，而抽象类是可以有私有方法或私有变量的。接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。抽象类里可以没有抽象方法。类单根继承，而接口可以实现多个。 参数 抽象类 接口 默认的方法实现 它可以有默认的方法实现 接口完全是抽象的。它根本不存在方法的实现 实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常Java类的区别 除了你不能实例化抽象类之外，它和普通Java类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。你不可以使用其它修饰符。 main方法 抽象方法可以有main方法并且我们可以运行它 接口没有main方法，因此我们不能运行它。 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口 速度 它比接口速度要快 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 Java抽象类与接口的区别 4.字符流和字节流的区别 在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。 在Java.io包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。（这四个都是抽象类） InputStream 和OutputStream,两个是为字节流设计的,主要用来处理字节或二进制对象。Reader和 Writer两个是为字符流（一个字符占两个字节）设计的,主要用来处理字符或字符串。字节流与字符流的区别详解 5.sql递归查询 mysql: 创建表t_areainfo。 123456789DROP TABLE IF EXISTS `t_areainfo`;CREATE TABLE `t_areainfo` ( `id` int(11) AUTO_INCREMENT, `level` int(11) DEFAULT '0', `name` varchar(255) DEFAULT '0', `parentId` int(11) DEFAULT '0', `status` int(11) DEFAULT '0', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8; 插入测试数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364INSERT INTO `t_areainfo` VALUES ('1', '0', '中国', '0', '0');INSERT INTO `t_areainfo` VALUES ('2', '0', '华北区', '1', '0');INSERT INTO `t_areainfo` VALUES ('3', '0', '华南区', '1', '0');INSERT INTO `t_areainfo` VALUES ('4', '0', '北京', '2', '0');INSERT INTO `t_areainfo` VALUES ('5', '0', '海淀区', '4', '0');INSERT INTO `t_areainfo` VALUES ('6', '0', '丰台区', '4', '0');INSERT INTO `t_areainfo` VALUES ('7', '0', '朝阳区', '4', '0');INSERT INTO `t_areainfo` VALUES ('8', '0', '北京XX区1', '4', '0');INSERT INTO `t_areainfo` VALUES ('9', '0', '北京XX区2', '4', '0');INSERT INTO `t_areainfo` VALUES ('10', '0', '北京XX区3', '4', '0');INSERT INTO `t_areainfo` VALUES ('11', '0', '北京XX区4', '4', '0');INSERT INTO `t_areainfo` VALUES ('12', '0', '北京XX区5', '4', '0');INSERT INTO `t_areainfo` VALUES ('13', '0', '北京XX区6', '4', '0');INSERT INTO `t_areainfo` VALUES ('14', '0', '北京XX区7', '4', '0');INSERT INTO `t_areainfo` VALUES ('15', '0', '北京XX区8', '4', '0');INSERT INTO `t_areainfo` VALUES ('16', '0', '北京XX区9', '4', '0');INSERT INTO `t_areainfo` VALUES ('17', '0', '北京XX区10', '4', '0');INSERT INTO `t_areainfo` VALUES ('18', '0', '北京XX区11', '4', '0');INSERT INTO `t_areainfo` VALUES ('19', '0', '北京XX区12', '4', '0');INSERT INTO `t_areainfo` VALUES ('20', '0', '北京XX区13', '4', '0');INSERT INTO `t_areainfo` VALUES ('21', '0', '北京XX区14', '4', '0');INSERT INTO `t_areainfo` VALUES ('22', '0', '北京XX区15', '4', '0');INSERT INTO `t_areainfo` VALUES ('23', '0', '北京XX区16', '4', '0');INSERT INTO `t_areainfo` VALUES ('24', '0', '北京XX区17', '4', '0');INSERT INTO `t_areainfo` VALUES ('25', '0', '北京XX区18', '4', '0');INSERT INTO `t_areainfo` VALUES ('26', '0', '北京XX区19', '4', '0');INSERT INTO `t_areainfo` VALUES ('27', '0', '北京XX区1', '4', '0');INSERT INTO `t_areainfo` VALUES ('28', '0', '北京XX区2', '4', '0');INSERT INTO `t_areainfo` VALUES ('29', '0', '北京XX区3', '4', '0');INSERT INTO `t_areainfo` VALUES ('30', '0', '北京XX区4', '4', '0');INSERT INTO `t_areainfo` VALUES ('31', '0', '北京XX区5', '4', '0');INSERT INTO `t_areainfo` VALUES ('32', '0', '北京XX区6', '4', '0');INSERT INTO `t_areainfo` VALUES ('33', '0', '北京XX区7', '4', '0');INSERT INTO `t_areainfo` VALUES ('34', '0', '北京XX区8', '4', '0');INSERT INTO `t_areainfo` VALUES ('35', '0', '北京XX区9', '4', '0');INSERT INTO `t_areainfo` VALUES ('36', '0', '北京XX区10', '4', '0');INSERT INTO `t_areainfo` VALUES ('37', '0', '北京XX区11', '4', '0');INSERT INTO `t_areainfo` VALUES ('38', '0', '北京XX区12', '4', '0');INSERT INTO `t_areainfo` VALUES ('39', '0', '北京XX区13', '4', '0');INSERT INTO `t_areainfo` VALUES ('40', '0', '北京XX区14', '4', '0');INSERT INTO `t_areainfo` VALUES ('41', '0', '北京XX区15', '4', '0');INSERT INTO `t_areainfo` VALUES ('42', '0', '北京XX区16', '4', '0');INSERT INTO `t_areainfo` VALUES ('43', '0', '北京XX区17', '4', '0');INSERT INTO `t_areainfo` VALUES ('44', '0', '北京XX区18', '4', '0');INSERT INTO `t_areainfo` VALUES ('45', '0', '北京XX区19', '4', '0');INSERT INTO `t_areainfo` VALUES ('46', '0', 'xx省1', '1', '0');INSERT INTO `t_areainfo` VALUES ('47', '0', 'xx省2', '1', '0');INSERT INTO `t_areainfo` VALUES ('48', '0', 'xx省3', '1', '0');INSERT INTO `t_areainfo` VALUES ('49', '0', 'xx省4', '1', '0');INSERT INTO `t_areainfo` VALUES ('50', '0', 'xx省5', '1', '0');INSERT INTO `t_areainfo` VALUES ('51', '0', 'xx省6', '1', '0');INSERT INTO `t_areainfo` VALUES ('52', '0', 'xx省7', '1', '0');INSERT INTO `t_areainfo` VALUES ('53', '0', 'xx省8', '1', '0');INSERT INTO `t_areainfo` VALUES ('54', '0', 'xx省9', '1', '0');INSERT INTO `t_areainfo` VALUES ('55', '0', 'xx省10', '1', '0');INSERT INTO `t_areainfo` VALUES ('56', '0', 'xx省11', '1', '0');INSERT INTO `t_areainfo` VALUES ('57', '0', 'xx省12', '1', '0');INSERT INTO `t_areainfo` VALUES ('58', '0', 'xx省13', '1', '0');INSERT INTO `t_areainfo` VALUES ('59', '0', 'xx省14', '1', '0');INSERT INTO `t_areainfo` VALUES ('60', '0', 'xx省15', '1', '0');INSERT INTO `t_areainfo` VALUES ('61', '0', 'xx省16', '1', '0');INSERT INTO `t_areainfo` VALUES ('62', '0', 'xx省17', '1', '0');INSERT INTO `t_areainfo` VALUES ('63', '0', 'xx省18', '1', '0');INSERT INTO `t_areainfo` VALUES ('64', '0', 'xx省19', '1', '0'); ①.向下递归(利用find_in_set()函数和group_concat()函数实现递归查询)：创建一个函数： 1234567891011121314151617DROP FUNCTION IF EXISTS queryChildrenAreaInfo;CREATE FUNCTION queryChildrenAreaInfo(areaId INT)RETURNS VARCHAR(4000)BEGINDECLARE sTemp VARCHAR(4000);DECLARE sTempChd VARCHAR(4000);SET sTemp='$';SET sTempChd = CAST(areaId AS CHAR);WHILE sTempChd IS NOT NULL DO -- 遍历下级节点SET sTemp= CONCAT(sTemp,',',sTempChd);SELECT GROUP_CONCAT(id) INTO sTempChd FROM t_areainfo WHERE FIND_IN_SET(parentId,sTempChd)&gt;0;-- 将检索记录id存入 sTempChdEND WHILE;RETURN sTemp;END; FIND_IN_SET(str,strlist)：使用FIND_IN_SET函数一次返回多条记录。如果str不在strlist或strlist为空字符串，则返回值为 0。如任意一个参数为NULL，则返回值为 NULL。假如字符串str在由N子链组成的字符串列表strlist中，则返回值的范围在 1 到 N 之间。一个字符串列表就是一个由一些被’ , ‘符号分开的子链组成的字符串。str是一个表的字段，然后每条记录分别是str等于strlist中的值的时候 ，有点类似in（集合）。 调用方法： 12SELECT queryChildrenAreaInfo(1);--查询id为1的所有下级节点id 查询id为”4”下面的所有节点。 1SELECT * FROM t_areainfo WHERE FIND_IN_SET(id,queryChildrenAreaInfo(4)); 1SELECT id FROM t_areainfo WHERE FIND_IN_SET(parentId,'$,1')&gt;0; 1SELECT GROUP_CONCAT(id) FROM t_areainfo WHERE FIND_IN_SET(parentId,'$,1')&gt;0; 1SELECT queryChildrenAreaInfo(1); -- function里递归调用了上面一句话 ②.向上递归 123456789101112131415161718DROP FUNCTION IF EXISTS queryChildrenAreaInfo1;CREATE FUNCTION queryChildrenAreaInfo1(areaId INT)RETURNS VARCHAR(4000)BEGINDECLARE sTemp VARCHAR(4000);DECLARE sTempChd VARCHAR(4000);SET sTemp='$';SET sTempChd = CAST(areaId AS CHAR);SET sTemp = CONCAT(sTemp,',',sTempChd);SELECT parentId INTO sTempChd FROM t_areainfo WHERE id = sTempChd;WHILE sTempChd &lt;&gt; 0 DOSET sTemp = CONCAT(sTemp,',',sTempChd);SELECT parentId INTO sTempChd FROM t_areainfo WHERE id = sTempChd;END WHILE;RETURN sTemp;END; 调用方式：查询id为”7”的节点的所有上级节点： 1SELECT * from t_areainfo where FIND_IN_SET(id,queryChildrenAreaInfo1(7)); 6.如何在后台进行非空验证/只在前台不在后台进行非空等验证的缺点 如果你开发的是商业应用，那么稳定性和安全性是相当重要的，而这里就存在有安全漏洞。因为你的前台验证并不一定在每个客户端都会执行，比如某个客户端把IE的安全等级调到最高(或者禁用了js)，那么所有JS实现的效果都会失效，那这时的前台验证就形同虚设，这时后台的验证也就显得很重要了。拿用户注册表单来说，用户在获得注册表单后，可以查看其HTML源代码，并且将其保存下来，将其中的JavaScript代码去掉，另存为一个本地HTML文件，再在本地运行，填写数据，同样可以成功达到向服务器提交不合理数据的目的。客户端验证给用户带来方便，其存在的原因主要是对用户考虑，但是它不能保证安全性，用户可以轻易绕过。因此，对于一个安全的数据验证方案，服务器端的验证是必须的，在设计应用系统时，必须考虑到这个要求。 7.如何对form表单提交到后台的大量数据进行验证 可以将多余的代码写在一个公共的工具类里面，再调用。史上最全Java表单验证封装类 8.JUnit及断言 断言是编写测试用例的核心实现方式，即期望值是多少，测试的结果是多少，以此来判断测试是否通过。Junit使用教程（二） 9.jdk1.5新特性 ①.自动装箱与拆箱②.枚举③.静态导入④.可变参数（Varargs）⑤.泛型(Generic)⑥.foreach循环……JDK1.5以后各版本新特性 10.解决过哪些浏览器兼容性的问题 。。。这个问题真的会不知道咋回答…前端开发要注意的浏览器兼容性问题整理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sqlserver常用SQL语句整理]]></title>
      <url>%2Fblog%2F2017%2F04%2F20%2Fsqlserver%E5%B8%B8%E7%94%A8SQL%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[15年10月份，大概一年半以前的某个工作日凌晨2点钟开始整理的sql语句。 创建数据库1234567891011121314151617CREATE DATABASE 数据库名ON PRIMARY --默认就属于PRIMARY主文件组，可省略( NAME=' ', --主数据文件的逻辑名 FILENAME='D:\project\stuDB_data.mdf', --主数据文件的物理名 SIZE=5mb, --主数据文件初始大小 MAXSIZE=100mb, --主数据文件增长的最大值 FILEGROWTH=15% --主数据文件的增长率)LOG ON( NAME=' ', FILENAME='D:\project\stuDB_log.ldf', SIZE=2mb, FILEGROWTH=1MB)GO 删除数据库12345DROP DATABASE 数据库名 USE master --设置当前数据库为master，以便访问sysdatabases表GOIF EXISTS（SELECT * FROM sysdatabases WHERE name ='stuDB'） DROP DATABASE stuDB SqlServer的主要数据类型Image:可用来存储图像Char:固定长度的非Unicode字符数据Varchar:可变长度非 Unicode 数据Nchar: 固定长度的Unicode 数据Nvarchar:可变长度的Unicode 数据DataTime：日期和时间int,smallint:整数Money:货币数据类型Bit:布尔 创建表12345678910111213141516171819CREATE TABLE 表名 ( 字段1 数据类型 列的特征， 字段2 数据类型 列的特征， ...)USE stuDB -数据库名 GOCREATE TABLE stuInfo /*-创建学员信息表-*/( stuName VARCHAR(20) NOT NULL , --姓名，非空（必填） stuNo CHAR(6) NOT NULL, --学号，非空（必填） stuAge INT NOT NULL, --年龄，INT类型默认为4个字节 stuID NUMERIC(18,0), --身份证号 stuSeat SMALLINT IDENTITY (1,1), --座位号，自动编号 stuAddress TEXT --住址，允许为空，即可选输入) GO 创建表：保证数据的完整性 = 实施完整性约束 删除表12345678910DROP TABLE 表名USE stuDB --将当前数据库设置为stuDB ，以便在stuDB数据库中建表GOIF EXISTS（SELECT * FROM sysobjects WHERE name=’stuInfo’ ） DROP TABLE stuInfoCREATE TABLE stuInfo /*-创建学员信息表-*/(…..) GO 添加约束123456789101112131415161718192021ALTER TABLE 表名 ADD CONSTRAINT 约束名 约束类型 具体的约束说明-- 主键（Primary Key）约束：如 PK_stuNo-- 唯一（Unique Key）约束：如 UQ_stuID(允许为空,不能重复)-- 默认（Default Key）约束：如 DF_stuAddress(当插入记录时该字段没有赋值，会使用默认值)-- 检查（Check Key）约束：如 CK_stuAge(列字段的内容必须符合要求,通常是一个取值范围)-- 外键(Foreign Key)约束：如 FK_stuNo ALTER TABLE stuInfo ADD CONSTRAINT PK_stuNo PRIMARY KEY (stuNo)ALTER TABLE stuInfo ADD CONSTRAINT UQ_stuID UNIQUE (stuID)ALTER TABLE stuInfo ADD CONSTRAINT DF_stuAddress DEFAULT ('地址不详') FOR stuAddressALTER TABLE stuInfo ADD CONSTRAINT CK_stuAge CHECK(stuAge BETWEEN 15 AND 40)ALTER TABLE stuMarks ADD CONSTRAINT FK_stuNo FOREIGN KEY(stuNo) REFERENCES stuInfo(stuNo)GO 主外键关系 当主表中没有对应的记录时，不能将记录添加到子表成绩表中不能出现在学员信息表中不存在的学号； 不能更改主表中的值而导致子表中的记录孤立把学员信息表中的学号改变了，学员成绩表中的学号也应当随之改变； 子表存在与主表对应的记录，不能从主表中删除该行不能把有成绩的学员删除了 删除主表前，先删子表先删学员成绩表、后删除学员信息表 删除约束12ALTER TABLE 表名 DROP CONSTRAINT 约束名 运算符= &gt; &lt; &gt;= &lt;= &lt;&gt;不等于 ! 通配符 ‘&#95;’ 一个字符 A Like ‘C&#95;’ % 任意长度的字符串 B Like ‘CO&#95;%’ [ ] 括号中所指定范围内的一个字符 C Like ‘9W0[1-2]’ [^] 不在括号中所指定范围内的一个字符 D Like ‘%[A-D][^1-2]’ 逻辑表达式 AND 逻辑与 1 AND 1 = 1; 1 AND 0 = 0; 0 AND 0 = 0; OR 逻辑或 1 OR 1 = 1; 1OR 0 = 1; 0 OR 0 = 0; NOT 逻辑非 NOT 1 = 0; NOT 0 = 1; 插入数据行123InSert [INTO] &lt;表名&gt; [列名] Values &lt;值列表&gt;INSERT INTO Table_1 (id,loginId,LoginPwd) values (3,4,5) 插入多行数据(一个表中数据引入另一个表/建临时表)应用：复制学员表Student为Table_1，包含表结构和全部的数据语法：Insert Into &lt;表名&gt;(列名)Select &lt;列名&gt;From &lt;源表名&gt; 1234567891011INSERT INTO Table_1(id, loginId, LoginPwd) SELECT Id,Name,NumberFROM StudentINSERT INTO tb_TB(id, number, 数学成绩) SELECT A.id,A.学号,A.数学成绩 FROM (SELECT id,number As 学号,Math As 数学成绩FROM tb_ScoreWHERE Math between 60 and 100ORDER BY tb_Score.number ------) A 除非另外还指定了TOP 或FOR XML，否则，ORDER BY 子句在视图、内联函数、派生表、子查询和公用表表达式中无效。 1234567INSERT INTO tb_TB(id, number, 数学成绩) SELECT A.id,A.学号,A.数学成绩 FROM (SELECT id,number As 学号,Math As 数学成绩FROM tb_ScoreWHERE Math between 60 and 100--ORDER BY tb_Score.number) A //(9 行受影响) 一般常用的创建临时表的方法是:Select &lt;列名&gt;Into &lt;表名&gt;(列名)From &lt;源表名&gt; –若不存在自己创建，若存在提示已存在 1234567select A.id,A.学号,A.数学成绩 into tb_TBfrom(SELECT id,number As 学号,Math As 数学成绩FROM tb_ScoreWHERE Math between 60 and 100--ORDER BY tb_Score.number) A //消息 2714，级别 16，状态 6，第 1 行 数据库中已存在名为 ‘tb_TB’ 的对象。 12345678910select A.id,A.学号,A.数学成绩 into tb_TCfrom(SELECT id,number As 学号,Math As 数学成绩FROM tb_ScoreWHERE Math between 60 and 100--ORDER BY tb_Score.number) Aselect * from tb_TC--新表中自动创建的id，number,Math与源表中数量，类型一致 Q：在数据库表中，数据行位置并不重要，但是一个单位中要根据奇数行和偶数行的数据来汇总，在这个汇总的基础上再得到一个数值，因此，要查询数据库表的奇数行和偶数行的总数。A：新建一个临时表，从原表中任选一列数据存入临时表，根据新的标识列，进行奇偶判断。 1234SELECT IDENTITY(int,1,1) AS ID INTO TEMPTABLFROM tb_TC 1select * from TEMPTABL 123SELECT count(ID) AS 奇数列汇总 FROM TEMPTABLWHERE ID%2 &lt;&gt; 0 123SELECT count(ID) AS 偶数列汇总 FROM TEMPTABL WHERE ID%2 = 0 更新数据行语法：Update &lt;表名&gt; Set &lt;列名 = 更新值&gt;[Where &lt;更新条件&gt;] 1UPDATE Students SET SSEX = 0 123UPDATE ScoresSET Scores = Scores + 5WHERE Scores &lt;= 95 删除数据行语法：Delete From &lt;表名&gt; [Where &lt;删除条件&gt;] 12DELETE FROM Table_3where s = '6' 删除表语法：Truncate Table &lt;表名&gt; 123TRUNCATE TABLE Table_3DELETE FROM Table_3 --与上面的语句等价 查询语法:SELECT &lt;列名&gt;FROM &lt;表名&gt;[WHERE &lt;查询条件表达式&gt;][ORDER BY &lt;排序的列名&gt;[ASC或DESC]] 1234SELECT id,Name,Number FROM Student WHERE SEX = 0 ORDER BY ClassNo 查询全部的行和列: 1SELECT * FROM Students 查询部分行: 12345SELECT SCode,SName,SAddress FROM StudentsWHERE SAddress = '河南新乡'SELECT SCode,SName,SAddress FROM StudentsWHERE SAddress &lt;&gt; '河南新乡' 使用AS来命名列: 12345678910SELECT SCode AS 学员编号,SName AS学员姓名,SAddress AS 学员地址 FROM StudentsWHERE SAddress &lt;&gt; '河南新乡'SELECT Name + '.' + Number AS '姓名' FROM StudentSELECT Name AS '男' FROM Studentwhere Sex=1 使用=来命名列: 12SELECT 'A' = Name+'.'+Number FROM Student 查询空行: 1SELECT Name FROM Student WHERE Sex IS NULL 使用常量列(‘’AS列名,列名下元素赋值’’): 123456SELECT 姓名=Name,学号= Number,'.Net班' AS 班级FROM Student--查询Name命名为okSELECT Name AS ok,学号= Number,'.Net班' AS 班级FROM Student 限制固定行数: 12SELECT TOP 5 Name, NumberFROM Student WHERE Sex = 0 返回百分之多少行: 12SELECT TOP 40 PERCENT Name, AddressFROM Student WHERE Sex = 0 123SELECT TOP 1 PERCENT Name, AddressFROM Student WHERE Sex = 0--若存在至少返回一行 升序排列: 1234SELECT id As 学员编号,(Math*0.9+5) As 综合成绩FROM Tb_ScoreWHERE (Math*0.9+5)&gt;60ORDER BY number //消息8115，级别16，状态8，第1 行 将varchar 转换为数据类型numeric 时出现算术溢出错误。 降序排列: 12…ORDER BY number DESC 按多列排序: 12345SELECT number As 学号,Math As 数学成绩FROM tb_ScoreWHERE Math&gt;60ORDER BY tb_Score.number--tb_Score可省略 模糊查询LIKE:Q:以下的SQL语句：SELECT * FROM 数据表WHERE 编号 LIKE ‘00[^8]%[A,C]%’可能会查询出的编号值为(B)。A、9890ACDB、007_AFFC、008&amp;DCGD、KK8C IS NULL(把某一字段中内容为空的记录查询出来): 1SELECT ID, Name FROM Student WHERE Phone Is null BETWEEN: 1234SELECT number As 学号,Math As 数学成绩FROM tb_ScoreWHERE Math between 60 and 100ORDER BY tb_Score.number IN(把某一字段中内容与所列出的查询内容列表匹配的记录查询出来): 12SELECT ID, Number FROM tb_address WHERE address IN ('北京','沈阳','南京') 聚合函数SUM: 1SELECT SUM(Math) FROM Tb_Score WHERE English = '95' AVG: 12SELECT AVG(Math) AS 平均成绩 From Tb_Score WHERE Math &gt;=60 MAX、MIN: 12SELECT AVG(Math) AS 平均成绩, MAX (Math) AS 最高分, MIN (Math) AS 最低分 From tb_Score WHERE Math &gt;=60 COUNT/COUNT(*): 12SELECT COUNT (*) AS 及格人数 From tb_Score WHERE Math&gt;=60 分组汇总GROUP BY:指定 GROUP BY 时，如果 SELECT 子句中包含聚合函数, 则计算每组的汇总值。 123SELECT math,AVG(Math) as 平均成绩FROM tb_ScoreGROUP BY math 选择列表中任一非聚合表达式内的所有列都应包含在 GROUP BY 列表中，或者 GROUP。BY 表达式必须与选择列表表达式完全匹配。否则列无法对应。 123SELECT number,mathFROM tb_ScoreGROUP BY number,math 多列分组:用于两个或多个元素在两个或多个列值相同的情况。 12345SELECT Number AS 学员编号,courseId AS 内部测试, AVG(Score) AS 内部测试平均成绩 geFROM studentScoresGROUP BY Number,courseId--转化为平均成绩 HAVING:输出两个或多个元素在两个或多个列值相同,例如成绩出现多次的分组的平均成绩： 12345SELECT Number AS 学员编号, courseId AS 内部测试, AVG(Score) AS 内部测试平均成绩FROM studentScoresGROUP BY Number,courseIdHAVING COUNT(Score)&gt;1 1234567select * from (SELECT Number AS 学员编号, courseId AS 内部测试,AVG(Score) AS 内部测试平均成绩 FROM studentScoresGROUP BY Number,courseId HAVING COUNT(Score)&gt;1) Awhere 学员编号=12 1234567891011if((select count (*) a from (SELECT distinct Number from studentScores) A )&lt;&gt;(select count (Number) b from studentScores ))beginprint '有重复'endelsebeginprint '无重复'end 对比:WHERE子句从数据源中去掉不符合其搜索条件的数据。GROUP BY子句搜集数据行到各个组中，统计函数为各个组计算统计值。HAVING子句去掉不符合其组搜索条件的各组数据行。 多表联结查询分类：1.内联结(INNER JOIN)2.外联结①.左外联结(LEFT JOIN)②.右外联结(RIGHT JOIN)③.完整外联结(FULL JOIN)3.交叉联结(CROSS JOIN) 1234SELECT S.SName,C.CourseID,C.Score From Score AS CINNER JOIN Students AS SON C.StudentID = S.SCode 1234SELECT S.SName,C.CourseID,C.Score From Students AS SINNER JOIN Score AS CON C.StudentID = S.SCode 123SELECT Students.SName, Score.CourseID, Score.ScoreFROM Students,Score --FROM 表A表BWHERE Students.SCode = Score.StudentID //上面三个结果相同 1234SELECT S.SName,C.CourseID,C.Score From Students AS SINNER JOIN Score AS CON C.StudentID &lt;&gt; S.SCode 三表联结: 123456SELECT --表A,B,C内要显示的列S.SName AS 姓名,C.Score AS 成绩 --,CS.CourseName AS 课程FROM Students AS S INNER JOIN Score AS C ON (S.SCode = C.StudentID)INNER JOIN Course AS CS ON (CS.CourseID = C.CourseID) 左外联结(LEFT JOIN /LEFT OUTER JOIN): 1234SELECT S.SName --,C.CourseID,C.Score From Students AS SLEFT JOIN Score AS CON C.StudentID = S.SCode 1234SELECT C.CourseID,C.Score --,S.SNameFrom Score AS CLEFT JOIN Students AS SON C.StudentID = S.SCode //上面两个结果相同 T-SQL局部变量：局部变量必须以标记@作为前缀，如@age。局部变量的使用也是先声明，再赋值。全局变量：全局变量必须以标记@@作为前缀，如@@version。全局变量由系统定义和维护，我们只能读取，不能修改全局变量的值。声明局部变量：DECLARE @变量名 数据类型 123DECLARE @name varchar(8)DECLARE @seat int 赋值:SET @变量名 = 值或 SELECT @变量名 = 值 1234SET @name='张三' --必须确保筛选出的记录只有1条SELECT @name=stuName FROM stuInfo WHERE stuNo='s25302' Eg：编写T-SQL查找李文才的左右同桌。/–查找李文才的信息–/ 12345678910DECLARE @name varchar(8) --学员姓名SET @name='李文才' --使用SET赋值SELECT * FROM stuInfo WHERE stuName = @name/*--查找李文才的左右同桌--*/DECLARE @seat int --座位号SELECT @seat=stuSeat FROM stuInfo --使用SELECT赋值 WHERE stuName=@nameSELECT * FROM stuInfo WHERE (stuSeat = @seat+1) OR (stuSeat = @seat-1)GO 全局变量123456INSERT INTO stuInfo(stuName,stuNo,stuSex,stuAge) VALUES('武松','s25328','男','23')--如果大于0表示上一条语句执行有错误print '当前错误号'+convert(varchar(5),@@ERROR)print '刚才报名的学员，座位号为:'+convert(varchar(5),@@IDENTITY ) Go IF-ELSE语句ELSE是可选部分,如果有多条语句,才需要BEGIN-END语句块。SQL中的IF-ELSE语句： 123456789101112IF (条件) BEGIN 语句1 语句2 … ENDELSE BEGIN 语句; 语句; … END WHILE循环语句BREAK表示退出循环,如果有多条语句才需要BEGIN-END语句块。SQL中的WHILE语句： 1234567WHILE 条件） BEGIN 语句1 语句2 …… BREAK END 12345678910111213DECLARE @n intWHILE(1=1) --条件永远成立 BEGIN SELECT @n=COUNT(*) FROM stuMarks WHERE writtenExam&lt;60 --统计不及格人数 IF (@n&gt;0) UPDATE stuMarks --每人加分 SET writtenExam=writtenExam+2 ELSE BREAK --退出循环 ENDprint '加分后的成绩如下：'SELECT * FROM stuMarks CASE-END多分支语句123456CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …… ELSE 其他结果END 12345678910print 'ABCDE五级显示成绩如下：'SELECT stuNo,成绩=CASE WHEN writtenExam&lt;60 THEN 'E' WHEN writtenExam BETWEEN 60 AND 69 THEN 'D' WHEN writtenExam BETWEEN 70 AND 79 THEN 'C' WHEN writtenExam BETWEEN 80 AND 89 THEN 'B' ElSE 'A' ENDFROM stuMarks 123456789101112USE stuDBGOSELECT 考号=ExamNo,学号=stuNo,笔试=writtenExam,机试=labExam, 平均分=(writtenExam+labExam)/2, 等级=CASE WHEN (writtenExam+labExam)/2&lt;60 THEN '不及格' WHEN (writtenExam+labExam)/2 BETWEEN 60 AND 69 THEN '差' WHEN (writtenExam+labExam)/2 BETWEEN 70 AND 79 THEN '中' WHEN (writtenExam+labExam)/2 BETWEEN 80 AND 89 THEN '良' ElSE '优' ENDFROM stuMarks 批处理语句：SQLServer规定：如果是建库、建表语句、以及我们后面学习的存储过程和视图等，则必须在语句末尾添加 GO 批处理标志。 Eg:对机试成绩进行反复加分，直到平均分超过分为止。请编写T-SQL语句实现。90分以上： 不加分80－89分： 加分70－79分： 加分60－69分： 加分60分以下： 加分 123456789101112131415161718SELECT * FROM stuMarks --原始成绩DECLARE @labAvg INTWHILE(1=1) BEGIN UPDATE stuMarks SET labExam= CASE WHEN labExam&lt;60 THEN labExam+5 WHEN labExam between 60 AND 69 THEN labExam+3 WHEN labExam between 70 AND 79 THEN labExam+2 WHEN labExam between 80 AND 89 THEN labExam+1 ELSE labExam END SELECT @labAvg=AVG(labExam) FROM stuMarks IF @labAvg&gt;=85 BREAK ENDSELECT * FROM stuMarks --加分后的成绩 事务假定张三的账户直接转账1000元到李四的账户。 1234567891011121314151617CREATE TABLE bank( customerName CHAR(10), --顾客姓名 currentMoney MONEY --当前余额)GOALTER TABLE bank ADD CONSTRAINT CK_currentMoney--添加约束：根据银行规定，账户余额不能少于1元，否则视为销户 CHECK(currentMoney&gt;=1)GOINSERT INTO bank(customerName,currentMoney) VALUES('张三',1000)INSERT INTO bank(customerName,currentMoney) VALUES('李四',1) haha，后面整理的资料丢失了，只到这了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[半年工作总结]]></title>
      <url>%2Fblog%2F2017%2F04%2F01%2F%E5%8D%8A%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[时间过得真快，在这家公司已经工作半年多了。是时候做个小结了。 有时候，不去比较真的不知道自己有多差劲。在一个安逸的环境里，的确会消磨人的一些东西。 生于忧患，死于安乐。 来公司第一天，让选个位子，然后搬一台新电脑到自己位子拆封，组装机子，装一些必要软件，像python环境，RegexBuddy，wireshark，编码-解码器，Xshell，Xftp，Markdown，phpStudy，虚拟机等，在虚拟机里装了pycharm，myeclipse，mysql，chrome…后面就是看Http，正则，git，python…相关的资料学习，再后来开始接手第一个任务，中国菜刀(Chopper)的协议及数据包分析。然后开始在虚拟机搭建回放环境，搭建好了之后熟悉回放环境，熟悉了之后学习wireshark抓包相关知识，要在服务端进行抓包，抓完了数据包根据回放环境的正则进行匹配，回放成我们的框架程序可以接受的模式，将回放的文件放在框架里，写解码程序，处理这些话单。大概就是 调研，写文档-&gt;复现-&gt;抓包-&gt;回放-&gt;写程序-&gt;单元测试 几个步骤。其中复现步骤要求会搭建各种漏洞需要的运行环境，抓包步骤要求你会写一些高级高效的正则去匹配要提取的信息。回放就是利用公司自己搭建的环境将数据包翻译成框架可以理解的格式。写程序嘛就是程序员都会干的事。另外，公司比较注重安全性，拷贝东西不可以用U盘，我们用的介质是可擦写光盘。 日子就这样一天天的过去。学习了很多，但好像有更多的东西不会做。 一些java面试题： Q：写一个简单的方式实现去字符串内部的空格，两个或两个以上的只保留一个。例如”S t r in g”转换成 “S t r in g”。A： 1String str2 = str.replaceAll("\\s&#123;2,&#125;", " "); Q：ArrayList可变长度如何实现的？A：看ArrayList源码知，ArrayList首先在内存中定义一个长度为10的数组，如果实际要用的长度大于10，就把数组的长度 *1.5+1，给一个新长度，不够用再增加。 Q：ArrayList和LinkedList区别，HashMap和HashTable区别A：ArrayList和LinkedList区别：1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 参考资料Java中ArrayList和LinkedList区别 HashMap和HashTable区别：由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。 参考资料HashMap和Hashtable的区别HashMap和Hashtable的区别 Q：IOC和DI的区别A：IOC控制反转：说的是创建对象实例的控制权从代码控制剥离到IOC容器控制，实际就是你在xml文件控制，侧重于原理。DI依赖注入：说的是创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现。 它们是spring核心思想的不同方面的描述。 Q：Spring如何实现IOC，Spring的好处A：1.解析配置文件，获得对象信息2.合理的创建它们 使用Spring降低耦合度。 Q：Struts2和SpringMVC有什么区别，SpringMVC相比Struts2有哪些优势A：1.入口：springmvc的入口是servlet，而struts2是filter2.性能：spring会稍微比struts快。spring mvc是基于方法的设计，而sturts是基于类，每次发一次请求都会实例一个action，每个action都会被注入属性，struts2实际上是通过setter getter方法与request打交道的 ，而 springmvc 不用 setter getter 方法。struts2中，一个Action对象对应一个request上下文。3.实现restful:springmvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上 springmvc就容易实现restful url 。struts2 是类级别的拦截，一个类对应一个 request 上下文，因为 struts2 action 的一个方法可以对应一个 url，而其类属性却被所有方法共享。4.数据共享：struts是在接受参数的时候，可以用属性来接受参数，这就说明参数是让多个方法共享的。springmvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量5.处理ajax请求：只需一个注解 @ResponseBody，然后直接返回响应文本即可6.interceptor实现机制：struts有自己的interceptor机制，springmvc用的是独立的AOP方式。这样导致struts的配置文件量还是比springmvc大 参考资料同是流行MVC框架，比较Struts2和SpringMVC的区别springmvc和struts2的区别SpringMVC与Struts2区别与比较总结 Q：网络传输分哪几层A：七层结构： 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 Q：常见的网络协议有哪些？TCP和UDP区别A：TCP/IP、HTTP、FTP、等。 TCP是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来。UDP是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。 TCP UDP 是否连接 面向连接 面向非连接 传输可靠性 可靠 不可靠 应用场合 传输大量数据 少量数据 速度 慢 快 Q：主流设计模式：单例模式(singleton)、简单工厂(StaticFactory Method)、工厂方法(Factory Method)和抽象工厂(Abstract Factory)、代理模式(Proxy)、命令模式(Command)、策略模式(Strategy)、门面模式(Facade)、桥接模式(Bridge)、观察者模式(Observer)等。 Q：写一个最优的单例模式(singleton) 作用：单例模式（Singleton）：保证一个类仅有一个实例，并提供一个访问它的全局访问点优点：系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 单例模式一般分为五种：懒汉，恶汉，双重校验锁，枚举和静态内部类。静态内部类： 12345678910111213141516171819202122//延迟加载，减少内存开销//线程安全（java中class加载时互斥的）public class Singleton &#123; //私有的构造函数 private Singleton() &#123; &#125; //由于SingletonHolder是私有的，除了getInstance()之外没有办法访问它，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，因此它是懒汉式的 private static class SingletonHolder &#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125; protected void method() &#123; System.out.println("SingletonInner"); &#125; &#125; 调用： 1Singleton.getInstance().method(); 参考资料JAVA单例模式的各种写法分析 Q：线程相关 参考资料Java线程面试题 Top 50]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速搭建php环境并使用phpstorm调试php代码]]></title>
      <url>%2Fblog%2F2017%2F01%2F11%2F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAphp%E7%8E%AF%E5%A2%83%E5%B9%B6%E4%BD%BF%E7%94%A8phpstorm%E8%B0%83%E8%AF%95php%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[教你从零基础升级成会完美调试php的大神！ 前言最近由于工作的关系调研一些php的webshell，为了更好的理解一些语句的作用，我想到了用调试来解决，但是搜索了全网也没有找到一份同时具备适合于新手、可配置性高、实用且完整的教程，于是决定自己写一份，把自己探索研究的过程记录下来。我本人经过几天的认真研究总结出的这些方法的确使代码调试达到了eclipse、Visual Studio相当的十分流畅的用户体验，代码发布达到了eclipse相当的简洁高效的用户体验，总结起来就是用了我的这套配置方法以后，感觉很流畅。 准备操作系统：win7 64bitPhp版本是：5.6.27PhpStorm版本是：PhpStorm 10.0.1Apache版本：2.4.17我用的是Chrome浏览器，版本：55.0.2883.87 m 如果只发布项目不进行调试，使用phpStudy集成环境来发布php项目也是不错的选择，特别适合新手学习使用。 安装Php这里的Php相当于Php代码的编译环境。跟教程里的其他配置操作的难度相比，这部分可以忽略不计，对纯小白来说可能稍微有一点难度，请自行百度，安装好以后配置好环境变量。本教程将留更大篇幅给后面有难度的章节。 安装PhpStormPhpStorm是Php代码运行环境和调试工具。安装方法请自行百度。 安装Apache服务器Apache服务器是适合搭载Php项目的服务器，也是世界上使用最广泛的服务器。百度下载Apache服务器到本地文件夹。 安装XdebugXdebug是对Php代码进行调试所需要的插件。把它放置在php安装的文件夹下的ext文件夹里。我的Xdebug的安装路径为：D:\D\software\php\php-5.6.27-Win32-VC11-x64\ext。注意要安装与自己Php对应版本的Xdebug，我安装的php_xdebug-2.5.0-5.6-vc11-x86_64.dll，2.5.0是xdebug的版本，5.6是我本地安装的php的版本。如果你要安装和我相同版本的xdebug(php_xdebug-2.5.0-5.6-vc11-x86_64.dll)，可以点击进入我的百度云下载。 打开php的安装目录，找到php.ini配置文件。将下面这段话复制到php.ini 文件任意位置。 1234567891011[xdebug]xdebug.profiler_output_dir="D:\D\workspace\xdebug_output\xdebug";输出目录自己定义xdebug.trace_output_dir="D:\D\workspace\xdebug_output\xdebug";输出目录自己定义zend_extension="D:\D\software\php\php-5.6.27-Win32-VC11-x64\ext\php_xdebug-2.5.0-5.6-vc11-x86_64.dll";zend_extension为Xdebug在你电脑里安装的物理地址xdebug.remote_enable=onxdebug.profiler_enable=off ;一般不要打开性能监控，会生成很大的缓存文件，几个g到几十g都有xdebug.idekey="PHPSTORM" 检查Xdebug是否安装成功：用记事本写一个php文件，1.php。 12&lt;?php phpinfo(); 作用是打印php的信息。放置到Apache服务器的htdocs目录下。启动Apache服务器（不懂的在正文第一节中有介绍启动方法），在浏览器中输入localhost/1.php，在弹出的php信息页面Ctrl+F搜索是否有Xdebug。如果找不到说明Xdebug没有安装成功。如果显示下面的信息，说明xdebug已经安装成功。对于按照上面每一步操作下来，仍然没有显示Xdebug的解决办法： 打开Apache服务器的配置文件httpd.conf（不懂的在正文第一节中有介绍配置文件位置）,Ctrl+F搜索PHPIniDir，将后面的地址改成php.ini（php的配置文件）的地址。这样做是因为Apache服务器对PHP.Ini加载有个默认路径，如果和你的安装路径不一致，就读取不了php.ini，我的Apache2.4.17默认：PHPIniDir “D:/php”,改成自己的 php.ini 文件路径，重启Apache服务器，就可以了，这个时候发现Xdebug也加载出来了。 安装xdebug helperxdebug helper是一款浏览器插件，跟phpStorm配合用于调试你的php代码。如果你也使用的Chrome浏览器，xdebug helper可以点击进入我的百度云下载。安装方法为 Chrome浏览器-&gt;设置-&gt;扩展程序 ,将下载好的插件拖动进去即可。安装好以后在Chrome浏览器的右上角，会出现一个小虫子的图标。 正文到这里我默认你已经安装好了上面的几个工具。 检查Apache默认端口是否被占用Apache服务器的默认端口号是80，跟IIS服务器的默认端口号相同。因为我常用IIS发布一些.NET的项目，所以IIS服务器的端口号我十分不愿意修改，这里我选择修改Apache的默认端口号，把它改成8081（电脑上没装IIS服务器的可以忽略这个问题，检测方法：浏览器地址栏输入localhost,看看会不会显示IIS服务器的起始页，会有IIS字样）。 找到Apache服务器的所在文件夹。用文本编辑器打开/conf/httpd.conf，Ctrl+F搜索“Listen”，紧接着Listen的数字就是端口号，默认状态下为“Listen 80/8080”，改成8081。 切换到Apache目录下的bin文件夹下（例如我的是D:\Apache2.4.17-x64\bin）。双击打开httpd.exe即可启动，启动后弹出一个黑色的命令框。在浏览器中输入localhost:8081/检查是否启动Apache服务器，成功启动后会看到Apache服务器的欢迎页。 配置phpStorm打开自己的phpStorm。 1.新建一个php文件test.php。不需要知道我写的这个文件的意思，感兴趣的同学可以继续进行研究，这个就说来话长了。 将项目拷贝到apache服务器htdocs目录下，启动phpStorm时打开的文件路径为Apache服务器下项目的路径 File-&gt; Settings-&gt; Build,Execution,Deployment-&gt; Debugger，设置端口号Port为8081。 2.发布项目。 File-&gt; Settings-&gt; Build,Execution,Deployment-&gt; Deployment，点击左上角加号，新增一个发布的项目。Type下拉框选择In place，Name文本框对边填写一个名字。我填的是Test。点击Ok，在这个界面配置Web server root URL，地址是用浏览器访问的地址，一般写成http://服务器IP地址:服务器端口号，这里我写为http://localhost:8081，也可以写成http://localhost:8081/Test，这里的Test为刚刚发布项目时取的名字。保存更改。 3.打开File-&gt; Settings-&gt; Languages &amp; Frameworks-&gt; PHP-&gt; Servers，点击Import，导入一个部署好的项目。在下拉框里选择刚刚发布的项目Test。点击确定，保存修改。 4.点菜单栏的Run&gt;Edit Configurations… 在弹出的窗口中添加一个调试配置：点击左上角加号，选择PHP Web Application,在右侧的Configuration里点击“更多”按钮。弹出了刚刚配置好的Servers,点击确定保存修改。在Name里随便取个名字，我取的是Test。 5.进入File-&gt; Settings-&gt; Languages &amp; Frameworks-&gt; PHP -&gt;Debug，找到Xdebug选项卡，port填9000(Debug port要和php.ini里面的 xdebug.remote_port相一致！默认是9000)。 6.进入File-&gt; Settings-&gt;Languages &amp; Frameworks -&gt;PHP -&gt;Debug -&gt;DBGp Proxy 填写：IDE key: phpStormhost: localhostport: 8081 需要注意的问题1.File-&gt; Settings-&gt; Build,Execution,Deployment-&gt; Deployment下的 Web server root URL 下将启动后的默认url改为”http://” +你的 ip后，发现总是默认启动80端口，原来还要加上服务器的端口号（我设置的8081），这样才会找到正确的路径。 2.更改完Apache的配置后一定要重启服务器。 高阶配置更改默认的网站目录为PHPStorm的工作目录。 由于默认的网站目录在Apache服务器目录下的htdocs里，可是我的phpStrom用的工作目录(WorkSpace)却不是这个,在phpstorm里点击Chrome浏览器图标默认打开的url不是服务器下的，所以会出错，影响浏览php页面的心情。 怎样才能不再浏览器里输入Apache下的工作路径而直接在phpStorm里点击Chrome浏览器图标访问自己编写的项目呢？ 解决方法1.将此php项目的工作目录赋值到Apache服务器的htdocs目录下，这样省去了粘贴项目到htdocs目录下的繁琐，但不是最佳解决方案。 2.在Apache的配置文件httpd.conf 里面修改Apache的默认工作目录在Apache配置文件里搜索”DocumentRoot”，将DocumentRoot和Directory改为你PHPStrom的工作目录即可，注意两个值一定要相同,重启Apache服务器。 12DocumentRoot "D:/D/workspace/phpStorm10.0.1_WorkSpace"&lt;Directory "D:/D/workspace/phpStorm10.0.1_WorkSpace"&gt; 上面的步骤实际上是手动完成了 相当于Eclipse在 IDE中自动配置发布的过程。按照这个步骤配置好以后就达到了相当于WebStorm里点击浏览器直接查看网页的功能，但这里配置的更完美，在phpStorm里直接点开Chrome浏览器图标以后在浏览器的地址栏里面显示的是服务器下的路径，究竟有多完美，自行体会。 php debug说到这里又非常有趣了。 1.检查谷歌浏览器扩展插件是否下载了xdebug插件。2.检查本地php下安装对应php版本的xdebug.dll文件。3.启动Apache服务器。4.phpstorm里打开调试的监听器5.加断点6.点击phpStorm里的Chrome浏览器图标，像run 项目一样，就自动进入debug模式了。7.不想debug？ 关掉phpstorm里debug监听器即可，这时候点击 浏览器图标就只是run了。 配置好之后调试php就一个字，爽！！！ 总结这篇博客是笔者良心之作。教程里有特别多的细节和注意点，应用好这些注意点可以极大方便你的php开发，调试。让你拥有不弱于VS/Eclipse的用户体验！！！如果各位看官觉得有帮助请动动手指转载一下，本人将不胜感激。参考文献PHP 设置调试工具XDebug PHPStorm IDE 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[离线搭建Docker环境]]></title>
      <url>%2Fblog%2F2016%2F12%2F31%2F%E7%A6%BB%E7%BA%BF%E6%90%AD%E5%BB%BAdocker%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[最近由于工作的原因，需要在内网用docker环境搭建靶场来复现一些漏洞的attack。 特此简单记录自己docker的学习过程。 Daocloud官网 准备操作系统：虚拟机 ubuntu 16.04 LTS 我收集的Docker资料包下载 Docker简介Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker是一个由GO语言写的程序运行的“容器”（Linux containers， LXCs）。 Docker是为开发者和系统管理员设计的，用来发布和运行分布式应用程序的一个开放性平台。 Docker相对于VM虚拟机的优势十分明显，那就是轻量和高性能和便捷性。 Docker 架构Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。 应用场景在docker的网站上提到了docker的典型场景：1.Automating the packaging and deployment of applications（使应用的打包与部署自动化）2.Creation of lightweight, private PAAS environments（创建轻量、私密的PAAS环境）3.Automated testing and continuous integration/deployment（使连续的集成/部署、测试自动化）4.Deploying and scaling web apps, databases and backend services（部署、衡量网页app、数据库和后台服务） 局限Docker并不是全能的，设计之初也不是KVM之类虚拟化手段的替代品，简单总结几点：1.Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用2.LXC是基于cgroup等linux kernel功能的，因此container的guest系统只能是linux base的3.隔离性相比KVM之类的虚拟化方案还是有些欠缺，所有container公用一部分的运行库4.网络管理相对简单，主要是基于namespace隔离5.cgroup的cpu和cpuset提供的cpu功能相比KVM的等虚拟化方案相比难以度量(所以dotcloud主要是按内存收费)6.docker对disk的管理比较有限7.container随着用户进程的停止而销毁，container中的log等用户数据不便收集。 Docker安装本教程只针对 ubuntu 16.04 LTS,我是在虚拟机上面安装的。 将下载好的资料包拷贝到ubuntu的文件系统中去。在当前目录空白处点击右键，选择Opern in Terminal。安装vim。在命令行输入 1$ dpkg -i vim-common_2%3a7.4.1689-3ubuntu1.2_amd64.deb 如果报错 1dpkg: error: requested operation requires superuser privilege 在前面加上sudo意为用管理员权限操作，重新输入 1$ sudo dpkg -i vim-common_2%3a7.4.1689-3ubuntu1.2_amd64.deb 依次安装 123$ sudo dpkg -i vim-tiny_2%3a7.4.1689-3ubuntu1.2_amd64.deb $ sudo dpkg -i vim-runtime_2%3a7.4.1689-3ubuntu1.2_all.deb $ sudo dpkg -i vim_2%3a7.4.1689-3ubuntu1.2_amd64.deb 安装AUFS文件系统。 12$ sudo dpkg -i aufs-tools_1%3a3.2+20130722-1.1ubuntu1_amd64.deb ``` 安装cgroup工具。12``` bash$ sudo dpkg -i cgroupfs-mount_1.2_all.deb 想详细了解cgroup的同学可以看看下面两个链接：cgroup介绍、安装和配置文件解析cgroups介绍.pdf 安装liberror-perl（可用来以后配置git）。 1$ sudo dpkg -i liberror-perl_0.17-1.2_all.deb 安装docker-engine（Docker 引擎） The Docker Engine is a lightweight container runtime and robust tooling that builds and runs your container. Docker allows you to package up application code and dependencies together in an isolated container that share the OS kernel on the host system. The in-host daemon communicates with the Docker Client to execute commands to build, ship and run containers.Docker引擎是一个轻量级容器运行时和强大的工具，构建和运行您的容器。Docker允许将应用程序代码和依赖关系打包在一个隔离的容器中，这些容器共享主机系统上的操作系统内核。主机内守护程序与Docker客户端进行通信，以执行命令来构建，运送和运行容器。 Docker Engine runs on both Linux and Windows operating systems on any infrastructure to create the operating environment for your applications. From a single container on a single host to a multi-container application networked across a cluster of hosts, Docker Engine delivers powerful tooling with a very simple user interface.Docker Engine在任何基础架构上的Linux和Windows操作系统上运行，为应用程序创建操作环境。从单个主机上的单个容器到跨群集主机联网的多容器应用程序，Docker Engine提供了具有非常简单的用户界面的强大的工具。 摘自https://www.docker.com 12$ sudo dpkg -i docker-engine_1.12.5-0~ubuntu-xenial_amd64.deb ``` 到这里Docker容器已经安装好了。 查看Docker版本。12``` bash$ docker -v 如果返回Docker version 1.12.5, build 7392c3b,证明前面的操作顺利。 查看Docker镜像。 1$ docker images 如果报错Cannot connect to the Docker daemon. Is the docker daemon running on this host?,在前面加上sudo意为用管理员权限操作，重新输入 1$ sudo docker images 观察到返回： 1REPOSITORY TAG IMAGE ID CREATED SIZE 都是空即为没有镜像的意思，下面我们来导入一个镜像。资料里的bwapp.tar.gz是一个demo，它是一个漏洞环境的镜像。 1$ sudo docker load &lt; bwapp.tar.gz 稍微等一小会儿。查看Docker镜像。 1$ docker images 结果： 123REPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; 41e984bb619b 17 months ago 465.9 MB``` 修改镜像的标签。123``` bash$ sudo docker tag 41e9 bwapp:latest ``` 查看Docker镜像。12``` bash$ sudo docker images 结果：1234``` bashREPOSITORY TAG IMAGE ID CREATED SIZEbwapp latest 41e984bb619b 17 months ago 465.9 MB``` 查看docker镜像所占用的端口。 1$ docker inspect 41e9 如图查看docker镜像所占端口。启动镜像bwapp。 12$ sudo docker run -d -p 0.0.0.0:8000:80 bwapp ``` 前面的”0.0.0.0：”是为了方便局域网中其他ip访问，可以省略。省略后”0.0.0.0:”仅虚拟机的宿主机（物理机）可以访问。8000是物理机中的端口号，80是虚拟机中docker镜像占用的端口号。 返回一长串code即为启动成功。3d23ce867614b04ae7fb7e438fb5676b73e6f9fbc42f232d994a39cbdf6d1621 检查docker占用的线程号确认docker镜像是否启动。12```bash$ sudo docker ps -l 我的运行结果： 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3d23ce867614 bwapp "/run.sh" About a minute ago Up About a minute 80/tcp, 3306/tcp, 0.0.0.0:8000-&gt;80/tcp sick_brown 到这里docker镜像已启动且已做好端口映射。可以在物理机的浏览器中根据虚拟机的ip+刚才给物理机设置的端口号8000即http://192.168.183.131:8000来访问。 注意：第一次在浏览器中访问要在ip和端口号后面输入”/install.php初始化一下”。bwapp是仅我上传的一个demo镜像，用作方便docker的讲解，不属于docker的插件。 让你的Docker连上服务器仓库1234$ cd /etc/docker/$ ls$ touch daemon.json // 将这句话拷贝到daemon.json中： &#123;"insecure-registries": ["192.168.1.105:5000"]&#125; // 192.168.1.105为你的服务器在局域网的ip。$ service docker restart //重启 如果提示没权限，输入 1$ su 接着输入root用户的密码即可保持root权限操作。 如果忘记root用户密码，用以下命令重置root用户密码： 1$ sudo passwd root 拉取服务器仓库中的镜像12$ curl -XGET http://192.168.1.150:5000/v2/_catalog //search 仓库中的镜像 // 添加服务器仓库的ip$ docker pull 192.168.1.150:5000/test_bwapp //拉取一个服务器的镜像 总结因本人水平有限，故此文只作为自己学习过程中的记录。并不是什么教程，如有纰漏，还望指正，定当不胜感激。 参考文献百度百科 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis学习笔记]]></title>
      <url>%2Fblog%2F2016%2F10%2F15%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[mybatis笔记整理。 框架框架是一系列jar包，本质是对JDK功能的扩展。框架是一组程序的集合，包含了一系列的最佳实践，作用是解决某一个领域的问题。最佳实践：实际上是无数程序员经历过无数次尝试之后，总结出来的处理特定问题的特定方法，如果把程序员的自由发挥看作是一条通往成功的途径，最佳实践就是其中的最短路径，能极大的解放生产力。最佳实践三要素：可读性，可维护性，可拓展性。 Web开发中的最佳实践(分层开发模式)JavaEE开发根据职责的纵向划分为：表现层，业务层，持久层。表现层（Predentation Layer）：web/mvc：负责处理与界面交互的相关操作，控制界面跳转（Struts2）业务层（Business Layer）:service：负责复杂的业务逻辑计算和判断（Spring）持久层（Persistent Layer）:dao：负责将业务逻辑数据进行持久化存储（Hibernate/MyBatis） ORM对象关系映射（Object Relational Mapping,简称ORM/OR Mapping）。是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将java程序中的对象自动持久化到关系数据库中。避免直接使用SQL语句对关系型数据库中的数据进行操作。减少代码编写量，提高产品质量。ORM主要解决对象–关系的映射。 面向对象概念 面向关系概念类 表对象 表的行（记录）属性 表的列（字段） ORM的实现思想将关系数据库中表中的记录映射成为对象，以对象的形式展现。程序员可以把对数据库的操作转化为对对象的操作，因此ORM的目的是为了方便开发人员以面向对象的思想来实现对数据库的操作。 ORM采用元数据来描述对象–关系映射细节。元数据通常采用XML格式，并且存放在专门的对象–关系映射文件中。 目前流行的ORM框架：1.JPA:本身是一种ORM规范，不是ORM框架，由各大ORM框架提供实现。2.Hibernate:目前最流行的ORM框架，设计灵巧，性能优秀，文档丰富。3.Mybatis:提供的持久层框架包括SQL Maps和Data Access Objects(DAO)，允许开发人员直接编写SQL等。 mybatis优势mybatis支持普通的SQL查询，存储过程和高级映射的优秀持久层框架。mybatis清除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。mybatis使用简单的XML或注解用于配置和映射，将接口和java的POJOs(Plain Old Java Objects，普通的java对象)映射成数据库中的记录。 使用mybatis1.提供Product对象，IProductDAO，ProductDAOImpl(未实现)，ProductDAOTest。2.使用框架第一步：拷贝jar包。①：mysql驱动②：mybatis核心包：mybatis-3.2.6.jar③：mybatis依赖jar：mybatis目录\lib中所有jar（使用了log4j.properties就可以不用commons-logging-1.1.1.jar）。3.建立mybatis主配置文件。4.建立对象映射配置文件。5.在主配置文件中关联映射文件。6.在对象映射配置文件中写sql。7.加载mybatis主配置文件。 sqlSessionFactory使用步骤（Hibernate/Mybatis）：1.从配置文件（通常是XML配置文件中）得到SessionFactory(相当于DataSource)。2.由SessionFactory产生session(相当于connection，和web中的HttpSession无关)。3.在session中完成对数据的增删改查和事务提交等。4.在用完后关闭session。 sqlSessionFactory一旦被创建，应该在你的应用程序执行期间都存在，没有理由来处理或重新创建它。因此SqlSessionFactory的最佳范围是应用范围，有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。然而这两种方法都不认为是最佳实践。可以考虑依赖注入容器，比如Spring或Google Guice，这样的框架允许你创建支持程序来管理单例sqlSessionFactory的生命周期。 SqlSession:每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能被共享，也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段甚至是实例字段中。也绝不能将SqlSession实例的引用放在任何类型的管理范围中，比如Servlet架构中的HttpSession。如果你现在正用任意的Web框架，要考虑SqlSession放在一个和Http请求对象相似的范围内。换句话说，基于收到的HTTP请求，你可以打开了一个SqlSession，然后返回响应，就可以关闭它了。关闭Session很重要，你应该确保使用finally块来关闭它。 源代码1数据库文件 log4j简介Log4j有三个主要的组件：Loggers(记录器)，Appenders(输出源)和Layouts(布局)。可简单理解为日志类别，日志要输出的地方和日志以何种形式输出，综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。 配置优化1.抽取MybatisUtil。2.添加db.properties属性文件。3.在mybatis主配置文件(MyBatis-config.xml)配置类型别名typeAliases。4.列名和属性名不同resultMap。 源代码2源代码3 多条件查询1.建立高级查询表单对象:XxxQuery/XxxQueryObject(Xxx表示对象名称)。ProductQueryObject(商品的高级查询对象)，封装了商品高级查询表单的数据。该类存放于query包中，query包和dao包同级。2.在IProductDAO中，定义高级查询方法： 1List&lt;Product&gt; query(ProductQueryObject qo); 3.在ProductDAOImpl中提供高级查询方法的实现。 Mybatis-query1 上述查询方法的缺点1.从责任分离上考虑，DAO是不应该做SQL拼接的(DAO是负责做CRUD的，因为查询对象(ProductQueryObject)拥有查询信息，应该把拼接sql责任交给它)。 Mybatis-query2 2.使用了where 1=1,降低性能。 Mybatis-query3 3.拼sql依旧麻烦。 Mybatis-query4 分页逻辑分页(假分页):一次性把内存中符合条件的数据全部查询出来，存放在内存，在翻页的时候，直接从内存中去截取。优点：翻页很快缺点：若数据量大，可能造成内存溢出。 物理分页(真分页):每次翻页都从数据库中去截取数据。优点：不会造成内存溢出缺点：翻页较慢 通过SQL查询出来的数据：1.查询当前的结果集2.查询结果总数 Mybatis-query5Mybatis-query6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdbc复习笔记]]></title>
      <url>%2Fblog%2F2016%2F10%2F07%2Fjdbc%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[jdbc复习笔记。 准备commons-dbcp-1.4-bin.zipcommons-dbcp-1.4-src.zipcommons-pool-1.5.6.jarc3p0-0.9.1.2.jarc3p0-0.9.1.2.src.zip 持久化和JDBC概述持久化持久化（persistence），把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘中加以“固化”，而持久化的实现过程大多通过各种关系型数据库来完成。持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。 在Java中，数据库存取技术只能通过JDBC访问数据库：JDBC访问数据库的形式主要有两种：1).直接使用JDBC的API去访问数据库服务器（MySQL/Oracle）。2).间接使用JDBC的API去访问数据库服务器。第三方O/R Mapping工具，如Hibernate,Mybatis等（底层依然是JDBC）。JDBC是java访问数据库的基石，其他技术都是对JDBC的封装。 JDBCJDBC是一种用于执行SQL语句的java API，可以为多种关系型数据库提供统一访问，它由一组用java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。JDBC的目标是使java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统有过多了解，加快开发过程。java.sql包装是JDBC的API。在开发中使用到的关于JDBC的类/接口全部引入的是java.sql/javax.sql包中的，不要使用各大数据库提供的API。 获取JDBC的连接对象1.加载注册驱动Class.forName(“驱动实现类的全限定名”);MySQL:Class.forName(“com.mysql.jdbc.Driver”);为啥写上这一句话，就会把驱动进行加载注册？步骤1：把com.mysql.jdbc.Driver这份字节码加载进JVM—-&gt;创建Class对象。步骤2：当一份字节码被加载进JVM，就会执行字节码中的静态代码块。见com.mysql.jdbc.Driver源码 1234567static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125; 步骤3：静态代码块中，就是使用DriverManager.registerDriver(new Driver())注册驱动的。 2.使用DriverManager获取连接Connection conn=DriverManager.getConnection(String url,String user,String password); 跟据官方API，从JDBC4.0（jdk1.6）开始，数据库连接驱动包里必须包含注册驱动那句话，所以省略它不会报错。建议仍然手动注册，兼容java5。 常用接口Connection接口表示JDBC的连接对象。 Statement接口用于执行静态SQL(写死的SQL)语句。常用方法： int executeUpdate(String sql) ResultSet executeQuery(String sql) close() PreparedStatement和Statement区别PreparedStatement比Statement优势：1.代码可读性/维护性更高。2.PreparedStatement是预编译语句对象，PreparedStatement的执行性能更高。3.安全性更高，防止SQL注入问题。 ResultSet接口表示查询的结果集(查询结果的封装对象)，是通过执行查询语句得到的。常用方法： boolean next() Xxx getXxx(int columnIndex) : 获取当前行的第几列的数据，从1开始(不建议)。 Xxx getXxx(String columnName) : 获取当前行的执行列名对应列的数据，可以使用别名，注意：Xxx是数据类型，比如String，long，int，boolean等。 Object getObject(int/String columnIndex) : 获取某一列的数据，统统使用Object来接收。 close() ResultSet对象具有指向其当前数据行的光标。最初，光标被置于第一行之前，next方法将光标移动到下一行。因为该方法在ResultSet对象没有下一行时返回false，所以可以在while循环中使用它来迭代结果集。 从ResultSet中取出数据，实质上是取出当前指针指向的当前行的数据。 其实，在表中，一行数据就是一个对象。可以使用一个对象来封装表中的一行数据。比如：使用Product对象，可以封装一行商品数据。若要封装多行，可以使用List搞定。 JDBC事务的细节1.在JDBC中事务是默认自动提交的。在执行DML语句的时候就已经提交事务了。2.事务只对DML语句有效，对于DDL(查询)没效果，查询不会涉及到修改数据库。3.回滚事务在释放资源，释放锁机制。（InnoDB：行锁；MyISAM：表锁）4.在Mysql中，MyISAM不支持外键，不支持事务；InnoDB都支持。 在Spring中有专门的事务管理器（TransactionManager）。 批量操作(batch)当需要成批插入或者更新记录时，可以采用java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。JDBC的批量处理语句包括下面两个方法：addBatch(String) – 添加需要处理的SQL语句或是参数。executeBatch() – 执行批量处理语句。通常我们会遇到两种批量执行SQL语句的情况：多条SQL语句的批量处理。Statement一个SQL语句的批量传参。PreparedStatement Mysql不支持PreparedStatement的性能优化，也不支持批量操作性能优化。Statement:Statement批处理，一次性可以执行多条sql语句，需要编译多次。应用场景：系统初始化（创建表，创建数据等）。批量处理sql语句， int[] st.executeBatch()清除缓存， st.clearBatch()PreparedStatement:PreparedStatement批处理，执行一条sql语句，编译一次，执行sql语句的参数不同。应用场景：表数据初始化。添加批量参数， ps.addBatch() —添加实际参数，执行之前，需要执行 ps.setXxx()设置实际参数执行批处理， int[] ps.executeBatch()清除缓存： ps.clearBatch()清除参数： ps.clearParameter() 大数据类型（BLOB和TEXT）BLOBTINYBLOB，BLOB，MEDIUMBLOB，LONGBLOB都是二进制类型，唯一的不同就是容量不同。可以把二进制的数据保存到数据库，比如可以把一个音频，视频，图片存到数据库中。注意：在开发中往往把二进制文件的保存路径存储到数据库中，而不是把数据存储到数据库。 TEXT用于保存文字比较多（博客/小说）。TINYTEXT，TEXT，MEDIUMTEXT，LONGTEXT，对应着java中的String，在java代码中没有变化。 获取自动生成的主键Statement:int executeUpdate(String sql): 执行DML/SQL语句int executeUpdate(String sql,int autoGeneratedKeys): 参数： autoGeneratedKeys:是否需要返回自动生成的主键 Statement.RETURN_GENERATED_KEYS:要返回 Statement.NO_GENERATED_KEYS:不返回ResultSet getGeneratedKeys() :获取自动生成的主键 PreparedStatement:conn.prepareStatement(String sql,int autoGeneratedKeys);ResultSet getGeneratedKeys() :获取自动生成的主键 连接池目的：重复利用Connection资源。 概述在java中，使用javax.sql.DataSource来表示连接池对象。DataSource:数据源，其实就是连接池，Connection Pool。 为什么必须使用数据库连接池：普通的JDBC数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将Connection加载到内存中，再验证用户名和密码。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接，这样的方式将会消耗大量的资源和时间，数据库的连接资源并没有得到很好的重复利用，若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。对于每一次数据库连接，使用完后都得断开，否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄露，最终将导致重启数据库。这种开发不能控制被创建的连接对象数，系统资源会被毫无顾忌的分配出去，如连接过多，也可能导致内存泄露，服务器崩溃。连接池的技术比较多，SUN公司仅仅是提供了DataSource的接口，不提供任何实现。由各大服务器厂商提供DataSource的实现（Tomcat,WebLogic）。 属性eg: 初始化连接数=5 设置事先先在连接池存储个5个Connection对象。 设置最大连接数=10 设置在连接池中最多有10个Connection对象。 最小连接数=2 设置在连接池中最少有两个Connection对象。 超时时间=5min 设置一个客户如果5分钟没有动作，则会被自动释放。 客户的最大等待时间=2min 设置客户最多有两分钟时间去获取Connection对象，若超过2分钟，还没获取到，则系统提示，稍后再试… 使用连接池和不使用连接池在代码上的区别不使用连接池：使用DriverManager来获取Connection对象。Connection conn=DriverManager.getConnection(url,username,password);使用连接池：直接找连接池（DataSource对象），取出Connection即可。在创建DataSource对象时，设置连接数据库的url,user,password。Connection conn=DataSource对象.getConnection();接下来的代码和以前相同。 释放连接：代码：Connection对象.close();不使用连接池：直接和数据库服务器建立连接关系，而断开也是和数据库服务器断开连接。使用连接池：直接和连接池建立连接关系，而断开也是把Connection对象还给连接池，供其他客户使用。没有真正的和数据库断开。如此一来，一个Connection对象就得到了充分的利用。 常见的连接池技术dbcp:Spring推荐的连接池技术c3p0:Hibernate推荐的连接池技术 dbcp准备：1.拷贝jar包。commons-dbcp-1.4.jar，commons-pool-1.5.6.jar。2.阅读文档。解压commons-dbcp-1.4-src.zip，查看commons-dbcp-1.4-src -&gt; doc -&gt; BasicDataSourceExample.java，里面有连接池的使用案例。步骤：1.创建DataSource对象。2.从DataSource对象中获取Connection对象。3.接下来使用Connection就和以前相同。 注意：dbcp.properties中的key必须是BasicDataSource对象里的属性（setter）。否则无法把对应的配置信息，设置到DBCP连接池中。dbcp.properties: driverClassName= url= username= password= initialSize= //连接池的最大值 maxActive= //连接池的最大空闲数 maxIdle= c3p0准备：1.拷贝jar包。c3p0-0.9.1.2.jar。2.阅读文档。解压c3p0-0.9.1.2.src.zip，查看c3p0-0.9.1.2.src -&gt; src -&gt; doc -&gt; index.html -&gt; Quickstart，里面有连接池的使用案例。步骤：1.创建DataSource对象。2.从DataSource对象中获取Connection对象。3.接下来使用Connection就和以前相同。 注意：1.文件名称必须叫作c3p0.properties。2.c3p0.properties必须放在CLASSPATH的根路径下。3.c3p0.properties文件中的key必须以”c3p0.”作为前缀。4.c3p0.properties文件中的key必须是ComboPooledDataSource类的属性名。 源代码1源代码2数据库文件 参考文献c3p0三种配置方式Connection实例是线程安全的吗]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速搭建Maven环境并创建web项目]]></title>
      <url>%2Fblog%2F2016%2F10%2F04%2Fmaven%E7%8E%AF%E5%A2%83%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Maven是一个项目管理工具，它能够很方便的帮你管理项目报告，生成站点，管理JAR文件，等等。 准备登录Maven官网下载Maven。我安装的Maven版本是apache-maven-3.3.9。值得注意的是，Maven需要在java环境运行，因此你的电脑应该装有jdk。 配置Maven环境将下载文件解压，然后设置maven环境。如果你配置过jdk的话，这里对你应该不难。如我的maven环境为：D:\apache-maven-3.3.9我的电脑—-属性—-高级—-环境变量—-系统环境变量—-新建变量名：maven_HOME变量值：D:\apache-maven-3.3.9找到path在环境变量值尾部加入：;%maven_HOME%\bin;—前面注意分号打开命令提示符（开始—运行—cmd）,检查我们的java环境和maven环境是否有误。 1$ mvn -v 修改仓库位置maven里面有一个repository的概念，仓库用于存放我们项目所依赖的所有jar包,当我们的项目依赖于某个jar时，maven会去repository里面去找。repository分两种，一种是远程的，一种是本地的。如果有几个project都用到junit，我们可以把junit放在repository里面，几个project可以公用，节约存储空间而且方便管理，这个repository的位置可以在pom.xml里面设置。本地的默认的路径是安装用户的目录下的 .m2\repository文件夹，下面来修改我们的仓库地址。我的仓库路径：D:_MavenRepository—-这个路径是我自己创建，你可以将路径创建在任何位置。我们打开…\apache-maven-3.3.9\conf\目录下的setting.xml文件，找到localRepository标签，此时是被注释掉的，我们解除注释，然后配置一个路径设置成我们创建的仓库路径。打开命令提示符，初始化Maven仓库。 1$ mvn help:system 如果运行的过程中没有错误，打开我们仓库（D:_MavenRepository）会发现里面多了一些文件。这些文件就是我们从maven的中央仓库下载到本地仓库的。上面的这个命令会打印出所有的java系统属性和环境变量。这些信息对我们日常的编程工作很有帮助。 创建一个Maven项目用命令行创建Maven项目创建一个存放Maven项目的文件夹，我这里是在D盘创建的，命名为_MavenPrj。切换到Maven目录下（注意：跳过这步操作会将项目建立在默认的C/Users/CurrentUser/ 目录下，就很尴尬了。） 1$ cd _MavenPrj 通过命令行方式创建一个普通项目： 1$ mvn archetype:generate -DgroupId=com.lee.test -DartifactId=testMaven -DpackageName=com.lee.test -Dversion=1.0 1)archetype:generate， 这是一个maven的plugin，用来从一个archetype创建一个project。2)-DgroupId和-DartifactId用来放在pom.xml文件里面，作为当前创建的project的描述信息。 因为是第一次构建项目，所有依赖的jar包都要从maven的中央仓库下载，所以需要时间等待。等以后我们的本地仓库中积累了我们常用的jar包后，我们的开发将变得非常规范和方便。中间如果有输入提示信息，直接回车使用默认值就可以了。这条命令执行完后，会在你的当前目录下生成一个名为testMaven的目录： 创建项目时卡顿的解决办法如果你在执行命令行时卡在Generating project in Interactive mode这一步，是因为maven在从远程拉取信息，使用 -DarchetypeCatalog=internal 参数让它不要从远程服务器上取catalog。添加这句话之后,就不会卡死了。就会进入交互阶段,一步步询问。每一步如果有默认选项直接按enter即可。 1$ mvn archetype:generate -DarchetypeCatalog=internal 按照交互提示依次输入groupId、artifactId、version、package如下图。也可以使用下面的命令跳过填写groupId、artifactId、version、package阶段，直接生成项目。 1mvn archetype:generate -DgroupId=com.lee.test -DartifactId=Demo -Dpackage=com.lee.test -Dversion=1.0-SNAPSHOT -DarchetypeCatalog=internal 了解pom.xml文件另外maven还生成了一个重要的文件pom.xml，maven就是通过这个文件来来管理整个project，可以理解位类似于eclipse的.project文件。默认生成的pom.xml文件的内容如下： 12345678910111213141516171819202122232425&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lee.test&lt;/groupId&gt; &lt;artifactId&gt;testMaven&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;testMaven&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Ø project：pom.xml文件中的顶层元素；Ø modelVersion：指明POM使用的对象模型的版本。这个值很少改动。Ø groupId：指明创建项目的组织或者小组的唯一标识。GroupId是项目的关键标识，典型的，此标识以组织的完全限定名来定义。比如，org.apache.maven.plugins是所有Maven插件项目指定的groupId。Ø artifactId：指明此项目产生的主要产品的基本名称。项目的主要产品通常为一个JAR文件。第二，像源代码包通常使用artifactId作为最后名称的一部分。典型的产品名称使用这个格式： - . (比如：myapp-1.0.jar)。Ø version：项目产品的版本号。Maven帮助你管理版本，可以经常看到SNAPSHOT这个版本，表明项目处于开发阶段。Ø packaging：这个project的打包的类型，一般是war、jar等值。Ø name：项目的显示名称，通常用于maven产生的文档中。Ø url：指定项目站点，通常用于maven产生的文档中。Ø description：描述此项目，通常用于maven产生的文档中。 对于一个项目中只有下面的一部分是是我们需要关注的： 12345&lt;groupId&gt;com.lee.test&lt;/groupId&gt;&lt;artifactId&gt;testMaven&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt; 编译项目代码我们的项目已经创建完成。但我们点开目录发现，它并不是我们eclipse所需要的项目目录格式。我们需要把它构建成我们eclipse可以导入的项目。 在命令提示符下切换到我们的创建的项目目录（D:_MavenPrj\testMaven）下，执行 1$ mvn clean compile Clean 告诉maven清理输出目录target/，compile告诉maven编译项目主代码。编译完后maven会创建一个target目录去保存编译结果。 我们需要编译成一个什么样的内容，以及要输出到什么地方等等，都是可以在pom.xml文件里面配置的，但是因为我们目前并没有指定这些内容，所以maven会使用默认值。不要急，我们又需要一段时间来下载相关jar包。第一次用maven要学会淡定。 项目是编译完了，但项目的目录结构还不是我们想要的eclipse的项目结构，是不能导入到eclipse中的。所以，还需要执行一个命令： 1mvn eclipse:eclipse 命令执行完成后就得到我们需要的项目目录了。 用Eclipse创建Maven项目第一次使用要先配置Eclipse中的Maven仓库位置。 打开我们的eclipse。查看eclipse指向的maven仓库路径：Window-&gt; Perferences-&gt; java-&gt; Build Path-&gt; Classpath Variables，观察M2_REPO的值，如果不是你自定义的本地仓库的路径，那么需要对其进行配置。配置方法：Window-&gt; Perferences-&gt; Maven-&gt; installations-&gt; 然后点击Add，添加自己安装的maven，找到自己安装的maven文件的根目录，并点击Apply -&gt; OK。 下面来用Eclipse创建一个Maven的webapp项目。 开启Eclipse，右键new -&gt; other，如下图找到Maven Project。选择Maven Project，显示创建maven项目的窗口，勾选如下图所示，Create a simple project。输入Maven项目的基本信息，如下图所示。完成maven项目的创建，生成相应的maven项目结构，如下图。这时还要对项目属性进行一些设置。选择项目，右键选择Properties，进入属性页面，点击Project Facets，如下图。因为我的jdk版本是1.7，所以我选择java版本为1.7。点击 Dynamic Web Module 前的复选框，将它去掉，点击Apply。选择Dynamic Web Module 的版本为3.0(跟jdk1.7对应)。在这个页面再次勾选 Dynamic Web Module 前的复选框，会看到最下面出现了 Further configuration available… 的超链接。点击 Further configuration available…，如下图。配置src/main/webapp，并勾选生成web.xml的选项，如下图。点击OK,如下所示，webapp目录结构显示出来了：此时还需要检查src/main/webapp为“/”项目的根目录，如果不是，需要配置，如下图。在webapp文件夹下新建一个jsp页面，index.jsp。写一句话 hello world!Run As -&gt; Run on Server，运行服务器。大功告成！ 总结Maven搭建的过程，总的来说并不难，一步一步下来即可。我相信一定有人有比我更好更方便的搭建方式，本文仅抛砖引玉，欢迎交流学习。 参考文献Maven学习总结:基本概念maven环境快速搭建Maven使用archetype迅速生成项目骨架eclipse创建maven web项目时，index.jsp报错Eclipse+Maven创建webapp项目&lt;一&gt;项目管理利器——maven 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ssh整合示例]]></title>
      <url>%2Fblog%2F2016%2F09%2F24%2Fssh%E6%95%B4%E5%90%88%E7%A4%BA%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[ssh整合的一个demo。 准备spring4-requiredstruts2.3.15.3-blankhibernate-release-4.2.4.Final 步骤加入Spring加入jar包spring4-required 配置web.xml文件在web.xml文件中 alt+ / 选择 ContextLoaderListener。 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;!-- needed for ContextLoaderListener --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;location&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstraps the root web application context before servlet initialization --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 修改web.xml。 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 加入Spring的配置文件new -&gt; Source Folder新建一个源码包conf。在conf源码包下新建applicationContext.xml配置文件。 加入Hibernate1).同时建立持久化类，和其对应的 .hbm.xml文件，生成对应的数据表。2).Spring整合Hibernate。3).步骤：①.加入jar包加入hibernate-release-4.2.4.Final-&gt;lib-&gt;required文件夹下的全部8个jar包。②.在类路径下加入hibernate.cfg.xml文件，在其中配置hibernate的基本属性。新建hibernate.cfg.xml配置文件。 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 配置 hibernate的基本属性 --&gt; &lt;!-- 方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 是否显示及格式化SQL --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 生成数据表的策略 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 二级缓存相关 --&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; ③.建立持久化类，和其对应的 .hbm.xml文件在src下新建包com.leezp.ssh.entities。在该包下新建Department.java。 12345678910111213141516171819202122232425package com.leezp.ssh.entities;public class Department &#123; private Integer id; private String departmentName; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getDepartmentName() &#123; return departmentName; &#125; public void setDepartmentName(String departmentName) &#123; this.departmentName = departmentName; &#125; &#125; 在该包下新建Employee.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.leezp.ssh.entities;import java.sql.Date;public class Employee &#123; private Integer id; // 不能被修改 private String lastName; private String email; // 从前端传入的是String类型，所以需要注意转换 private Date birth; // 不能被修改 private Date createTime; // 单向多对一的关联关系 private Department department; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; &#125; 在该包下新建 Hibernate XML Mapping file(hbm.xml)。Hibernate会帮助我们根据entities自动生成内容。查看Employee.hbm.xml。 123456789101112131415161718192021222324252627&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2017-3-14 15:46:11 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt; &lt;class name="com.leezp.ssh.entities.Employee" table="EMPLOYEE"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="ID" /&gt; &lt;generator class="assigned" /&gt; &lt;/id&gt; &lt;property name="lastName" type="java.lang.String"&gt; &lt;column name="LASTNAME" /&gt; &lt;/property&gt; &lt;property name="email" type="java.lang.String"&gt; &lt;column name="EMAIL" /&gt; &lt;/property&gt; &lt;property name="birth" type="java.sql.Date"&gt; &lt;column name="BIRTH" /&gt; &lt;/property&gt; &lt;property name="createTime" type="java.sql.Date"&gt; &lt;column name="CREATETIME" /&gt; &lt;/property&gt; &lt;many-to-one name="department" class="com.leezp.ssh.entities.Department" fetch="join"&gt; &lt;column name="DEPARTMENT" /&gt; &lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 查看Department.hbm.xml。 123456789101112131415&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2017-3-14 15:46:11 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt; &lt;class name="com.leezp.ssh.entities.Department" table="DEPARTMENT"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="ID" /&gt; &lt;generator class="assigned" /&gt; &lt;/id&gt; &lt;property name="departmentName" type="java.lang.String"&gt; &lt;column name="DEPARTMENTNAME" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 修改Department.hbm.xml。 123456789101112131415&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2017-3-14 15:46:11 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt; &lt;class name="com.leezp.ssh.entities.Department" table="SSH_DEPARTMENT"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="ID" /&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;property name="departmentName" type="java.lang.String"&gt; &lt;column name="DEPARTMENT_NAME" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 修改Employee.hbm.xml。 12345678910111213141516171819202122232425262728&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2017-3-14 15:46:11 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt; &lt;class name="com.leezp.ssh.entities.Employee" table="SSH_EMPLOYEE"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="ID" /&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;property name="lastName" type="java.lang.String"&gt; &lt;column name="LAST_NAME" /&gt; &lt;/property&gt; &lt;property name="email" type="java.lang.String"&gt; &lt;column name="EMAIL" /&gt; &lt;/property&gt; &lt;property name="birth" type="java.sql.Date"&gt; &lt;column name="BIRTH" /&gt; &lt;/property&gt; &lt;property name="createTime" type="java.sql.Date"&gt; &lt;column name="CREATE_TIME" /&gt; &lt;/property&gt; &lt;!-- 映射单向多对一的关联关系 --&gt; &lt;many-to-one name="department" class="com.leezp.ssh.entities.Department"&gt; &lt;column name="DEPARTMENT_ID" /&gt; &lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; ④.和Spring进行整合i.加入c3p0和MySQL的驱动。c3p0-0.9.1.2.jarmysql-connector-java-5.1.22-bin.jarii.在Spring的配置文件中配置:数据源，SessionFactory。 在conf源码包下面新建db.properties属性文件。 1234567jdbc.user=rootjdbc.password=rootjdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/ssh_demojdbc.initPoolSize=5jdbc.maxPoolSize=10 修改Spring配置文件applicationContext.xml。 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置C3P0数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 路径给Spring用的情况可以加classpath:，指的是编译后的class路径。/WEB-INF/classes/，编译后的class文件，资源文件，依赖文件等都会放在这个路径下。 --&gt; &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;!-- 注意将复制的com.leezp.ssh.entities中的"."换成"/"并在最后加上"/*.hbm.xml" --&gt; &lt;property name="mappingLocations" value="classpath:com/leezp/ssh/entities/*.hbm.xml"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在mysql新建一个空的数据库ssh_demo。启动项目，会看到生成对应的数据表。在数据库里向ssh_department表添加数据。修改Spring配置文件applicationContext.xml配置声明式事务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置C3P0数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置SessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 路径给Spring用的情况可以加classpath:，指的是编译后的class路径。/WEB-INF/classes/，编译后的class文件，资源文件，依赖文件等都会放在这个路径下。 --&gt; &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;!-- 注意将复制的com.leezp.ssh.entities中的"."换成"/"并在最后加上"/*.hbm.xml" --&gt; &lt;property name="mappingLocations" value="classpath:com/leezp/ssh/entities/*.hbm.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Spring的声明式事务 --&gt; &lt;!-- 1.配置hibernate的事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2.配置事务属性 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 配置get开头的 read-only="true --&gt; &lt;tx:method name="get*" read-only="true" /&gt; &lt;!-- 配置默认值 --&gt; &lt;tx:method name="*" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 3.配置事务切入点 --&gt; &lt;aop:config&gt; &lt;!-- com.leezp.ssh.service包下的所有类的所有方法所有参数 --&gt; &lt;aop:pointcut expression="execution(* com.leezp.ssh.service.*.*(..))" id="txPointCut" /&gt; &lt;!-- 4.把事务属性和事务切入点关联起来 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 新建包com.leezp.ssh.service。 获取源代码 加入Struts2加入jar包asm-3.3.jarasm-commons-3.3.jarasm-tree-3.3.jarcommons-fileupload-1.3.jarcommons-io-2.0.1.jarcommons-lang3-3.1.jarcommons-logging-1.1.3.jarfreemarker-2.3.19.jarjavassist-3.11.0.GA.jarlog4j-1.2.17.jarognl-3.0.6.jarstruts2-core-2.3.15.3.jarxwork-core-2.3.15.3.jar若有重复的jar包，则需要删除版本较低的。javassist-3.11.0.GA.jar 在web.xml文件中配置Struts2的Filter复制struts2官方示例web.xml中的如下代码到项目的web.xml文件中。123456789&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 加入Struts2的配置文件复制struts2官方配置文件struts.xml到conf源码包下。 修改struts.xml。 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;!-- 这是利用Struts2里面的自动匹配特性。*代表通配符，可以匹配任何一个字符串,[1]表示匹配的参数。 --&gt; &lt;!-- 举个例子来说，如果你在xml文件中做了这个配置，那么当你页面里面有一个form &lt;form action="/emp-add" method="post"&gt; 那么，*匹配到的就是“add”,同时method="&#123;1&#125;"，实际上就是method="add"。 --&gt; &lt;!-- 假设有两个参数，如果在xml里面的配置是 &lt;action name="emp-*-*" class="&#123;1&#125;Action" method="&#123;2&#125;"&gt; 那么第一个星号对应的是&#123;1&#125;,第二个星号对应的是&#123;2&#125; --&gt; &lt;!-- 例如，页面里面有&lt;form action="/emp-employee-add" method="post"&gt; 那么实际上的意思就是 class="employeeAction" method="add" --&gt; &lt;!-- **这样做的好处就是我们不必为增、删、改、查方法写四个&lt;action&gt;配置。** --&gt; &lt;!-- 通配符还可以用来节省xml文件中的代码量 --&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;/package&gt;&lt;/struts&gt; Struts2整合Spring①.加入Struts2的Spring插件的jar包。struts2-spring-plugin-2.3.15.3.jar②.在Spring的配置文件中正常配置Action，注意Action的scope为prototype。 在conf源码包下新建applicationContext-beans.xml配置文件。 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;/beans&gt; 在src下新建包com.leezp.ssh.actions。 在该包下新建EmployeeAction.java。 12345package com.leezp.ssh.actions;public class EmployeeAction &#123; &#125; 修改applicationContext-beans.xml配置文件。 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="employeeAction" class="com.leezp.ssh.actions.EmployeeAction" scope="prototype"&gt;&lt;/bean&gt;&lt;/beans&gt; ③.在Struts2的配置文件中配置Action时，class属性指向该Action在IOC中的id。 修改struts.xml配置文件。 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;action name="emp-*" class="employeeAction" method="&#123;1&#125;"&gt;&lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 向数据库中的表ssh_employee添加两条用于测试的数据。新建一个web页面index.jsp。 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="emp-list"&gt;List All Employees&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 修改前面建好的EmployeeAction.java。为它添加与index.jsp里”emp-list”对应的list()方法。 12345678910111213141516package com.leezp.ssh.actions;import com.opensymphony.xwork2.ActionSupport;public class EmployeeAction extends ActionSupport &#123; /** * */ private static final long serialVersionUID = 1L; public String list() &#123; return "list"; &#125;&#125; 添加包com.leezp.ssh.dao。在该包下新建EmployeeDao.java。 12345678910111213141516171819202122232425262728293031323334package com.leezp.ssh.dao;import java.util.List;import org.hibernate.Session;import org.hibernate.SessionFactory;import com.leezp.ssh.entities.Employee;public class EmployeeDao &#123; private SessionFactory sessionFactory; public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125; public Session getSession() &#123; return this.sessionFactory.getCurrentSession(); &#125; public List&lt;Employee&gt; getAll() &#123; // 迫切左外连接 // Query query = // getSession.createQuery(" from Employee e left outer join fetch e.department o"); // Iterator iter = query.list().iterator(); // 说明： // 关键字：left join fetch // 返回结果为Employee类型，再通过Employee对象导航到department对象 String hql = " from Employee e left outer join fetch e.department "; return getSession().createQuery(hql).list(); &#125;&#125; 在包com.leezp.ssh.service下新建EmployeeService.java。 12345678910111213141516171819package com.leezp.ssh.service;import java.util.List;import com.leezp.ssh.dao.EmployeeDao;import com.leezp.ssh.entities.Employee;public class EmployeeService &#123; private EmployeeDao employeeDao; public void setEmployeeDao(EmployeeDao employeeDao) &#123; this.employeeDao = employeeDao; &#125; public List&lt;Employee&gt; getAll() &#123; return employeeDao.getAll(); &#125;&#125; 修改EmployeeAction.java。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.leezp.ssh.actions;import java.util.Map;import org.apache.struts2.interceptor.RequestAware;import com.leezp.ssh.service.EmployeeService;import com.opensymphony.xwork2.ActionSupport;/** * 实现RequestAware请求域 * * @author Lee * */public class EmployeeAction extends ActionSupport implements RequestAware &#123; /** * */ private static final long serialVersionUID = 1L; private EmployeeService employeeService; public void setEmployeeService(EmployeeService employeeService) &#123; this.employeeService = employeeService; &#125; public String list() &#123; request.put("employees", employeeService.getAll()); return "list"; &#125; private Map&lt;String, Object&gt; request; @Override public void setRequest(Map&lt;String, Object&gt; arg0) &#123; this.request = arg0; &#125;&#125; 在applicationContext.xml中配置bean。 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="employeeDao" class="com.leezp.ssh.dao.EmployeeDao"&gt; &lt;!-- 这里的ref指向的sessionFactory在另一个配置文件 --&gt; &lt;!-- ref指向不同配置文件时，需要在web.xml的&lt;context-param&gt;中修改配置为 &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt; --&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="employeeService" class="com.leezp.ssh.service.EmployeeService"&gt; &lt;property name="employeeDao" ref="employeeDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="employeeAction" class="com.leezp.ssh.actions.EmployeeAction" scope="prototype"&gt; &lt;property name="employeeService" ref="employeeService"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 修改web.xml中的&lt;param-value&gt;标签为&lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt;。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置Struts2的Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 修改struts.xml配置文件，添加一个结果集的返回页面emp-list.jsp。 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;!-- 这是利用Struts2里面的自动匹配特性。*代表通配符，可以匹配任何一个字符串,[1]表示匹配的参数。 --&gt; &lt;!-- 举个例子来说，如果你在xml文件中做了这个配置，那么当你页面里面有一个form &lt;form action="/emp-add" method="post"&gt; 那么，*匹配到的就是“add”,同时method="&#123;1&#125;"，实际上就是method="add"。 --&gt; &lt;!-- 假设有两个参数，如果在xml里面的配置是 &lt;action name="emp-*-*" class="&#123;1&#125;Action" method="&#123;2&#125;"&gt; 那么第一个星号对应的是&#123;1&#125;,第二个星号对应的是&#123;2&#125; --&gt; &lt;!-- 例如，页面里面有&lt;form action="/emp-employee-add" method="post"&gt; 那么实际上的意思就是 class="employeeAction" method="add" --&gt; &lt;!-- **这样做的好处就是我们不必为增、删、改、查方法写四个&lt;action&gt;配置。** --&gt; &lt;!-- 通配符还可以用来节省xml文件中的代码量 --&gt; &lt;action name="emp-*" class="employeeAction" method="&#123;1&#125;"&gt; &lt;result name="list"&gt;/WEB-INF/views/emp-list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在WEB-INF目录下新建views文件夹。配置Eclipse中新建的web页面的默认编码：Window-&gt;Preferences-&gt;输入encoding，选择JSP Files，在右侧的Encoding下拉框选择UTF-8，点击保存。在views文件夹下新建web页面emp-list.jsp，这时看到它的默认编码已经变成了UTF-8。在emp-list.jsp中导入struts2的标签&lt;%@ taglib prefix=”s” uri=”/struts-tags”%&gt;并和前台页面显示绑定。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;Employee List Page&lt;/h4&gt; &lt;s:if test="#request.employees==null || #request.employees.size()==0 "&gt; 没有任何员工信息 &lt;/s:if&gt; &lt;s:else&gt; &lt;table border="1" cellpadding="10" cellspacing="0"&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;LASTNAME&lt;/td&gt; &lt;td&gt;EMAIL&lt;/td&gt; &lt;td&gt;BIRTH&lt;/td&gt; &lt;td&gt;CREATETIME&lt;/td&gt; &lt;td&gt;DEPT&lt;/td&gt; &lt;/tr&gt; &lt;s:iterator value="#request.employees"&gt; &lt;tr&gt; &lt;td&gt;$&#123;id &#125;&lt;/td&gt; &lt;td&gt;$&#123;lastName &#125;&lt;/td&gt; &lt;td&gt;$&#123;email &#125;&lt;/td&gt; &lt;td&gt;$&#123;birth &#125;&lt;/td&gt; &lt;td&gt;$&#123;createTime &#125;&lt;/td&gt; &lt;td&gt;$&#123;department.departmentName &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;/s:else&gt; &lt;/body&gt;&lt;/html&gt; 开启服务器运行项目。 获取源代码 业务需求获取所有的员工信息若在Dao中只查询Employee的信息，而且Employee和Department还是使用的懒加载，页面上如果需要显示员工信息，此时会出现懒加载异常，代理对象不能被初始化org.hibernate.LazyInitializationException: could not initialize proxy - no Session。eg:EmployeeDao.java没有查询department。同时修改Employee.hbm.xml文件禁止懒加载。解决方法：①.关闭懒加载 lazy=”false”，不推荐使用，因为查询了很多不需要的数据，影响性能。获取源代码②.获取Employee时使用迫切左外连接同时初始化其关联的Department对象。③.使用OpenSessionInViewFilter:页面加载时开启Session，页面加载完关Session，见文末参考文献《懒加载异常的解决办法》。 删除员工信息在emp-list.jsp页面里添加“删除”功能的超链接。在EmployeeAction.java里添加id属性和delete方法。在EmployeeDao.java里添加delete()方法的数据库操作语句。在业务层EmployeeService.java里添加调用employeeDao。修改EmployeeAction.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.leezp.ssh.actions;import java.util.Map;import org.apache.struts2.interceptor.RequestAware;import com.leezp.ssh.service.EmployeeService;import com.opensymphony.xwork2.ActionSupport;/** * 实现RequestAware请求域 * * @author Lee * */public class EmployeeAction extends ActionSupport implements RequestAware &#123; /** * */ private static final long serialVersionUID = 1L; private EmployeeService employeeService; public void setEmployeeService(EmployeeService employeeService) &#123; this.employeeService = employeeService; &#125; public String list() &#123; request.put("employees", employeeService.getAll()); return "list"; &#125; private Integer id; public void setId(Integer id) &#123; this.id = id; &#125; public String delete() &#123; employeeService.delete(id); return SUCCESS; &#125; private Map&lt;String, Object&gt; request; @Override public void setRequest(Map&lt;String, Object&gt; arg0) &#123; this.request = arg0; &#125;&#125; 这时候要在struts.xml里配置返回的数据如何绑定web页面。注意：name后参数应该小写，应该改成如下图。启动服务器运行项目。点击“删除”超链接可以删除一行数据。 获取源代码 删除时弹出“确定删除吗？”提示信息并使用ajax异步删除在WebContent文件夹下新建文件夹scripts。将jquery-1.9.1.min.js添加到scripts文件夹下。 修改emp-list.jsp。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;!-- 开发时推荐写绝对路径--&gt;&lt;script type="text/javascript" src="scripts/jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; //1.点击delete时，弹出 确定是要删除xx的信息吗？若确定，执行删除，若不确定，则取消 $(".delete").click(function() &#123; var lastName = $(this).next(":input").val(); //var lastName = $(this).next(":hidden").val();//等价于上面一句 var flag = confirm("确定要删除" + lastName + "的信息吗?"); if (flag) &#123; var $tr = $(this).parent().parent();//,$(this)取出当前对象并转换为jQuery对象 //删除，使用Ajax的方式 //获取url var url = this.href; //获取删除时间 var args = &#123; "time" : new Date() &#125;; $.post(url, args, function(data) &#123; //若data的返回值为1，则提示删除成功，且把当前行删除 if (data == "1") &#123; alert("删除成功！"); $tr.remove();//删除页面显示的整行 &#125; else &#123; //若data的返回值不是1，提示删除失败 alert("删除失败！"); &#125; &#125;); &#125; //取消超链接的默认行为 return false; &#125;); &#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;Employee List Page&lt;/h4&gt; &lt;s:if test="#request.employees==null || #request.employees.size()==0 "&gt; 没有任何员工信息 &lt;/s:if&gt; &lt;s:else&gt; &lt;table border="1" cellpadding="10" cellspacing="0"&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;LASTNAME&lt;/td&gt; &lt;td&gt;EMAIL&lt;/td&gt; &lt;td&gt;BIRTH&lt;/td&gt; &lt;td&gt;CREATETIME&lt;/td&gt; &lt;td&gt;DEPT&lt;/td&gt; &lt;td&gt;DELETE&lt;/td&gt; &lt;/tr&gt; &lt;s:iterator value="#request.employees"&gt; &lt;tr&gt; &lt;td&gt;$&#123;id &#125;&lt;/td&gt; &lt;td&gt;$&#123;lastName &#125;&lt;/td&gt; &lt;td&gt;$&#123;email &#125;&lt;/td&gt; &lt;td&gt;$&#123;birth &#125;&lt;/td&gt; &lt;td&gt;$&#123;createTime &#125;&lt;/td&gt; &lt;td&gt;$&#123;department.departmentName &#125;&lt;/td&gt; &lt;td&gt;&lt;a href="emp-delete?id=$&#123;id &#125;" class="delete"&gt;Delete&lt;/a&gt; &lt;input type="hidden" value="$&#123;lastName &#125;"&gt;&lt;/td&gt; &lt;!-- 设置一个隐藏域 --&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/table&gt; &lt;/s:else&gt;&lt;/body&gt;&lt;/html&gt; 修改EmployeeAction.java。修改struts.xml配置文件。 获取源代码 建立添加员工页面并绑定部门信息下拉框①.显示表单页面：需要先查询所有的部门信息②.使用Struts2的ModelDriven和Preparable拦截器③.时间是一个字符串，需要转为一个Date类型的对象 在index.jsp添加一个新增员工的链接。向EmployeeAction.java类中新增一个input()方法。 123public String input()&#123; return INPUT;&#125; 在com.leezp.ssh.dao包下面新建一个Dao,DepartmentDao.java。因为EmployeeDao.java和DepartmentDao.java都需要使用相同的代码操作SessionFactory，所以这里将处理SessionFactory的代码提取出来。 123456789private SessionFactory sessionFactory; public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125; public Session getSession() &#123; return this.sessionFactory.getCurrentSession(); &#125; 再com.leezp.ssh.dao包下新建一个BaseDao.java。 1234567891011121314151617package com.leezp.ssh.dao;import org.hibernate.Session;import org.hibernate.SessionFactory;public class BaseDao &#123; private SessionFactory sessionFactory; public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125; public Session getSession() &#123; return this.sessionFactory.getCurrentSession(); &#125;&#125; 使EmployeeDao.java继承BaseDao.java。 12345678910111213141516171819202122232425262728293031package com.leezp.ssh.dao;import java.util.List;import org.hibernate.Session;import org.hibernate.SessionFactory;import com.leezp.ssh.entities.Employee;public class EmployeeDao extends BaseDao &#123; public void delete(Integer id) &#123; // 注意大小写与entities里面一致 String hql = " delete from Employee e where e.id=? "; getSession().createQuery(hql).setInteger(0, id).executeUpdate(); &#125; public List&lt;Employee&gt; getAll() &#123; // 迫切左外连接 // Query query = // getSession.createQuery(" from Employee e left outer join fetch e.department o"); // Iterator iter = query.list().iterator(); // 说明： // 关键字：left join fetch // 返回结果为Employee类型，再通过Employee对象导航到department对象 // String hql = " from Employee e "; String hql = " from Employee e left outer join fetch e.department "; return getSession().createQuery(hql).list(); &#125;&#125; 修改DepartmentDao.java。 12345678910111213package com.leezp.ssh.dao;import java.util.List;import com.leezp.ssh.entities.Department;public class DepartmentDao extends BaseDao &#123; public List&lt;Department&gt; getAll() &#123; String hql = " from Department "; return getSession().createQuery(hql).list(); &#125;&#125; 在com.leezp.ssh.service包下新建DepartmentService.java。 12345678910111213141516171819package com.leezp.ssh.service;import java.util.List;import com.leezp.ssh.dao.DepartmentDao;import com.leezp.ssh.entities.Department;public class DepartmentService &#123; private DepartmentDao departmentDao; public void setDepartmentDao(DepartmentDao departmentDao) &#123; this.departmentDao = departmentDao; &#125; public List&lt;Department&gt; getAll() &#123; return departmentDao.getAll(); &#125;&#125; 在IOC容器里配置刚才添加的bean,在applicationContext-beans.xml配置文件里配置bean添加如下图所示代码。修改EmployeeAction.java里调用DepartmentService。修改struts.xml配置文件添加如下图所示代码。在views文件夹下新建emp-input.jsp。 123456789101112131415161718192021222324252627&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;Employee Input Page&lt;/h4&gt; &lt;s:form action="emp-save" method="post"&gt; &lt;!-- label属性为在页面显示的值 --&gt; &lt;s:textfield name="lastName" label="LastName"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="email" label="Email"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="birth" label="Birth"&gt;&lt;/s:textfield&gt; &lt;!-- struts2的下拉框有listKey和listValue两个属性 --&gt; &lt;s:select list="#request.departments" listKey="id" listValue="departmentName" name="department.id" label="Department"&gt;&lt;/s:select&gt; &lt;s:submit&gt;&lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 获取源代码 添加员工首先在EmployeeAction.java里面实现ModelDriven和Preparable接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.leezp.ssh.actions;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.Map;import org.apache.struts2.interceptor.RequestAware;import com.leezp.ssh.entities.Employee;import com.leezp.ssh.service.DepartmentService;import com.leezp.ssh.service.EmployeeService;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import com.opensymphony.xwork2.Preparable;/** * 实现RequestAware请求域 * * @author Lee * */public class EmployeeAction extends ActionSupport implements RequestAware, ModelDriven&lt;Employee&gt;, Preparable &#123; /** * */ private static final long serialVersionUID = 1L; private EmployeeService employeeService; public void setEmployeeService(EmployeeService employeeService) &#123; this.employeeService = employeeService; &#125; private DepartmentService departmentService; public void setDepartmentService(DepartmentService departmentService) &#123; this.departmentService = departmentService; &#125; public String input() &#123; request.put("departments", departmentService.getAll()); return INPUT; &#125; public String list() &#123; request.put("employees", employeeService.getAll()); return "list"; &#125; private Integer id; public void setId(Integer id) &#123; this.id = id; &#125; private InputStream inputStream; public InputStream getInputStream() &#123; return inputStream; &#125; public String delete() &#123; try &#123; employeeService.delete(id); inputStream = new ByteArrayInputStream("1".getBytes("UTF-8")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); try &#123; inputStream = new ByteArrayInputStream("0".getBytes("UTF-8")); &#125; catch (UnsupportedEncodingException e1) &#123; e1.printStackTrace(); &#125; &#125; // return SUCCESS; // 使用ajax异步，删除后不再需要刷新页面，所以注释掉上一句。 return "delete"; &#125; private Map&lt;String, Object&gt; request; @Override public void setRequest(Map&lt;String, Object&gt; arg0) &#123; this.request = arg0; &#125; // struts2执行Save()方法之前会先执行prepareSave()方法 public void prepareSave() &#123; model = new Employee(); &#125; // 保存员工信息的方法 public String save() &#123; // System.out.println(model);// 打印model查看 model.setCreateTime(new Date()); employeeService.saveOrUpdate(model); return SUCCESS; &#125; @Override public void prepare() throws Exception &#123; &#125; // 定义一个model来接受表单提交的值 private Employee model; @Override public Employee getModel() &#123; return model; &#125;&#125; 修改struts.xml配置拦截器。因为表单提交和回显涉及到要把String日期和Date相互转换，所以在src下新建包com.leezp.ssh.converters。在该包下新建SSHDateConverter.java转换类。 123456789101112131415161718192021222324252627282930313233343536373839package com.leezp.ssh.converters;import java.sql.Date;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Map;import org.apache.struts2.util.StrutsTypeConverter;public class SSHDateConverter extends StrutsTypeConverter &#123; private DateFormat dateFormat; &#123; dateFormat = new SimpleDateFormat("yyyy-MM-dd"); &#125; @Override public Object convertFromString(Map context, String[] values, Class toClass) &#123; if (toClass == Date.class) &#123; try &#123; dateFormat.parse(values[0]); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; @Override public String convertToString(Map context, Object o) &#123; if (o instanceof Date) &#123; return dateFormat.format((Date) o); &#125; return null; &#125;&#125; 在conf源码包下新建xwork-conversion.properties属性文件配置日期转换类。 12# 复制 SSHDateConverter的全类名java.util.Date=com.leezp.ssh.converters.SSHDateConverter 配置自定义的类型转换器的两种方法：在应用程序里使用一个自定义的类型转换器之前，必须先对它进行配置，这种配置既可以基于字段，也可以基于类型。1.基于字段配置:可以为某个Model(该Model类也可能是Action)的各个属性分别配置一个自定义的转换器。①.创建一个属性文件：ModelClassName-conversion.properties,该文件需和相对应的Model类放在同一个目录下。②.编辑属性文件:field1=customConverter1field2=customConverter2… 2.基于类型配置①.在WEB-INF/classes/目录下创建xwork-conversion.properties文件。②.在xwork-conversion.properties文件里把每一个需要进行类型转换的类与一个类型转换器关联起来。fullyQualifiedClassName=CustomConvertor1 修改EmployeeDao.java添加保存的方法。修改EmployeeService.java添加保存的方法。 获取源代码 添加员工的流程访问index.jsp，点击添加员工的超链接&lt;a href=”emp-input”&gt;Add New Employee&lt;/a&gt;，经过struts.xml配置文件解析， 1234&lt;action name="emp-*" class="employeeAction" method="&#123;1&#125;"&gt; &lt;result name="input"&gt;/WEB-INF/views/emp-input.jsp &lt;/result&gt;&lt;/action&gt; 进入EmployeeAction.java的input()方法处理页面请求， 1234public String input() &#123; request.put("departments", departmentService.getAll()); return INPUT;&#125; 获取department的list返回到 emp-input.jsp从而绑定下拉框。 12&lt;s:form action="emp-save" method="post"&gt;&lt;/s:form&gt; 把crud方法放在一个action类中，就必定会涉及到一些数据准备的事情，所以用Preparable接口就再合适不过了，实现这个接口的prepare()方法，这个方法会在action类的所有方法执行前执行，另外我们也可以按照它的规则来写一些其它形式的prepare方法，例如aciton中有一个方法叫input(),那么我们可以实现一个prepareInput方法，这样在input()执行前，会执行prepareInput()方法。 保存操作的流程（ModelDriven和Preparable 拦截器）：prepareSave()-&gt;getModel()将上一步创建的值放到栈顶-&gt;由Preparable拦截器将表单的值赋给栈顶对象对应的属性 -&gt; Save()可以在struts-default.xml中查看拦截器执行顺序，prepare-&gt;modelDriven-&gt;params(表单参数值赋给栈顶对象对应的属性)-&gt;setParameters -&gt;prepareX() ajax检验添加时的用户名是否可用修改emp-input.jsp。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type="text/javascript" src="scripts/jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(":input[name=lastName]").change(function() &#123; var val = $(this).val(); val = $.trim(val); var $this = $(this); if (val != "") &#123; var url = "emp-validateLastName"; var args = &#123; "lastName" : val, "time" : new Date() &#125;; $this.nextAll("font").remove();//清空节点后内容，防止文字累加 $.post(url, args, function(data) &#123; //可用 if (data == "1") &#123; $this.after("&lt;font color='green'&gt;LastName可用!&lt;/font&gt;"); &#125; //不可用 else if (data == "0") &#123; $this.after("&lt;font color='red'&gt;LastName不可用!&lt;/font&gt;"); &#125;//服务器错误 else &#123; alert("服务器错误!"); &#125; &#125;); &#125; else &#123; alert("lastName 不能为空！"); this.focus(); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;Employee Input Page&lt;/h4&gt; &lt;s:form action="emp-save" method="post"&gt; &lt;!-- label属性为在页面显示的值 --&gt; &lt;s:textfield name="lastName" label="LastName"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="email" label="Email"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="birth" label="Birth"&gt;&lt;/s:textfield&gt; &lt;!-- struts2的下拉框有listKey和listValue两个属性 --&gt; &lt;!-- department.id为属性department的属性 --&gt; &lt;s:select list="#request.departments" listKey="id" listValue="departmentName" name="department.id" label="Department"&gt; &lt;/s:select&gt; &lt;s:submit&gt; &lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 在EmployeeDao.java添加查询用户名重复的方法。在EmployeeService.java添加调用它的方法。修改EmployeeAction.java。修改struts.xml。 获取源代码 员工信息的修改修改input.jsp页面，添加了修改链接等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type="text/javascript" src="scripts/jquery-1.9.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $(":input[name=lastName]").change(function() &#123; var val = $(this).val(); val = $.trim(val); var $this = $(this); if (val != "") &#123; var url = "emp-validateLastName"; var args = &#123; "lastName" : val, "time" : new Date() &#125;; $this.nextAll("font").remove();//清空节点后内容，防止文字累加 $.post(url, args, function(data) &#123; //可用 if (data == "1") &#123; $this.after("&lt;font color='green'&gt;LastName可用!&lt;/font&gt;"); &#125; //不可用 else if (data == "0") &#123; $this.after("&lt;font color='red'&gt;LastName不可用!&lt;/font&gt;"); &#125;//服务器错误 else &#123; alert("服务器错误!"); &#125; &#125;); &#125; else &#123; alert("lastName 不能为空！"); this.focus(); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;Employee Input Page&lt;/h4&gt; &lt;s:form action="emp-save" method="post"&gt; &lt;!-- Edit --&gt; &lt;s:if test="id !=null"&gt; &lt;s:textfield name="lastName" label="LastName" disabled="true"&gt;&lt;/s:textfield&gt; &lt;s:hidden name="id"&gt;&lt;/s:hidden&gt; &lt;%-- &lt;!--通过添加隐藏域的方式把未提交的字段值提交到服务器--&gt; &lt;s:hidden name="lastName"/&gt; &lt;s:hidden name="createTime"/&gt; 缺点：每个属性都要再另写一行 优点：不需要使用查一遍数据库的方式获取数据 --%&gt; &lt;/s:if&gt; &lt;!-- Add --&gt; &lt;s:else&gt; &lt;s:textfield name="lastName" label="LastName"&gt;&lt;/s:textfield&gt; &lt;/s:else&gt; &lt;!-- label属性为在页面显示的值 --&gt; &lt;s:textfield name="email" label="Email"&gt;&lt;/s:textfield&gt; &lt;s:textfield name="birth" label="Birth"&gt;&lt;/s:textfield&gt; &lt;!-- struts2的下拉框有listKey和listValue两个属性 --&gt; &lt;!-- department.id为属性department的属性 --&gt; &lt;s:select list="#request.departments" listKey="id" listValue="departmentName" name="department.id" label="Department"&gt; &lt;/s:select&gt; &lt;s:submit&gt; &lt;/s:submit&gt; &lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 在EmployeeDao.java里添加获取员工信息的get()方法。修改EmployeeService.java。修改EmployeeAction.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package com.leezp.ssh.actions;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.Map;import org.apache.struts2.interceptor.RequestAware;import com.leezp.ssh.entities.Employee;import com.leezp.ssh.service.DepartmentService;import com.leezp.ssh.service.EmployeeService;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import com.opensymphony.xwork2.Preparable;/** * 实现RequestAware请求域 * * @author Lee * */public class EmployeeAction extends ActionSupport implements RequestAware, ModelDriven&lt;Employee&gt;, Preparable &#123; /** * */ private static final long serialVersionUID = 1L; private EmployeeService employeeService; public void setEmployeeService(EmployeeService employeeService) &#123; this.employeeService = employeeService; &#125; private DepartmentService departmentService; public void setDepartmentService(DepartmentService departmentService) &#123; this.departmentService = departmentService; &#125; private String lastName; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; // **注意，这个方法validateLastName()里加参数(String lastName),struts.xml会找不到这个方法而报错** public String validateLastName() throws UnsupportedEncodingException &#123; if (employeeService.lastNameIsValid(lastName)) &#123; inputStream = new ByteArrayInputStream("1".getBytes("UTF-8")); &#125; else &#123; inputStream = new ByteArrayInputStream("0".getBytes("UTF-8")); &#125; return "ajax-success"; &#125; public String input() &#123; request.put("departments", departmentService.getAll()); return INPUT; &#125; public void prepareInput() &#123; if (id != null) &#123; // 回显到页面 model = employeeService.get(id); &#125; &#125; public String list() &#123; request.put("employees", employeeService.getAll()); return "list"; &#125; private Integer id; public void setId(Integer id) &#123; this.id = id; &#125; private InputStream inputStream; public InputStream getInputStream() &#123; return inputStream; &#125; public String delete() &#123; try &#123; employeeService.delete(id); inputStream = new ByteArrayInputStream("1".getBytes("UTF-8")); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); try &#123; inputStream = new ByteArrayInputStream("0".getBytes("UTF-8")); &#125; catch (UnsupportedEncodingException e1) &#123; e1.printStackTrace(); &#125; &#125; // return SUCCESS; // 使用ajax异步，删除后不再需要刷新页面，所以注释掉上一句。 return "ajax-success"; &#125; private Map&lt;String, Object&gt; request; @Override public void setRequest(Map&lt;String, Object&gt; arg0) &#123; this.request = arg0; &#125; // struts2执行Save()方法之前会先执行prepareSave()方法 public void prepareSave() &#123; // 根据id来判断为save()方法准备的model是new的还是从数据库获取的！ // add if (id == null) &#123; model = new Employee(); // edit //防止 id为空 &#125; else &#123; model = employeeService.get(id); &#125; &#125; // 保存员工信息的方法 public String save() &#123; // System.out.println(model);// 打印model查看 if (id == null) &#123; // add model.setCreateTime(new Date()); &#125; employeeService.saveOrUpdate(model); return SUCCESS; &#125; @Override public void prepare() throws Exception &#123; &#125; // 定义一个model来接受表单提交的值 private Employee model; @Override public Employee getModel() &#123; return model; &#125;&#125; 获取源代码 总结因本人水平有限，本demo还有很多不足之处，还望各位批评指正。 参考文献JavaBean中DAO设计模式介绍Hibernate高级查询方法Hibernate学习笔记-懒加载Lazy-trueJQuery this和$(this)的区别及获取$(this)子元素对象的方法Preparable接口和自定义拦截器总结Java过滤器与SpringMVC拦截器之间的关系与区别ModelDriven拦截器、Preparable 拦截器关于struts2/webwork中prepare接口中的二次绑定hibernate——Session接口中定义的saveOrUpdate()方法浅析Hibernate之Query接口的uniqueResult()方法懒加载异常的解决办法 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（八）Spring整合Struts2]]></title>
      <url>%2Fblog%2F2016%2F09%2F17%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring整合Struts2。 准备Struts2官方示例jar包:struts2.3.15.3-blankstruts-2.3.15.3-libstruts2官方示例web.xmlstruts2官方配置文件struts.xmlspring4-required jar Spring如何在WEB应用中使用1).需要额外导入两个jar包。spring-web-4.0.4.RELEASE.jarspring-webmvc-4.0.4.RELEASE.jar2).Spring的配置文件，和非WEB环境没有什么不同3).需要在web.xml文件中加入如下配置： 123456789101112&lt;!-- 配置Spring配置文件的名称和位置 --&gt;&lt;!-- needed for ContextLoaderListener --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 启动IOC容器的ServletContextListener --&gt;&lt;!-- Bootstraps the root web application context before servlet initialization --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 4).如何创建IOC容器。①.非WEB应用：在main方法中直接创建。②.WEB应用：在WEB应用被服务器加载时就创建IOC容器：在ServletContextListener#contextInitialized(ServletContextEvent sce)方法中创建IOC容器。③.在WEB应用的其他组件中如何来访问IOC容器：在ServletContextListener#contextInitialized(ServletContextEvent sce)方法中创建IOC容器后，可以把其放在ServletContext(即application 域)的一个属性中。④.实际上，Spring配置文件的名字和位置应该也是可配置的！将其配置到当前WEB应用的初始化参数中较为合适。 点击new-&gt; Other-&gt; Dynamic web project,新建一个Web项目spring-05。导入spring4-required jar包。新建包com.leezp.spring.struts2.beans。在该包下新建Person.java。 1234567891011121314package com.leezp.spring.struts2.beans;public class Person &#123; private String username; public void setUsername(String username) &#123; this.username = username; &#125; public void hello() &#123; System.out.println("My name is " + username); &#125;&#125; 新建Spring配置文件applicationContext.xml。 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="person" class="com.leezp.spring.struts2.beans.Person"&gt; &lt;property name="username" value="lee"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在项目下新建包com.leezp.spring.struts2.listeners。点击new-&gt; Other-&gt; Listener创建一个监听器。在Class Name项里填写监听器的名字。点击Next,选择相应监听器。点击finish。查看新建的监听器SpringServletContextListener.java。 1234567891011121314151617181920212223242526272829303132333435package com.leezp.spring.struts2.listeners;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;/** * Application Lifecycle Listener implementation class SpringServletContextListener * */@WebListenerpublic class SpringServletContextListener implements ServletContextListener &#123; /** * Default constructor. */ public SpringServletContextListener() &#123; // TODO Auto-generated constructor stub &#125; /** * @see ServletContextListener#contextInitialized(ServletContextEvent) */ public void contextInitialized(ServletContextEvent arg0) &#123; // TODO Auto-generated method stub &#125; /** * @see ServletContextListener#contextDestroyed(ServletContextEvent) */ public void contextDestroyed(ServletContextEvent arg0) &#123; // TODO Auto-generated method stub &#125; &#125; 在该监听器的contextInitialized()方法中创建IOC容器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.leezp.spring.struts2.listeners;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.annotation.WebListener;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Application Lifecycle Listener implementation class * SpringServletContextListener * */@WebListenerpublic class SpringServletContextListener implements ServletContextListener &#123; /** * Default constructor. */ public SpringServletContextListener() &#123; // TODO Auto-generated constructor stub &#125; /** * @see ServletContextListener#contextInitialized(ServletContextEvent) */ public void contextInitialized(ServletContextEvent arg0) &#123; // 获取Spring配置文件的名称 ServletContext servletContext = arg0.getServletContext(); String config = servletContext.getInitParameter("configLocation"); // 1.创建IOC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(config); // 2.把IOC容器放在ServletContext的一个属性中 servletContext.setAttribute("ApplicationContext", ctx); &#125; /** * @see ServletContextListener#contextDestroyed(ServletContextEvent) */ public void contextDestroyed(ServletContextEvent arg0) &#123; // TODO Auto-generated method stub &#125;&#125;``` 修改配置文件web.xml。12345678910111213141516``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt; &lt;!-- 配置Spring配置文件的名称和位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;configLocation&lt;/param-name&gt; &lt;param-value&gt;applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 启动IOC容器的 ServletContextListener --&gt; &lt;listener&gt; &lt;listener-class&gt;com.leezp.spring.struts2.listeners.SpringServletContextListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 新建包com.leezp.spring.struts2.servlets。在该包下新建Servlet类TestServlet.java。 123456789101112131415161718192021222324252627282930313233343536373839package com.leezp.spring.struts2.servlets;import java.io.IOException;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.context.ApplicationContext;import com.leezp.spring.struts2.beans.Person;/** * Servlet implementation class TestServlet */@WebServlet("/TestServlet")public class TestServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse * response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 1.从application域对象中得到IOC容器的引用 ServletContext servletContext = getServletContext(); ApplicationContext ctx = (ApplicationContext) servletContext .getAttribute("ApplicationContext"); // 2.从IOC容器中得到需要的bean Person person = ctx.getBean(Person.class); person.hello(); &#125;&#125; 新建web页面index.jsp。 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="TestServlet"&gt;TestServlet&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 运行项目，鼠标单击项目，右击，run as-&gt; run on server-&gt; next… 获取源代码 Spring如何整合Struts21).整合目标：使IOC容器来管理Struts2的Action！2).整合方法：①.正常加入Struts2web.xml里加入Struts2的过滤器添加Struts2的配置文件struts.xml。②.在Spring的IOC容器中配置struts2的Action。注意：在IOC容器中配置Struts2的Action时，需要配置scope属性，其值必须为prototype,即struts2的action是非单例的 123&lt;bean id="personAction" class="com.leezp.spring.struts2.actions.PersonAction" scope="prototype"&gt; &lt;property name="personService" ref="personService"&gt;&lt;/property&gt;&lt;/bean&gt; ③.配置Struts2的配置文件action节点的class属性不能再指向全类名，需要指向IOC容器中该bean的id。 123&lt;action name="person-save" class="personAction"&gt; &lt;result&gt;/success.jsp&lt;/result&gt;&lt;/action&gt; ④.导入jar：struts2-spring-plugin-2.3.15.3.jar3).整合原理：通过添加struts2-spring-plugin-2.3.15.3.jar以后，Struts2会先从IOC容器中获取Action的实例。具体可以看Struts2的源码，在父类SpringObjectFactory.java的buildBean()方法里做了如下判断。123456if (appContext.containsBean(beanName)) &#123; o = appContext.getBean(beanName); &#125; else &#123; Class beanClazz = getClassInstance(beanName); o = buildBean(beanClazz, extraContext); &#125; 新建一个web项目spring-06。导入spring4-required jar包。新建包com.leezp.spring.struts2.beans。在该包下新建Person.java。 1234567891011121314package com.leezp.spring.struts2.beans;public class Person &#123; private String username; public void setUsername(String username) &#123; this.username = username; &#125; public void hello() &#123; System.out.println("My name is " + username); &#125;&#125; 新建包com.leezp.spring.struts2.services。在该包下新建PersonService.java。 12345678package com.leezp.spring.struts2.services;public class PersonService &#123; public void save() &#123; System.out.println("PersonService's save..."); &#125;&#125; 新建包com.leezp.spring.struts2.actions。在该包下新建PersonAction.java。 123456789101112131415161718package com.leezp.spring.struts2.actions;import com.leezp.spring.struts2.services.PersonService;public class PersonAction &#123; private PersonService personService; public void setPersonService(PersonService personService) &#123; this.personService = personService; &#125; public String execute() &#123; System.out.println("execute..."); personService.save(); return "success"; &#125;&#125; 复制struts2官方示例web.xml里的内容到web.xml并修改web.xml。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt; &lt;!-- 配置Spring配置文件的名称和位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 启动IOC容器的 ServletContextListener --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置Struts2的Filter --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 新建Spring配置文件applicationContext.xml。 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="person" class="com.leezp.spring.struts2.beans.Person"&gt; &lt;property name="username" value="spring"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="personService" class="com.leezp.spring.struts2.services.PersonService"&gt;&lt;/bean&gt; &lt;!-- 注意：在IOC容器中配置Struts2的Action时，需要配置scope属性，其值必须为prototype,即struts2的action是非单例的 --&gt; &lt;bean id="personAction" class="com.leezp.spring.struts2.actions.PersonAction" scope="prototype"&gt; &lt;property name="personService" ref="personService"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 新建struts.xml。复制struts2官方配置文件struts.xml内容到struts.xml并修改这个文件。 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;!-- Spring整合Struts2时，在Struts2中配置的Spring的Action的class需要指向IOC容器中该bean的id，而不再使用全类名(单独配置Struts2时需要使用全类名) --&gt; &lt;action name="person-save" class="personAction"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 新建web页面success.jsp。 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="ISO-8859-1"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;Success Page&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 新建web页面index.jsp。 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="person-save"&gt;Person Save&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 在该页面右击，Run As-&gt; Run on Server启动Apache服务器进行测试。点击页面的”Person Save”链接。 在控制台观察运行结果。 12execute...PersonService's save... 新建web页面test.jsp。 123456789101112131415161718192021222324252627&lt;%@page import="com.leezp.spring.struts2.beans.Person"%&gt;&lt;%@page import="org.springframework.web.context.support.WebApplicationContextUtils"%&gt;&lt;%@page import="org.springframework.context.ApplicationContext"%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% //1.从application域对象中得到IOC容器的实例 //利用Spring提供的工具 WebApplicationContextUtils获取 ApplicationContext ctx = WebApplicationContextUtils .getWebApplicationContext(application); //2.从IOC容器中得到bean Person person = ctx.getBean(Person.class); //3.使用bean person.hello(); %&gt;&lt;/body&gt;&lt;/html&gt; 在该页面右击，Run As-&gt; Run on Server启动Apache服务器进行测试。 在控制台观察运行结果。 1My name is spring 获取源代码 参考文献struts2.3.15.3-blankstruts2官方示例web.xmlstruts2官方配置文件struts.xml 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（七）Spring整合Hibernate]]></title>
      <url>%2Fblog%2F2016%2F09%2F11%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring整合Hibernate。 准备JBoss官网Spring jar包：spring-framework-4.0.4.RELEASEHibernate jar包：hibernate-release-4.2.4.Final 根据自己Eclipse版本下载对应的插件。我的是Eclipse Kepler 4.3.2，与之对应的Hibernate Tools版本是hibernatetools-Update-4.1.2.Final_2014-03-18_15-46-19-B706。官网上写它的Requirements: Java 6 or Java 7 and Eclipse Kepler 4.3.2。 下载好hibernatetools之后将其解压，在Eclipse目录下新建文件夹MyPlugins，在MyPlugins文件夹下新建Hibernatetools文件夹，这两个文件夹的名字可以任意取，这样命名是便于识别。将解压好的hibernatetools文件夹下的features和plugins两个文件夹复制到Hibernatetools文件夹下。在Eclipse目录下新建links文件夹，在links文件夹下新建hibernatetools.link文件，这个文件的名字可以任意取，这样取是便于识别。在hibernatetools.link文件里写入path=/MyPlugins/Hibernatetools,也可以写绝对路径，都OK的。重启Eclipse，在New-&gt; Other 之后，输入h,看到Hibernate即为安装成功。 目标1.有IOC容器来生成Hibernate的SessionFactory。2.让Hibernate使用上Spring的声明式事务。 步骤1.加入Hibernate①.添加jar包并build path。②.添加Hibernate配置文件：hibernate.cfg.xml。③.编写了持久化类对应的 .hbm.xml文件。2.加入Spring。①.jar包。②.加入Spring的配置文件。3.整合。Spring hibernate 事务的流程：1.在方法开始之前:①.获取Session。②.把Session和当前线程绑定，这样就可以在Dao中使用SessionFactory的getCurrentSession()方法来获取Session了。③.开启事务。2.若方法正常结束，即没有出现异常，则:①.提交事务。②.使用当前线程绑定的Session，解除绑定。③.关闭Session。3.若方法出现异常，则：①.回滚事务。②.使和当前线程绑定的Session解除绑定。③.关闭Session。 新建项目spring-04。新建bin文件夹。将下载的Hibernate jar包解压缩。进入lib-&gt; required文件夹，将全部8个必要jar包复制到bin文件夹下。antlr-2.7.7.jardom4j-1.6.1.jarhibernate-commons-annotations-4.0.2.Final.jarhibernate-core-4.2.4.Final.jarhibernate-jpa-2.0-api-1.0.1.Final.jarjavassist-3.15.0-GA.jarjboss-logging-3.1.0.GA.jarjboss-transaction-api_1.1_spec-1.0.1.Final.jar再添加c3p0-0.9.1.2.jar，mysql-connector-java-5.1.22-bin.jar并build path。在该项目下新建包com.leezp.spring.hibernate.entities。在该包下新建hibernate的配置文件hibernate.cfg.xml。 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 配置hibernate的基本属性 --&gt; &lt;!-- 1.数据源需配置到IOC容器中，所以此处不再需要配置数据源。 --&gt; &lt;!-- 2.关联的 .hbm.xml 也在IOC容器配置SessionFactory实例时再进行配置。 --&gt; &lt;!-- 3.配置hibernate的基本属性：方言，SQL显示及格式化，生成数据表的策略及二级缓存等。 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 是否显示所生成 SQL 语句 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 是否格式化生成的 SQL 语句，增加可读性，不然全挤在一行 --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!--hibernate.hbm2ddl.auto 用于 自动创建|更新|验证数据库表结构。 create | update | validate | create-drop --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 --&gt; &lt;!-- create-drop ： 每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 --&gt; &lt;!-- update： 最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 --&gt; &lt;!-- validate ： 每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 --&gt; &lt;!-- 配置hibernate 二级缓存相关的属性 --&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 在该包下新建Account.java。 1234567891011121314151617181920212223242526272829303132333435package com.leezp.spring.hibernate.entities;public class Account &#123; private Integer id; private String username; private int balance; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getBalance() &#123; return balance; &#125; public void setBalance(int balance) &#123; this.balance = balance; &#125;&#125; 在该包下新建Book.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.leezp.spring.hibernate.entities;public class Book &#123; private Integer id; private String bookName; private String isbn; private int price; private int stock; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getBookName() &#123; return bookName; &#125; public void setBookName(String bookName) &#123; this.bookName = bookName; &#125; public String getIsbn() &#123; return isbn; &#125; public void setIsbn(String isbn) &#123; this.isbn = isbn; &#125; public int getPrice() &#123; return price; &#125; public void setPrice(int price) &#123; this.price = price; &#125; public int getStock() &#123; return stock; &#125; public void setStock(int stock) &#123; this.stock = stock; &#125;&#125; 鼠标单击包，右键new-&gt; Other…-&gt; Hibernate XML Mapping file(hbm.xml)，如下图。点击Next,点Finish。发现包下多了两个文件，这是Hibernate Tools为我们自动生成的hibernate Mapping文件。打开Book.hbm.xml。 123456789101112131415161718&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2016-9-11 10:14:02 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt; &lt;class name="com.leezp.spring.hibernate.entities.Account" table="ACCOUNT"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="ID" /&gt; &lt;generator class="assigned" /&gt; &lt;/id&gt; &lt;property name="username" type="java.lang.String"&gt; &lt;column name="USERNAME" /&gt; &lt;/property&gt; &lt;property name="balance" type="int"&gt; &lt;column name="BALANCE" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 打开Account.hbm.xml。 123456789101112131415161718&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2016-9-11 10:14:02 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt; &lt;class name="com.leezp.spring.hibernate.entities.Account" table="ACCOUNT"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="ID" /&gt; &lt;generator class="assigned" /&gt; &lt;/id&gt; &lt;property name="username" type="java.lang.String"&gt; &lt;column name="USERNAME" /&gt; &lt;/property&gt; &lt;property name="balance" type="int"&gt; &lt;column name="BALANCE" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 修改Account.hbm.xml文件。 12345678910111213141516171819202122&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2016-9-11 10:14:02 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt; &lt;class name="com.leezp.spring.hibernate.entities.Account" table="SH_ACCOUNT"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="ID" /&gt; &lt;!-- 生成主键的方式,如有疑问见最后的参考文献：Hibernate 的&lt;generator class="native"&gt;&lt;/generator&gt;的不同属性含义 --&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;property name="username" type="java.lang.String"&gt; &lt;column name="USERNAME" /&gt; &lt;/property&gt; &lt;property name="balance" type="int"&gt; &lt;column name="BALANCE" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 修改Book.hbm.xml文件。 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2016-9-11 10:14:02 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt; &lt;class name="com.leezp.spring.hibernate.entities.Book" table="SH_BOOK"&gt; &lt;id name="id" type="java.lang.Integer"&gt; &lt;column name="ID" /&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;property name="bookName" type="java.lang.String"&gt; &lt;column name="BOOK_NAME" /&gt; &lt;/property&gt; &lt;property name="isbn" type="java.lang.String"&gt; &lt;column name="ISBN" /&gt; &lt;/property&gt; &lt;property name="price" type="int"&gt; &lt;column name="PRICE" /&gt; &lt;/property&gt; &lt;property name="stock" type="int"&gt; &lt;column name="STOCK" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 新建属性文件db.properties。 1234567jdbc.user=rootjdbc.password=rootjdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/spring_hibernatejdbc.initPoolSize=5jdbc.maxPoolSize=10 spring4-required jar包将下载好的spring4-required jar包里的所有jar文件复制到bin文件夹下并且build path。 12345678910111213141516171819202122232425262728293031323334353637新建Spring的配置文件applicationContext.xml。&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 1.配置数据源 --&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2.配置Hibernate 的 SessionFactory实例 :通过Spring 提供的LocalSessionFactoryBean进行配置 --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;!-- 配置数据源属性 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 配置hibernate配置文件的位置及名称 --&gt; &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; &lt;!-- 配置hibernate映射文件的位置及名称，可以使用通配符 --&gt; &lt;property name="mappingLocations" value="classpath:com/leezp/spring/hibernate/entities/*.hbm.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3.配置Spring的声明式事务 --&gt;&lt;/beans&gt; 在mysql中新建数据库spring_hibernate。不创建任何表。新建包com.leezp.spring.hibernate.test。在该包下新建测试类SpringHibernateTest.java。 1234567891011121314151617import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringHibernateTest &#123; private ApplicationContext ctx = null; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource=ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125; 运行上面的测试类。在数据库里刷新，发现为我们建立好了数据表。 新建包com.leezp.spring.hibernate.dao。在该包下新建接口BookShopDao.java。 12345678910111213package com.leezp.spring.hibernate.dao;public interface BookShopDao &#123; //根据书号获取书的单价 public int findBookPriceByIsbn(String isbn); //更新书的库存，使书号对应的库存 -1 public void updateBookStock(String isbn); //更新用户的账户余额：使username的balance - price public void updateUserAccount(String username,int price);&#125; 新建包com.leezp.spring.hibernate.dao.impl。在该包下新建接口BookShopDao.java的实现类BookShopDaoImpl.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.leezp.spring.hibernate.dao.impl;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import com.leezp.spring.hibernate.dao.BookShopDao;import com.leezp.spring.hibernate.exception.BookStockException;import com.leezp.spring.hibernate.exception.UserAccountException;@Repositorypublic class BookShopDaoImpl implements BookShopDao &#123; // 线程安全的 @Autowired private SessionFactory sessionFactory; // HibernateTemplate 和 HibernateDaoSupport是Spring的API， // 不推荐使用，因为这样会导致Dao和Spring的API进行耦合，可移植性变差，建议原生Hibernate接口。 // private HibernateTemplate hibernateTemplate; // // public class BookShopDaoImpl extends HibernateDaoSupport implements // BookShopDao &#123; // Hibernate 获取跟当前线程绑定的Session private Session getSession() &#123; return sessionFactory.getCurrentSession(); &#125; @Override public int findBookPriceByIsbn(String isbn) &#123; String hql = " select b.price from Book b where b.isbn = ? "; // import org.hibernate.Query; Query query = getSession().createQuery(hql).setString(0, isbn); return (Integer) query.uniqueResult(); &#125; @Override public void updateBookStock(String isbn) &#123; // 验证书的库存是否充足 String hql2 = " select b.stock from Book b where b.isbn= ? "; int stock = (int) getSession().createQuery(hql2).setString(0, isbn) .uniqueResult(); if (stock == 0) &#123; throw new BookStockException("库存不足！"); &#125; String hql = " update Book b set b.stock=b.stock -1 where b.isbn= ? "; getSession().createQuery(hql).setString(0, isbn).executeUpdate(); &#125; @Override public void updateUserAccount(String username, int price) &#123; // 验证余额是否足够 String hql2 = " select a.balance from Account a where a.username=? "; int balance = (int) getSession().createQuery(hql2) .setString(0, username).uniqueResult(); if (balance &lt; price) &#123; throw new UserAccountException("余额不足！"); &#125; String hql = " update Account a set a.balance=a.balance-? where a.username=? "; getSession().createQuery(hql).setInteger(0, price) .setString(1, username).executeUpdate(); &#125;&#125; 新建包com.leezp.spring.hibernate.service。新建接口BookShopService.java。 123456package com.leezp.spring.hibernate.service;public interface BookShopService &#123; public void purchase(String username, String isbn);&#125; 新建接口Cashier.java。 12345678package com.leezp.spring.hibernate.service;import java.util.List;public interface Cashier &#123; public void checkout(String username, List&lt;String&gt; isbns);&#125; 新建包com.leezp.spring.hibernate.service.impl。在该包下新建接口BookShopService.java的实现类BookShopServiceimpl.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.leezp.spring.hibernate.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.leezp.spring.hibernate.dao.BookShopDao;import com.leezp.spring.hibernate.service.BookShopService;@Servicepublic class BookShopServiceImpl implements BookShopService &#123; @Autowired private BookShopDao bookShopDao; /** * Spring hibernate 事务的流程： * * 1.在方法开始之前 * * ①.获取Session * * ②.把Session和当前线程绑定，这样就可以在Dao中使用SessionFactory的 * getCurrentSession()方法来获取Session了。 * * ③.开启事务 * * 2.若方法正常结束，即没有出现异常，则 * * ①.提交事务 * * ②.使用当前线程绑定的Session，解除绑定 * * ③.关闭Session * * 3.若方法出现异常，则： * * ①.回滚事务 * * ②.使和当前线程绑定的Session解除绑定 * * ③.关闭Session */ @Override public void purchase(String username, String isbn) &#123; int price = bookShopDao.findBookPriceByIsbn(isbn); bookShopDao.updateBookStock(isbn); bookShopDao.updateUserAccount(username, price); &#125;&#125; 在该包下新建接口Cashier.java的实现类CashierImpl.java。 123456789101112131415161718192021222324package com.leezp.spring.hibernate.service.impl;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.leezp.spring.hibernate.service.BookShopService;import com.leezp.spring.hibernate.service.Cashier;@Servicepublic class CashierImpl implements Cashier &#123; @Autowired private BookShopService bookShopService; @Override public void checkout(String username, List&lt;String&gt; isbns) &#123; for (String isbn : isbns) &#123; bookShopService.purchase(username, isbn); &#125; &#125;&#125; 新建包com.leezp.spring.hibernate.exception。在该包下新建异常类BookStockException.java。 1234567891011121314151617181920212223242526272829303132333435363738package com.leezp.spring.hibernate.exception;//继承RuntimeException,Generate Constructors from SuperClass添加构造器// Add default serial version IDpublic class BookStockException extends RuntimeException &#123; /** * */ private static final long serialVersionUID = 1L; public BookStockException() &#123; super(); // TODO Auto-generated constructor stub &#125; public BookStockException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); // TODO Auto-generated constructor stub &#125; public BookStockException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public BookStockException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125; public BookStockException(Throwable cause) &#123; super(cause); // TODO Auto-generated constructor stub &#125;&#125; 在该包下新建异常类UserAccountException.java。 123456789101112131415161718192021222324252627282930313233343536package com.leezp.spring.hibernate.exception;public class UserAccountException extends RuntimeException &#123; /** * */ private static final long serialVersionUID = 1L; public UserAccountException() &#123; super(); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125; public UserAccountException(Throwable cause) &#123; super(cause); // TODO Auto-generated constructor stub &#125;&#125; 向Spring配置文件applicationContext.xml中添加： 12&lt;!-- 使用注解要配置自动扫描的包 --&gt; &lt;context:component-scan base-package="com.leezp.spring.hibernate"&gt;&lt;/context:component-scan&gt; 修改测试类SpringHibernateTest.java。 12345678910111213141516171819202122232425262728293031323334package com.leezp.spring.hibernate.test;import java.sql.SQLException;import javax.sql.DataSource;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.hibernate.service.BookShopService;public class SpringHibernateTest &#123; private ApplicationContext ctx = null; private BookShopService bookShopService = null; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); bookShopService = ctx.getBean(BookShopService.class); &#125; @Test public void testBookShopService() &#123; bookShopService.purchase("aa", "1001"); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125; 获取数据库spring_hibernate 在测试类SpringHibernateTest.java中运行testBookShopService方法进行测试。 获取源代码 补充说明Hibernate的配置文件hibernate.cfg.xml不是必须的，可以在Spring配置文件applicationContext.xml里通过配置来取代它。但是不建议这么使用，因为在Spring配置文件中配置Hibernate提示功能不是很好，而且配置Hibernate插件时不如在hibernate配置文件中配置方便。具体操作根据项目需求来定。 修改applicationContext.xml配置文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 使用注解要配置自动扫描的包 --&gt; &lt;context:component-scan base-package="com.leezp.spring.hibernate"&gt;&lt;/context:component-scan&gt; &lt;!-- 1.配置数据源 --&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2.配置Hibernate 的 SessionFactory实例 :通过Spring 提供的LocalSessionFactoryBean进行配置 --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;!-- 配置数据源属性 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 配置hibernate配置文件的位置及名称 --&gt; &lt;!-- &lt;property name="configLocation" value="classpath:hibernate.cfg.xml"&gt;&lt;/property&gt; --&gt; &lt;!-- 使用hibernateProperties属性来配置Hibernate原生的属性 --&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/prop&gt; &lt;!-- 测试方法：将这里的true改成false，若不显示sql语句（之前显示sql语句），证明配置生效 --&gt; &lt;prop key="hibernate.show_sql"&gt;false&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 配置hibernate映射文件的位置及名称，可以使用通配符 --&gt; &lt;property name="mappingLocations" value="classpath:com/leezp/spring/hibernate/entities/*.hbm.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3.配置Spring的声明式事务 --&gt; &lt;!-- ①.配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ②.配置事务属性，需要事务管理器 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get" read-only="true" /&gt; &lt;tx:method name="*" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- ③.配置事务切点，并把切点和事务属性关联起来 --&gt; &lt;aop:config&gt; &lt;!-- com.leezp.spring.hibernate.service包下的所有类，所有方法，参数值任意 --&gt; &lt;aop:pointcut expression="execution(* com.leezp.spring.hibernate.service.*.*(..))" id="txPointCut" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 获取源代码 参考文献hibernate中的映射文件xxx.hbm.xml详解总结xxx.hbm.xml文件配置详解，适合保存。Hibernate 的的不同属性含义 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（六）Spring中的事务管理]]></title>
      <url>%2Fblog%2F2016%2F09%2F03%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring中的事务管理。 Spring中的事务管理事务就是一系列的动作，它们被当做一个单独的工作单元，这些动作要么全部完成，要么全部不起作用。用来确保数据的完整性和一致性。事务的四个关键属性（ACID）1.原子性（atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成要么完全不起作用。2.一致性（consistency）：一旦所有事务动作完成，事务就被提交，数据和资源就处于一种满足业务规则的一致性状态中。3.隔离性（isolation）：可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据破坏。4.持久性（durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，通常情况下，事务的结果被写到持久化存储器中。 Spring的事务管理机制Spring在不同的事务管理API之上定义了一个抽象层。而应用程序开发人员不必了解底层的事务管理API，就可以使用Spring的事务管理机制。Spring既支持编程式事务管理，也支持声明式的事务管理。编程式事务管理：将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。在编程式管理事务时，必须在每个事务操作中包含额外的事务管理代码。声明式事务管理：大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过SpringAOP框架支持声明式事务管理。 Spring中的事务管理器Spring从不同的事务管理API中抽象了一整套的事务机制。开发人员不必了解底层的事务API，就可以利用这些事务机制。有了这些事务机制，事务管理代码就能独立于特定的事务技术了。Spring的核心事务管理抽象是 org.springframework.transaction Interface Platform TransactionManager管理和封装了一组独立于技术的方法。无论使用Spring的哪种事务管理策略（编程式或声明式），事务管理器都是必须的。 Spring中事务管理器的不同实现org.springframework.jdbc.datasourceClass DataSource TransactionManager:在应用程序中只需要处理一个数据源，而且通过JDBC存取。 org.springframework.transaction.jtaClass JtaTransactionManager:在JavaEE应用服务器上用JTA（Java Transaction API）进行事务管理。 org.springframework.orm.hibernate3Class Hibernate TransactionManager:用Hibernate框架存取数据库。 事务管理器以普通的Bean形式声明在SpringIOC容器中。 声明式事务一共三步。1.在配置文件中配置事务管理器2.在配置文件中配置注解驱动3.在要应用事务的方法前添加@Transaction。 沿用上一节中的项目。在项目下新建包com.leezp.spring.tx。在该包下新建接口BookShopDao.java。 12345678910111213package com.leezp.spring.tx;public interface BookShopDao &#123; //根据书号获取书的单价 public int findBookPriceByIsbn(String isbn); //更新书的库存，使书号对应的库存 -1 public void updateBookStock(String isbn); //更新用户的账户余额：使username的balance - price public void updateUserAccount(String username,int price);&#125; 新建异常类BookStockException.java。 1234567891011121314151617181920212223242526272829303132333435363738package com.leezp.spring.tx;//继承RuntimeException,Generate Constructors from SuperClass添加构造器// Add default serial version IDpublic class BookStockException extends RuntimeException &#123; /** * */ private static final long serialVersionUID = 1L; public BookStockException() &#123; super(); // TODO Auto-generated constructor stub &#125; public BookStockException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); // TODO Auto-generated constructor stub &#125; public BookStockException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public BookStockException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125; public BookStockException(Throwable cause) &#123; super(cause); // TODO Auto-generated constructor stub &#125;&#125; 新建异常类UserAccountException.java。 123456789101112131415161718192021222324252627282930313233343536package com.leezp.spring.tx;public class UserAccountException extends RuntimeException &#123; /** * */ private static final long serialVersionUID = 1L; public UserAccountException() &#123; super(); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125; public UserAccountException(Throwable cause) &#123; super(cause); // TODO Auto-generated constructor stub &#125;&#125; 新建接口BookShopDao的实现类BookShopDaoImpl.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.leezp.spring.tx;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repository("bookShopDao")public class BookShopDaoImpl implements BookShopDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int findBookPriceByIsbn(String isbn) &#123; String sql = " select price from book where isbn = ? "; return jdbcTemplate.queryForObject(sql, Integer.class, isbn); &#125; @Override public void updateBookStock(String isbn) &#123; // 检查书的库存是否足够，若不够，则抛出异常 String sql2 = " select stock from book_stock where isbn = ? "; int stock = jdbcTemplate.queryForObject(sql2, Integer.class, isbn); if (stock == 0) &#123; // 定义一个异常类 throw new BookStockException("库存不足"); &#125; String sql = " update book_stock set stock= stock -1 where isbn = ? "; jdbcTemplate.update(sql, isbn); &#125; @Override public void updateUserAccount(String username, int price) &#123; // 验证余额是否足够，若不足，则抛出异常 String sql2 = " select balance from account where username = ? "; int balance = jdbcTemplate .queryForObject(sql2, Integer.class, username); if (balance &lt; price) &#123; throw new UserAccountException("余额不足"); &#125; String sql = " update account set balance=balance - ? where username = ? "; jdbcTemplate.update(sql, price, username); &#125;&#125; 新建接口BookShopService.java。 123456package com.leezp.spring.tx;public interface BookShopService &#123; public void purchase(String username, String isbn);&#125; 新建接口BookShopService的实现类BookShopServiceImpl.java。注意在要应用事务的方法上添加@Transaction。 12345678910111213141516171819202122232425package com.leezp.spring.tx;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service("bookShopService")public class BookShopServiceImpl implements BookShopService &#123; @Autowired private BookShopDao bookShopDao; //添加事务注解 @Transactional @Transactional @Override public void purchase(String username, String isbn) &#123; // 1.获取书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); // 2.更新书的库存 -1 bookShopDao.updateBookStock(isbn); // 3.更新用户余额 bookShopDao.updateUserAccount(username, price); &#125;&#125; 重新配置db.properties属性文件里的连接字符串。 1jdbc.jdbcUrl=jdbc:mysql://localhost:3306/spring_demo2 修改applicationContext.xml配置文件。 1&lt;context:component-scan base-package="com.leezp.spring"&gt;&lt;/context:component-scan&gt; 向该配置文件中添加： 123456789&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 添加数据源 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 启用事务注解 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; 新建测试类（JUnit Test Case）SpringTransactionTest.java。 123456789101112131415161718192021222324252627282930313233343536373839package com.leezp.spring.tx;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTransactionTest &#123; private ApplicationContext ctx = null; private BookShopDao bookShopDao = null; private BookShopService bookShopService=null; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); bookShopDao=ctx.getBean(BookShopDao.class); bookShopService=ctx.getBean(BookShopService.class); &#125; @Test public void testBookShopService()&#123; bookShopService.purchase("AA", "1001"); &#125; @Test public void testBookShopDaoUpdateUserAccount()&#123; bookShopDao.updateUserAccount("AA", 200); &#125; @Test public void testBookShopDaoUpdateBookStock()&#123; bookShopDao.updateBookStock("1001"); &#125; @Test public void testBookShopDaoFindPriceByIsbn() &#123; System.out.println(bookShopDao.findBookPriceByIsbn("1001")); &#125;&#125; 获取源代码获取数据库文件 其他细节事务的属性：1.事务的传播行为 propagation2.事务的隔离级别 isolation3.对哪些异常不回滚 noRollbackFor/rollbackFor4.事务的过期时间 timeout 事务传播属性当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。 事务的传播行为可以由传播属性指定。Spring定义了7种传播行为。 Spring支持的事务传播行为REQUIRED(默认)：如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行。 REQUIRES_NEW：当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起。 SUPPORTS：如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中。 NOT_SUPPORTED：当前的方法不应该运行在事务中，如果有运行的事务，将它挂起。 MANDATORY：当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常。 NEVER：当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常。 NESTED：如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行。 事务的传播属性可以在@Transactional注解的propagation属性中定义。eg:@Transactional(propagation=Propagation.REQUIRED) 在项目中新建接口Cashier.java。 12345678package com.leezp.spring.tx;import java.util.List;public interface Cashier &#123; public void checkout(String username, List&lt;String&gt; isbns);&#125; 新建接口Cashier的实现类CashierImpl.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.leezp.spring.tx;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;/** * 事务的传播行为（事务之间的调用） * * @author Lee * */@Service("cashier")public class CashierImpl implements Cashier &#123; @Autowired private BookShopService bookShopService; /** * 当bookService的purchase()方法被另一个事务方法checkout()调用时， * * 它默认会在**已有**的事务内运行，这个默认的传播行为就是REQUIRED。 * * 因此在checkout()方法的开始和终止边界内只有一个事务， * * 这个事务只在checkout()方法结束的时候被提交， * * 因为用户余额只够买第一本书的，所以最终结果用户一本书都买不了。 * */ // 使用propagation 指定事务的传播行为，即当前的事务方法被另一个事务方法调用时，如何使用事务 // 默认取值REQUIRED,即使用调用方法的事务 // REQUIRES_NEW:使用自己的事务，调用事务的方法的事务被挂起 @Transactional(propagation = Propagation.REQUIRED) @Override public void checkout(String username, List&lt;String&gt; isbns) &#123; for (String isbn : isbns) &#123; bookShopService.purchase(username, isbn); &#125; &#125;&#125; 修改SpringTransactionTest.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.leezp.spring.tx;import java.util.Arrays;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTransactionTest &#123; private ApplicationContext ctx = null; private BookShopDao bookShopDao = null; private BookShopService bookShopService = null; private Cashier cashier = null; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); bookShopDao = ctx.getBean(BookShopDao.class); bookShopService = ctx.getBean(BookShopService.class); cashier = ctx.getBean(Cashier.class); &#125; @Test public void testTransactionlPropagation() &#123; cashier.checkout("AA", Arrays.asList("1001", "1002")); &#125; @Test public void testBookShopService() &#123; bookShopService.purchase("AA", "1001"); &#125; @Test public void testBookShopDaoUpdateUserAccount() &#123; bookShopDao.updateUserAccount("AA", 200); &#125; @Test public void testBookShopDaoUpdateBookStock() &#123; bookShopDao.updateBookStock("1001"); &#125; @Test public void testBookShopDaoFindPriceByIsbn() &#123; System.out.println(bookShopDao.findBookPriceByIsbn("1001")); &#125;&#125; 获取源代码 并发事务所导致的问题当同一个应用程序或者不同应用程序中的多个事务在同一个数据集上并发执行时，可能会出现许多意外的问题。 并发事务所导致的问题可以分为下面三种类型：1.脏读：对于两个事务T1,T2,T1读取了已经被T2更新但还没有被提交的字段。之后，若T2回滚，T1读取的内容就是临时且无效的。2.不可重复读：对于两个事务T1,T2,T1读取了一个字段，然后T2更新了该字段。之后，T1再次读取同一个字段，值就不同了。3.幻读：对于两个事务T1,T2,T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行。之后，如果T1再次读取同一个表，就会多出几行。 事务的隔离级别：使用isolation指定事务的隔离级别，最常用的取值为 READ_COMMITTED：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 超时和只读属性由于事务可以在行和表上获得锁，因此长事务会占用资源，并对整体性能产生影响。如果一个事务只读取数据但不做修改，数据库引擎可以对这个事务进行优化。超时事务属性：事务在强制回滚之前可以保持多久。这样可以防止长期运行的事务占用资源。只读事务属性：表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。 修改CashierImpl.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.leezp.spring.tx;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;/** * 事务的传播行为（事务之间的调用） * * @author Lee * */@Service("cashier")public class CashierImpl implements Cashier &#123; @Autowired private BookShopService bookShopService; /** * 当bookService的purchase()方法被另一个事务方法checkout()调用时， * * 它默认会在**已有**的事务内运行，这个默认的传播行为就是REQUIRED。 * * 因此在checkout()方法的开始和终止边界内只有一个事务， * * 这个事务只在checkout()方法结束的时候被提交， * * 因为用户余额只够买第一本书的，所以最终结果用户一本书都买不了。 * */ // 1.使用propagation 指定事务的传播行为，即当前的事务方法被另一个事务方法调用时，如何使用事务 // 默认取值REQUIRED,即使用调用方法的事务 // REQUIRES_NEW:使用自己的事务，调用事务的方法的事务被挂起 // 2.使用isolation指定事务的隔离级别，最常用的取值为 READ_COMMITTED // 3.默认情况下Spring的声明式事务对所有的运行时异常进行回滚，也可以通过对应的属性进行设置。 // noRollbackFor:指定对哪些异常不进行回滚，通常情况下取默认值即可。 // @Transactional(propagation = Propagation.REQUIRED, isolation = // Isolation.READ_COMMITTED, noRollbackFor = &#123; UserAccountException.class &#125;) // 4.使用readOnly指定事务是否只读，即没有写操作，表示这个事务只读取数据但不更新数据， // 这样可以帮助数据库引擎优化事务，若真的是一个只读取数据库值的方法，应设置 readOnly=true // 5.timeout:单位 秒，使用timeout指定强制回滚之前事务可以占用的时间。 @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, readOnly = false, timeout = 3) @Override public void checkout(String username, List&lt;String&gt; isbns) &#123; for (String isbn : isbns) &#123; bookShopService.purchase(username, isbn); &#125; &#125;&#125; 获取源代码 基于XML文件方式新建包com.leezp.spring.tx.xml。复制com.leezp.spring.tx包下的BookShopDao.java、BookStockException.java、UserAccountException.java到com.leezp.spring.tx.xml包。在该包下新建BookShopDaoImpl.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.leezp.spring.tx.xml;import org.springframework.jdbc.core.JdbcTemplate;public class BookShopDaoImpl implements BookShopDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public int findBookPriceByIsbn(String isbn) &#123; String sql = " select price from book where isbn = ? "; return jdbcTemplate.queryForObject(sql, Integer.class, isbn); &#125; @Override public void updateBookStock(String isbn) &#123; // 检查书的库存是否足够，若不够，则抛出异常 String sql2 = " select stock from book_stock where isbn = ? "; int stock = jdbcTemplate.queryForObject(sql2, Integer.class, isbn); if (stock == 0) &#123; // 定义一个异常类 throw new BookStockException("库存不足"); &#125; String sql = " update book_stock set stock= stock -1 where isbn = ? "; jdbcTemplate.update(sql, isbn); &#125; @Override public void updateUserAccount(String username, int price) &#123; // 验证余额是否足够，若不足，则抛出异常 String sql2 = " select balance from account where username = ? "; int balance = jdbcTemplate .queryForObject(sql2, Integer.class, username); if (balance &lt; price) &#123; throw new UserAccountException("余额不足"); &#125; String sql = " update account set balance=balance - ? where username = ? "; jdbcTemplate.update(sql, price, username); &#125;&#125; 新建包com.leezp.spring.tx.xml.service。复制com.leezp.spring.tx.xml包下的Cashier.java、BookShopService.java到包com.leezp.spring.tx.xml.service。新建包com.leezp.spring.tx.xml.service.impl。在该包下新建BookShopServiceImpl.java。 123456789101112131415161718192021222324package com.leezp.spring.tx.xml.service.impl;import com.leezp.spring.tx.xml.BookShopDao;import com.leezp.spring.tx.xml.service.BookShopService;public class BookShopServiceImpl implements BookShopService &#123; private BookShopDao bookShopDao; public void setBookShopDao(BookShopDao bookShopDao) &#123; this.bookShopDao = bookShopDao; &#125; @Override public void purchase(String username, String isbn) &#123; // 1.获取书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); // 2.更新书的库存 -1 bookShopDao.updateBookStock(isbn); // 3.更新用户余额 bookShopDao.updateUserAccount(username, price); &#125;&#125; 在该包下新建CashierImpl.java。 1234567891011121314151617public class CashierImpl implements Cashier &#123; private BookShopService bookShopService; public void setBookShopService(BookShopService bookShopService) &#123; this.bookShopService = bookShopService; &#125; @Override public void checkout(String username, List&lt;String&gt; isbns) &#123; for (String isbn : isbns) &#123; bookShopService.purchase(username, isbn); &#125; &#125;&#125; 新建配置文件applicationContext-tx-xml.xml。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;context:component-scan base-package="com.leezp.spring"&gt;&lt;/context:component-scan&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置c3p0数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Spring 的jdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Bean --&gt; &lt;bean id="bookShopDao" class="com.leezp.spring.tx.xml.BookShopDaoImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="bookShopService" class="com.leezp.spring.tx.xml.service.impl.BookShopServiceImpl"&gt; &lt;property name="bookShopDao" ref="bookShopDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="cashier" class="com.leezp.spring.tx.xml.service.impl.CashierImpl"&gt; &lt;property name="bookShopService" ref="bookShopService"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 1.配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2.配置事务属性：传播行为、隔离级别、回滚、过期时间 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 根据方法名指定事务的属性 --&gt; &lt;tx:method name="purchase" propagation="REQUIRES_NEW" /&gt; &lt;tx:method name="*" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 3.配置事务切入点（在哪个方法起作用）以及把事务切入点和事务属性关联起来 --&gt; &lt;aop:config&gt; &lt;!-- 设置 任意返回值任意类型任意方法任意参数 --&gt; &lt;aop:pointcut expression="execution(* com.leezp.spring.tx.xml.service.*.*(..))" id="txPointCut" /&gt; &lt;!-- 用 &lt;aop:advisor&gt;将事务切入点和事务属性关联起来 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 在包com.leezp.spring.tx.xml下新建SpringTransactionTest.java。 123456789101112131415161718192021222324252627282930313233343536package com.leezp.spring.tx.xml;import java.util.Arrays;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.tx.xml.service.BookShopService;import com.leezp.spring.tx.xml.service.Cashier;public class SpringTransactionTest &#123; private ApplicationContext ctx = null; private BookShopDao bookShopDao = null; private BookShopService bookShopService = null; private Cashier cashier = null; &#123; ctx = new ClassPathXmlApplicationContext( "applicationContext-tx-xml.xml"); bookShopDao = ctx.getBean(BookShopDao.class); bookShopService = ctx.getBean(BookShopService.class); cashier = ctx.getBean(Cashier.class); &#125; @Test public void testTransactionlPropagation() &#123; cashier.checkout("AA", Arrays.asList("1001", "1002")); &#125; @Test public void testBookShopService() &#123; bookShopService.purchase("AA", "1001"); &#125;&#125; 获取源代码 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（五）Spring对JDBC的支持]]></title>
      <url>%2Fblog%2F2016%2F08%2F27%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring对JDBC的支持。 JdbcTemplate 简介为了使JDBC更加易于使用，Spring在JDBC API上定义了一个抽象层，以此建立一个JDBC存取框架。 作为Spring JDBC框架的核心，JDBC模板的设计目的是为不同类型的JDBC操作提供模板方法。每个模板方法都能控制整个过程，并允许覆盖过程中的特定任务。通过这种方式，可以在尽可能保留灵活性的情况下，将数据库存取的工作量降到最低。 使用 JdbcTemplate更新数据库用sql语句和参数更新数据库：update public int update(String sql,Object… args) throw DataAccessException 批量更新数据库batchUpdate public int[] batchUpdate(String sql,List batchArgs) 使用 JdbcTemplate查询数据库查询单行queryForObject public T queryForObject(String sql,ParameterizedRowMapper n,Object… args)throws DataAccessException 便利的BeanPropertyRowMappper实现org.springframework.jdbc.core.simpleClass ParameterizedBeanPropertyRowMapper java.lang.ObjectBeanPropertyRowMapperParameterizedBeanPropertyRowMapper 查询多行query public List query(String sql,ParameterizedRowMapper n,Object… args) throws DataAccessException 单值查询queryForObject public T queryForObject(String sql,Class requiredType,Object… args) throws DataAccessException 简化JDBC模板查询每次使用都创建一个JdbcTemplate的新实例，这种做法效率很低下。JdbcTemplate类被设计成为线程安全的，所以可以在IOC容器中声明它的单个实例，并将这个实例注入到所有的DAO实例中。JdbcTemplate 也利用了Java 1.5 的特定（自动装箱，泛型，可变长度等）来简化开发。SpringJDBC框架还提供了一个JdbcDaoSupport类来简化DAO实现。该类声明了jdbcTemplate属性，它可以从IOC容器中注入，或者自动从数据源中创建。不推荐使用 JdbcDaoSupport，而推荐直接使用 JdbcTemplate作为Dao类的成员变量。 新建项目spring-03。新建文件夹lib。导入如下的包并build path。c3p0-0.9.1.2.jarcom.springsource.net.sf.cglib-2.2.0.jarcom.springsource.org.aopalliance-1.0.0.jarcom.springsource.org.aspectj.weaver-1.6.8.RELEASE.jarcommons-logging-1.2.jarmysql-connector-java-5.1.22-bin.jarspring-aop-4.0.4.RELEASE.jarspring-aspects-4.0.4.RELEASE.jarspring-beans-4.0.4.RELEASE.jarspring-context-4.0.4.RELEASE.jarspring-core-4.0.4.RELEASE.jarspring-expression-4.0.4.RELEASE.jarspring-jdbc-4.0.4.RELEASE.jarspring-orm-4.0.4.RELEASE.jarspring-tx-4.0.4.RELEASE.jarspring-web-4.0.4.RELEASE.jarspring-webmvc-4.0.4.RELEASE.jar 在该项目下新建包com.leezp.spring.jdbc。在该包下新建Department.java。 1234567891011121314151617181920212223242526272829package com.leezp.spring.jdbc;public class Department &#123; private Integer id; private String name; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return "Department [id=" + id + ", name=" + name + "]"; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 在该包下新建Employee.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.leezp.spring.jdbc;public class Employee &#123; private Integer id; private String lastName; private String email; private Department department; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastname() &#123; return lastName; &#125; public void setLastname(String lastname) &#123; this.lastName = lastname; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; @Override public String toString() &#123; return "Employee [id=" + id + ", lastname=" + lastName + ", email=" + email + ", department=" + department + "]"; &#125;&#125; 新建EmployeeDao.java。 1234567891011121314151617181920212223242526272829package com.leezp.spring.jdbc;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Repository;/** * 注解方式使用JdbcTemplate * * @author Lee * */@Repositorypublic class EmployeeDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public Employee get(Integer id) &#123; String sql = " select id,last_name lastName,email from employees where id = ? "; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, id); return employee; &#125;&#125; 新建DepartmentDao.java。 1234567891011121314151617181920212223242526272829303132package com.leezp.spring.jdbc;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;import org.springframework.stereotype.Repository;import com.leezp.spring.jdbc.Department;/** * 不推荐使用 JdbcDaoSupport，而推荐直接使用 JdbcTemplate作为Dao类的成员变量 * * @author Lee * */@Repositorypublic class DepartmentDao extends JdbcDaoSupport &#123; @Autowired public void setDataSource2(DataSource dataSource) &#123; setDataSource(dataSource); &#125; public Department get(Integer id) &#123; String sql = " select id,dept_name name from departments where id=? "; RowMapper&lt;Department&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Department.class); return getJdbcTemplate().queryForObject(sql, rowMapper, id); &#125;&#125; 新建db.properties属性文件。 1234567jdbc.user=rootjdbc.password=rootjdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/spring_demojdbc.initPoolSize=5jdbc.maxPoolSize=10 新建applicationContext.xml配置文件。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;context:component-scan base-package="com.leezp.spring.jdbc"&gt;&lt;/context:component-scan&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置c3p0数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Spring 的jdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在该包下new-&gt; JUnit Test Case-&gt; 新建一个JDBCTest.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.leezp.spring.jdbc;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import javax.sql.DataSource;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;public class JDBCTest &#123; private ApplicationContext ctx = null; private JdbcTemplate jdbcTemplate; private EmployeeDao employeeDao; private DepartmentDao departmentDao; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate"); employeeDao = ctx.getBean(EmployeeDao.class); departmentDao = ctx.getBean(DepartmentDao.class); &#125; // 可以 双击方法名，使其变蓝，右键，run as-&gt; JUnit Test 单独运行这一个测试方法 @Test public void testDepartmentDao() &#123; System.out.println(departmentDao.get(1)); &#125; @Test public void testEmployeeDao() &#123; System.out.println(employeeDao.get(1)); &#125; /** * 获取单个Bean的值，或做统计查询 * * queryForObject(String sql, Class&lt;Long&gt; requiredType) */ @Test public void testQueryForObject2() &#123; String sql = " select count(id) from employees "; long count = jdbcTemplate.queryForObject(sql, Long.class); System.out.println(count); &#125; /** * 查到实体类的集合 * * query(sql, rowMapper, args) */ @Test public void testQueryForList() &#123; String sql = " SELECT id,last_name lastName,email,dept_id From employees where id&gt;? "; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper, 5); System.out.println(employees); &#125; /** * 从数据库中获取一条记录，实际得到对应的一个对象 * * 注意不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, * Object...args)方法 * * 而是调用queryForObject(sql, rowMapper, args)方法。 * * 1.其中的 RowMapper 指定如何去映射结果集的行，常用的实现类为BeanPropertyRowMapper。 * * 2.使用SQL中列的别名完成列名和类的属性名的映射。例如 last_name lastName。 * * 3.不支持级联属性，JdbcTemplate到底是一个JDBC的小工具，而不是ORM框架。 */ // 结果：Employee [id=1, lastname=Tom, email=tom@qq.com, department=null] @Test public void testQueryForObject() &#123; String sql = " SELECT id,last_name lastName,email,dept_id as \"department.id\" From employees where id=? "; // import org.springframework.jdbc.core.RowMapper; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1); System.out.println(employee); &#125; /** * 执行批量insert/update/delete * * 最后一个参数是 Object[] 的 List 类型: 因为修改一条记录需要一个Object的数组，那么多条不就需要多个Object的数组吗 */ @Test public void testBatchUpdate() &#123; String sql = " INSERT INTO employees(last_name,email,dept_id) values(?,?,?) "; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(new Object[] &#123; "AA", "AA@qq.com", 1 &#125;); batchArgs.add(new Object[] &#123; "BB", "BB@qq.com", 2 &#125;); batchArgs.add(new Object[] &#123; "CC", "CC@qq.com", 3 &#125;); jdbcTemplate.batchUpdate(sql, batchArgs); &#125; /** * 执行 INSERT,UPDATE,DELETE */ @Test public void testUpdate() &#123; String sql = "UPDATE employees SET LAST_NAME=? where ID =? "; jdbcTemplate.update(sql, "Jack", 5); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125; 获取源代码获取数据库文件 在JDBC模板中使用具名参数在经典的JDBC用法中，SQL参数是用占位符？表示，并且受到位置的限制。定位参数的问题在于，一旦参数的顺序发生变化，就必须改变参数绑定。在SpringJDBC框架中，绑定SQL参数的另一种选择是使用具名参数(named parameter)。具名参数：SQL按名称（以冒号开头）而不是按位置进行指定。具名参数更易于维护，也提升了可读性。具名参数由框架类在运行时用占位符取代。具名参数只在NamedParameterJdbcTemplate中得到支持。 修改applicationContext.xml配合文件。增加以下内容。 12345&lt;!-- 配置namedParameterJdbcTemplate,该对象可以使用具名参数，其没有无参数的构造器，所以必须为其构造器指定参数 --&gt; &lt;bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"&gt; &lt;constructor-arg ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 修改Employee.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.leezp.spring.jdbc;public class Employee &#123; private Integer deptId; private String lastName; private String email; private Department department; public Integer getDeptId() &#123; return deptId; &#125; public void setDeptId(Integer deptId) &#123; this.deptId = deptId; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getLastname() &#123; return lastName; &#125; public void setLastname(String lastname) &#123; this.lastName = lastname; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; @Override public String toString() &#123; return "Employee [deptId=" + deptId + ", lastName=" + lastName + ", email=" + email + ", department=" + department + "]"; &#125;&#125; 修改JDBCTest.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package com.leezp.spring.jdbc;import java.sql.SQLException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.sql.DataSource;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;import org.springframework.jdbc.core.namedparam.SqlParameterSource;public class JDBCTest &#123; private ApplicationContext ctx = null; private JdbcTemplate jdbcTemplate; private EmployeeDao employeeDao; private DepartmentDao departmentDao; private NamedParameterJdbcTemplate namedParameterJdbcTemplate; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate"); employeeDao = ctx.getBean(EmployeeDao.class); departmentDao = ctx.getBean(DepartmentDao.class); namedParameterJdbcTemplate = ctx .getBean(NamedParameterJdbcTemplate.class); &#125; /** * 使用具名参数时，可以使用update(String sql, SqlParameterSource paramSource)方法进行更新操作 * 1.SQL语句中的参数名和类的属性一致 * 2.使用SqlParameterSource 的 BeanPropertySqlParameterSource实现类作为参数。 */ @Test public void testNamedParameterJdbcTemplate2() &#123; String sql = " INSERT INTO employees(last_name,email,dept_id) values(:lastName,:email,:deptId) "; Employee employee = new Employee(); employee.setLastname("ABC"); employee.setEmail("lee@leezp.space"); employee.setDeptId(3); SqlParameterSource paramSource = new BeanPropertySqlParameterSource( employee); namedParameterJdbcTemplate.update(sql, paramSource); &#125; /** * 优点：参数多的时候可以为参数起名字，便于维护 * * 缺点：较为繁琐 * */ @Test public void testNamedParameterJdbcTemplate() &#123; String sql = " INSERT INTO employees(last_name,email,dept_id) values(:ln,:email,:deptid) "; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put("ln", "FF"); paramMap.put("email", "ff@leezp.space"); paramMap.put("deptid", 2); namedParameterJdbcTemplate.update(sql, paramMap); &#125; // 可以 双击方法名，使其变蓝，右键，run as-&gt; JUnit Test 单独运行这一个测试方法 @Test public void testDepartmentDao() &#123; System.out.println(departmentDao.get(1)); &#125; @Test public void testEmployeeDao() &#123; System.out.println(employeeDao.get(1)); &#125; /** * 获取单个Bean的值，或做统计查询 * * queryForObject(String sql, Class&lt;Long&gt; requiredType) */ @Test public void testQueryForObject2() &#123; String sql = " select count(id) from employees "; long count = jdbcTemplate.queryForObject(sql, Long.class); System.out.println(count); &#125; /** * 查到实体类的集合 * * query(sql, rowMapper, args) */ @Test public void testQueryForList() &#123; String sql = " SELECT id,last_name lastName,email,dept_id From employees where id&gt;? "; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper, 5); System.out.println(employees); &#125; /** * 从数据库中获取一条记录，实际得到对应的一个对象 * * 注意不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, * Object...args)方法 * * 而是调用queryForObject(sql, rowMapper, args)方法。 * * 1.其中的 RowMapper 指定如何去映射结果集的行，常用的实现类为BeanPropertyRowMapper。 * * 2.使用SQL中列的别名完成列名和类的属性名的映射。例如 last_name lastName。 * * 3.不支持级联属性，JdbcTemplate到底是一个JDBC的小工具，而不是ORM框架。 */ // 结果：Employee [id=1, lastname=Tom, email=tom@qq.com, department=null] @Test public void testQueryForObject() &#123; String sql = " SELECT id,last_name lastName,email,dept_id as \"department.id\" From employees where id=? "; // import org.springframework.jdbc.core.RowMapper; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1); System.out.println(employee); &#125; /** * 执行批量insert/update/delete * * 最后一个参数是 Object[] 的 List 类型: 因为修改一条记录需要一个Object的数组，那么多条不就需要多个Object的数组吗 */ @Test public void testBatchUpdate() &#123; String sql = " INSERT INTO employees(last_name,email,dept_id) values(?,?,?) "; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(new Object[] &#123; "AA", "AA@qq.com", 1 &#125;); batchArgs.add(new Object[] &#123; "BB", "BB@qq.com", 2 &#125;); batchArgs.add(new Object[] &#123; "CC", "CC@qq.com", 3 &#125;); jdbcTemplate.batchUpdate(sql, batchArgs); &#125; /** * 执行 INSERT,UPDATE,DELETE */ @Test public void testUpdate() &#123; String sql = "UPDATE employees SET LAST_NAME=? where ID =? "; jdbcTemplate.update(sql, "Jack", 5); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125; 获取源代码 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（四）Spring AOP]]></title>
      <url>%2Fblog%2F2016%2F08%2F20%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring AOP（面向切面编程）。 代理设计模式的原理使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 新建项目 spring-02。在项目下新建包com.leezp.spring.aop.helloworld。在该包下新建ArithmeticCalculator.java接口。 1234567891011package com.leezp.spring.aop.helloworld;public interface ArithmeticCalculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125; 新建接口的实现类ArithmeticCalculatorImpl.java。 12345678910111213141516171819202122232425262728package com.leezp.spring.aop.helloworld;public class ArithmeticCalculatorImpl implements ArithmeticCalculator &#123; @Override public int add(int i, int j) &#123; int res = i + j; return res; &#125; @Override public int sub(int i, int j) &#123; int res = i - j; return res; &#125; @Override public int mul(int i, int j) &#123; int res = i * j; return res; &#125; @Override public int div(int i, int j) &#123; int res = i / j; return res; &#125;&#125; 新建动态代理类ArithmeticCalculatorLoggingProxy.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.leezp.spring.aop.helloworld;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/** * 动态代理 * * @author Lee * */public class ArithmeticCalculatorLoggingProxy &#123; // 要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; public ArithmeticCalculator getLoggingproxy() &#123; ArithmeticCalculator proxy = null; // 代理对象由哪一个类加载器负责加载 ClassLoader loader = target.getClass().getClassLoader(); // 代理对象的类型，即其中有哪些方法 Class[] interfaces = new Class[] &#123; ArithmeticCalculator.class &#125;; // 当调用代理对象其中的方法时，该执行的代码 InvocationHandler h = new InvocationHandler() &#123; /** * proxy：正在返回的那个代理对象。一般情况下，在invoke方法中都不使用该对象或该对象的方法， * 防止出现再次调用invoke函数的死循环 ；method:正在被调用的方法 ；args:调用方法时，传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); // 日志 System.out.println("The method " + methodName + " begins with " + Arrays.asList(args)); // 执行方法 Object res = method.invoke(target, args); // 日志 System.out.println("The method " + methodName + " ends with " + res); return res; &#125; &#125;; proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h); return proxy; &#125;&#125;``` 新建Main.java。123456789101112131415161718192021222324``` bashpackage com.leezp.spring.aop.helloworld;public class Main &#123; public static void main(String[] args) &#123; /* * ArithmeticCalculator ari = null; ari = new * ArithmeticCalculatorImpl(); */ ArithmeticCalculator target = new ArithmeticCalculatorImpl(); ArithmeticCalculator proxy = new ArithmeticCalculatorLoggingProxy( target).getLoggingproxy(); System.out.println(proxy.getClass().getName());// 打印代理名称 int res = proxy.add(1, 2); System.out.println(res); res = proxy.div(4, 2); System.out.println(res); &#125;&#125; 在控制台观察运行结果。 1234567$Proxy0The method add begins with [1, 2]The method add ends with 33The method div begins with [4, 2]The method div ends with 22 获取源代码 AOP 简介AOP(Aspect-Oriented Programming,面向切面编程):是一种新的方法论，是对传统OOP(Object-Oriented Programming,面向对象编程)的补充。 AOP的主要编程对象是切面(aspect)，而切面模块化横切关注点。 在应用AOP编程时，仍然需要定义公共功能，但可以明确的定义这个功能在哪里，以什么方式应用，并且不必修改受影响的类。这样一来横切关注点就被模块化到特殊的对象（切面）里。 AOP的好处：1.每个事物逻辑位于一个位置，代码不分散，便于维护和升级。2.业务模块更简洁，只包含核心业务代码。 AOP 术语切面(Aspect)：横切关注点（跨越应用程序多个模块的功能）被模块化的特殊对象。 通知(Active)：切面必须要完成的工作。 目标(Target)：被通知的对象。 代理(Proxy)：向目标对象应用通知之后创建的对象。 连接点(Joinpoint)：程序执行的某个特定位置:如类某个方法调用前、调用后、方法抛出异常后等。连接点由两个信息确定：方法表示的程序执行点。相对点表示方位。例如ArithmeticCalculator#add()方法执行前的连接点执行点为ArithmeticCalculator#add()；方位为该方法执行前的位置。 切点(pointcut)：每个类都拥有多个连接点：例如ArithmeticCalculator的所有方法实际上都是连接点，即连接点是程序类中客观存在的事务。AOP通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 AspectJJava社区里最完整最流行的AOP框架。 在Spring2.0以上版本中，可以使用基于AspectJ注解或基于XML配置的AOP。 在Spring中启用AspectJ注解支持要在Spring应用中使用AspectJ注解，必须在classpath下包含AspectJ类库：aopalliance.jar、aspectj.weaver.jar和spring-aspects.jar。 将aop Schema添加到根元素中。 要在Spring IOC容器中启动AspectJ注解支持，只要在Bean配置文件中定义一个空的XML元素。 当Spring IOC容器侦测到Bean配置文件中的元素时，会自动为与AspectJ切面匹配的Bean创建代理。 将下图的jar包添加到lib文件夹下并build path。 要在Spring中声明AspectJ切面，只需要在IOC容器中将切面声明为Bean实例。当在Spring IOC容器中初始化AspectJ切面之后，Spring IOC 容器就会为那些与AspectJ切面相匹配的Bean创建代理。 在AspectJ注解中，切面只是一个带有@Aspect注解的Java类。 新建包com.leezp.spring.aop.impl。在该包下新建接口ArithmeticCalculator.java。 1234567891011package com.leezp.spring.aop.impl;public interface ArithmeticCalculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125; 新建接口的实现类ArithmeticCalculatorImpl.java。 1234567891011121314151617181920212223242526272829303132package com.leezp.spring.aop.impl;import org.springframework.stereotype.Component;@Componentpublic class ArithmeticCalculatorImpl implements ArithmeticCalculator &#123; @Override public int add(int i, int j) &#123; int res = i + j; return res; &#125; @Override public int sub(int i, int j) &#123; int res = i - j; return res; &#125; @Override public int mul(int i, int j) &#123; int res = i * j; return res; &#125; @Override public int div(int i, int j) &#123; int res = i / j; return res; &#125;&#125; 新建applicationContext.xml并添加beans、aop、context节点。 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;context:component-scan base-package="com.leezp.spring.aop.impl"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 新建Main.java。 123456789101112131415161718package com.leezp.spring.aop.impl;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml"); ArithmeticCalculator arithmeticCalculator = ctx .getBean(ArithmeticCalculator.class); int res = arithmeticCalculator.add(3, 4); System.out.println(res); &#125;&#125; 在控制台观察运行结果。 17 获取源代码 新建一个日志处理的切面LoggingAspect.java。 12345678910111213141516171819202122232425262728293031323334353637383940package com.leezp.spring.aop.impl;import java.util.Arrays;import java.util.List;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;//把这个类声明为一个切面：需要1.把该类放入到IOC容器中@Component;2.声明为一个切面@Aspect@Aspect@Componentpublic class LoggingAspect &#123; // 声明该方法是一个前置通知：在目标方法开始之前执行 // 执行（public 返回值 包名 接口名 方法（参数）） // **还需要在配置文件中加配置&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;使@Before这个注解起作用** // @Before作用：当调用一个目标方法和声明的注解相匹配的时候， // aop框架自动为那个方法所在的类生成一个代理对象， // 在调用目标方法之前，将这句话加进去。 // .*代表接口里的所有方法 @Before("execution(public int com.leezp.spring.aop.impl.ArithmeticCalculator.*(int,int))") public void beforeMethod(JoinPoint joinPoint) &#123; // 连接点 JoinPoint String methodName = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println("The method " + methodName + " begins with" + args); &#125; // 后置通知：在目标方法执行后（无论是否发生异常）执行的通知 // 注意：在后置通知中还不能访问目标方法的执行结果，要在**返回通知**里访问。 @After("execution(public int com.leezp.spring.aop.impl.ArithmeticCalculator.*(int,int))") public void afterMethod(JoinPoint joinPoint) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println("The method " + methodName + " ends"); &#125;&#125; 修改 applicationContext.xml。 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;context:component-scan base-package="com.leezp.spring.aop.impl"&gt;&lt;/context:component-scan&gt; &lt;!-- 在配置文件中加配置使@Before起作用 --&gt; &lt;!-- 使AspectJ注解起作用:自动为匹配的类生成代理对象 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt; 修改Main.java。 12345678910111213141516171819202122package com.leezp.spring.aop.impl;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml"); ArithmeticCalculator arithmeticCalculator = ctx .getBean(ArithmeticCalculator.class); int res = arithmeticCalculator.add(3, 4); System.out.println(res); res = arithmeticCalculator.div(12, 0); System.out.println(res); &#125;&#125;``` 在控制台观察运行结果。123456789101112131415161718192021222324``` bashException in thread &quot;main&quot; java.lang.ArithmeticException: / by zeroThe method add begins with[3, 4]The method add ends7The method div begins with[12, 0] at com.leezp.spring.aop.impl.ArithmeticCalculatorImpl.div(ArithmeticCalculatorImpl.java:28) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.aspectj.AspectJAfterAdvice.invoke(AspectJAfterAdvice.java:43) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207) at $Proxy8.div(Unknown Source) at com.leezp.spring.aop.impl.Main.main(Main.java:17)The method div ends 获取源代码 Spring AOP配置总结1.加入jar包。com.springsource.org.aopalliance-1.0.0.jarcom.springsource.org.aspectj.weaver-1.6.8.RELEASE.jarcommons-logging-1.2.jarspring-aop-4.0.4.RELEASE.jarspring-aspects-4.0.4.RELEASE.jarspring-beans-4.0.4.RELEASE.jarspring-context-4.0.4.RELEASE.jarspring-core-4.0.4.RELEASE.jarspring-expression-4.0.4.RELEASE.jar2.在配置文件中加入aop的命名空间。3.基于注解的方式①.在配置文件中加入如下配置：&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;②.把横切关注点的代码抽象到切面的类中。i.切面首先是一个IOC中的bean，即加入@Component注解ii.切面还需要加入@Aspect注解③.在类中声明各种通知：通知是标注有某种注解的简单的Java方法。一个切面可以包括一个或多个通知。AspectJ支持5种类型的通知注解：——@Before：前置通知，在方法执行之前执行——@After：后置通知，在方法执行之后执行（连接点返回结果或者抛异常的时候，都执行）——@AfterRunning：返回通知，在方法返回结果之后执行——@AfterThrowing：异常通知，在方法抛出异常之后执行——@Around：环绕通知，围绕着方法执行 i.声明一个方法ii.在方法前加一个注解 例如 @Before(“方法签名“), 利用方法签名编写AspectJ切入点表达式：最典型的切入点表达式是根据方法的签名来匹配各种方法：匹配ArithmeticCalculator中声明的所有方法：第一个代表任意修饰符即任意返回值，第二个代表任意方法，“..”代表匹配任意数量的参数。若目标类与接口与该平面在同一个包中，可以省略包名。匹配ArithmeticCalculator接口的所有公共方法。匹配ArithmeticCalculator中返回double类型数值的方法。匹配第一个参数为double类型的方法，”..”匹配任意数量任意类型的参数。匹配参数类型为double，double类型的方法。④.可以在通知方法中声明一个类型 JoinPoint的参数。然后就能访问链接细节，如方法名称和参数值。 AspectJ支持的5种类型的通知注解、设置切面优先级、相同名称切入点的引用的Demo 基于配置文件方式配置AOPcom.leezp.spring.aop包是用注解方式配置AOP。com.leezp.spring.aop.xml包时用配置文件的方式来配置AOP。 获取源代码 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（三）]]></title>
      <url>%2Fblog%2F2016%2F08%2F13%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[在上一节中，我们已经学会了Bean的一些基本配置。 在这一节中，将补充介绍Bean的配置。 沿用上一节的项目。 Bean的其他配置方法配置Bean之方法二工厂方法通过调用静态工厂方法创建Bean调用静态工厂方法创建Bean是将对象创建的过程封装到静态方法中。当客户端需要对象时，只需要简单地调用静态方法，而不用关心创建对象的细节。 要声明通过静态方法创建的Bean1.在Bean的class属性里指定拥有该工厂方法的类2.在factory-method属性里指定工厂方法的名称3.使用&lt;constructor-arg&gt;元素为该方法传递方法参数。 在src下新建包com.leezp.spring.beans.factory。 在该包下新建Car.java。 12345678910111213141516171819202122232425262728293031323334package com.leezp.spring.beans.factory;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", price=" + price + "]"; &#125; public Car(String brand, double price) &#123; super(); this.brand = brand; this.price = price; &#125;&#125; 新建StaticCarFactory.java。 12345678910111213141516171819202122232425package com.leezp.spring.beans.factory;import java.util.HashMap;import java.util.Map;/** * 静态工厂方法：直接调用某一个类的静态方法就可以返回Bean的实例 * * @author Lee * */public class StaticCarFactory &#123; private static Map&lt;String, Car&gt; cars = new HashMap&lt;String, Car&gt;(); static &#123; cars.put("audi", new Car("audi", 300000)); cars.put("ford", new Car("ford", 400000)); &#125; public static Car getCar(String name) &#123; return cars.get(name); &#125;&#125;``` 新建beans-factory.xml配置文件。123456789101112131415``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 通过静态工厂方法来配置Bean。注意不是配置静态工厂方法实例，而是配置Bean实例 --&gt; &lt;!-- class属性：指向静态工厂方法的全类名；factory-method:指向静态工厂方法的名字； constructor-arg:如果工厂方法需要传入参数，则使用constructor-arg 来配置参数 --&gt; &lt;bean id=&quot;car1&quot; class=&quot;com.leezp.spring.beans.factory.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt; &lt;constructor-arg value=&quot;audi&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt;``` 新建Main.java。12345678910111213141516``` bashpackage com.leezp.spring.beans.factory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-factory.xml&quot;); Car car1 = (Car) ctx.getBean(&quot;car1&quot;);新建beans-beanfactory.xml配置文件。 System.out.println(car1); &#125;&#125;``` 在控制台观察运行结果。123``` bashCar [brand=audi, price=300000.0]``` 通过调用实例工厂方法创建Bean实例工厂方法：将对象的创建过程封装到另外一个对象实例的方法里。当客户端需要请求对象时，只需要简单的调用该实例方法而不需要关心对象的创建细节。 要声明通过实例工厂方法创建的Bean1.在bean的factory-bean属性里指定拥有该工厂方法的Bean。2.在factory-method属性里指定该工厂方法的名称。3.使用constructor-arg元素为工厂方法传递方法参数。 新建InstanceCarFactory.java。12345678910111213141516171819202122232425``` bashpackage com.leezp.spring.beans.factory;import java.util.HashMap;import java.util.Map;/** * 实例工厂方法：实例工厂的方法，即先需要创建工厂本身，再调用工厂的实例方法 * * @author Lee * */public class InstanceCarFactory &#123; private Map&lt;String, Car&gt; cars = null; public InstanceCarFactory() &#123; cars = new HashMap&lt;String, Car&gt;(); cars.put(&quot;audi&quot;, new Car(&quot;audi&quot;, 400000)); cars.put(&quot;ford&quot;, new Car(&quot;ford&quot;, 300000)); &#125; public Car getCar(String brand) &#123; return cars.get(brand); &#125;&#125; 修改beans-factory.xml配置文件。 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 通过静态工厂方法来配置Bean。注意不是配置静态工厂方法实例，而是配置Bean实例 --&gt; &lt;!-- class属性：指向静态工厂方法的全类名；factory-method:指向静态工厂方法的名字； constructor-arg:如果工厂方法需要传入参数，则使用constructor-arg 来配置参数 --&gt; &lt;bean id="car1" class="com.leezp.spring.beans.factory.StaticCarFactory" factory-method="getCar"&gt; &lt;constructor-arg value="audi"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- Invalid bean definition with name 'car2' defined in class path resource [beans-factory.xml]: factory-bean reference points back to the same bean definition --&gt; &lt;!-- 配置工厂的实例 --&gt; &lt;bean id="carFactory" class="com.leezp.spring.beans.factory.InstanceCarFactory"&gt;&lt;/bean&gt; &lt;bean id="car2" factory-bean="carFactory" factory-method="getCar"&gt; &lt;constructor-arg value="audi"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 修改Main.java。 123456789101112131415161718package com.leezp.spring.beans.factory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "beans-factory.xml"); Car car1 = (Car) ctx.getBean("car1"); System.out.println(car1); Car car2 = (Car) ctx.getBean("car2"); System.out.println(car2); &#125;&#125; 在控制台观察运行结果。 123Car [brand=audi, price=300000.0]Car [brand=audi, price=400000.0]``` 获取源代码 配置Bean之方法三FactoryBean新建包com.leezp.spring.beans.factorybean。 在该包下新建Car.java。123456789101112131415161718192021222324252627282930313233343536``` bashpackage com.leezp.spring.beans.factorybean;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;; &#125; public Car(String brand, double price) &#123; super(); this.brand = brand; this.price = price; &#125;&#125;``` 新建CarFactoryBean.java。123456789101112131415161718192021222324252627282930313233``` bashpackage com.leezp.spring.beans.factorybean;import org.springframework.beans.factory.FactoryBean;//自定义的FactoryBean需要实现 FactoryBean 接口public class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; private String brand; public void setBrand(String brand) &#123; this.brand = brand; &#125; // 返回Bean的对象 @Override public Car getObject() throws Exception &#123; return new Car(&quot;BMW&quot;, 500000); &#125; // 返回bean的类型 @Override public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; // 是否为单实例 @Override public boolean isSingleton() &#123; return true; &#125;&#125; 新建beans-beanfactory.xml配置文件。 1234567891011121314151617181920212223242526272829303132package com.leezp.spring.beans.factorybean;import org.springframework.beans.factory.FactoryBean;//自定义的FactoryBean需要实现 FactoryBean 接口public class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; private String brand; public void setBrand(String brand) &#123; this.brand = brand; &#125; // 返回Bean的对象 @Override public Car getObject() throws Exception &#123; return new Car("BMW", 500000); &#125; // 返回bean的类型 @Override public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; // 是否为单实例 @Override public boolean isSingleton() &#123; return true; &#125;&#125; 新建Main.java。 123456789101112131415package com.leezp.spring.beans.factorybean;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "beans-beanfactory.xml"); Car c = (Car) ctx.getBean("car"); System.out.println(c); &#125;&#125;``` 在控制台观察运行结果。123``` bashCar [brand=BMW, price=500000.0]``` 获取源代码 Bean的第二种配置形式——基于注解的方式spring从2.5版本开始支持注解注入，注解注入可以省去很多的xml配置工作。由于注解是写入java代码中的，所以注解注入会失去一定的灵活性，我们要根据需要来选择是否启用注解注入。 在classpath中扫描组件组件扫描（component scanning）:Spring能够从classpath下自动扫描，侦测和实例化具有特定注解的组件。 特定组件包括：1.@Component:基本注解，标识了一个受Spring管理的组件2.@Repository:标识持久层组件(可将DAO类声明为Bean )3.@Service：标识服务层（业务层）组件4.@Controller:标识表现层组件 对于扫描到的组件，Spring有默认的命名策略：使用非限定类名，第一个字母小写。也可以在注解中通过value属性值标识组件的名称。 当在组件类上使用了特定的注解之后，还需要在Spring的配置文件中声明&lt;context:component-scan&gt;:1.base-package属性指定一个需要扫描的基类包，Spring容器将会扫描这个基类包里及其子包中的所有类。2.当需要扫描多个包时，可以使用逗号分隔。3.如果仅希望扫描特定的类而非基包下的所有类，可使用resource-pattern属性过滤特定的类，示例：1234``` bash&lt;context:component-scan base-package=&quot;com.leezp.spring.beans&quot; resource-pattern=&quot;autowire/*.class&quot; /&gt;``` 4.&lt;context:include-filter&gt;子节点表示要包含的目标类。5.&lt;context:exclude-filter&gt;子节点表示要排除在外的目标类。6.&lt;context:component-scan&gt;下可以拥有若干个&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子节点。&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子节点支持多种类型的过滤表达式： filter标签的type和表达式说明如下图。annotation:所有标注了XxxAnnotation的类。该类型采用目标类是否标注了某个注解进行过滤。assinable:所有继承或扩展XxxService的类。该类型采用目标类是否继承或扩展某个特定类进行过滤。aspectj:所有类名以Service结束的类及继承或扩展它们的类。该类型采用aspectj表达式进行过滤。regex:示例：com.\leezp.anno_*:所有com.leezp.anno包下的类。该类型采用正则表达式根据类的类名进行过滤custom:采用XxxTypeFilter通过代码的方式定义过滤规则。该类必须实现org.springframework.core.type.TypeFilter接口。 新建包com.leezp.spring.beans.annotation。 在该包下新建TestObject.java。1234567891011``` bashpackage com.leezp.spring.beans.annotation;import org.springframework.stereotype.Component;// 只加了@Component以后项目名称右上角还没有&quot;S&quot;的小标签，说明还没有被Spring管理,还要建立Spring配置文件才可以@Componentpublic class TestObject &#123;&#125;``` 新建包com.leezp.spring.beans.annotation.controller。 在该包下新建UserController.java。12345678910111213``` bashpackage com.leezp.spring.beans.annotation.controller;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; public void execute() &#123; System.out.println(&quot;UserController execute...&quot;); &#125;&#125;``` 新建包com.leezp.spring.beans.annotation.repository。 在该包下新建UserRepository.java接口。12345678``` bashpackage com.leezp.spring.beans.annotation.repository;public interface UserRepository &#123; void save();&#125;``` 在该包下新建UserRepository接口的实现类UserRepositoryImpl.java。123456789101112131415``` bashpackage com.leezp.spring.beans.annotation.repository;import org.springframework.stereotype.Repository;@Repository(&quot;userRepository&quot;)public class UserRepositoryImpl implements UserRepository &#123; @Override public void save() &#123; System.out.println(&quot;UserRepository Save...&quot;); &#125;&#125;``` 新建包com.leezp.spring.beans.annotation.service。 在该包下新建业务类UserService.java。12345678910111213``` bashpackage com.leezp.spring.beans.annotation.service;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; public void add() &#123; System.out.println(&quot;UserService add...&quot;); &#125;&#125;``` 新建beans-annotation.xml配置文件。123456789101112131415161718192021222324252627282930313233343536``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 指定SpringIOC容器扫描的包 --&gt; &lt;!-- 加上下面这个配置以后项目名称右上角出现&quot;S&quot;的小标签，说明已被Spring管理 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt;&lt;/context:component-scan&gt; --&gt; &lt;!-- 可以通过resource-pattern指定扫描的资源 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; resource-pattern=&quot;repository/*.class&quot;&gt;&lt;/context:component-scan&gt; --&gt; &lt;!-- context:exclude-filter子节点指定排除哪些指定表达式的组件 ,将不想包含的包粘贴进来 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- context:include-filter子节点指定包含哪些表达式的组件，该子节点需要设置use-default-filters=&quot;false&quot; --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- 不包含UserRepository接口和这个接口所有实现类 --&gt; &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt; &lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.leezp.spring.beans.annotation.repository.UserRepository&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.leezp.spring.beans.annotation.repository.UserRepository&quot; /&gt; &lt;/context:component-scan&gt; --&gt;&lt;/beans&gt; 在com.leezp.spring.beans.annotation包下新建Main.java。 12345678910111213141516171819202122232425262728293031323334353637383940package com.leezp.spring.beans.annotation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.annotation.controller.UserController;import com.leezp.spring.beans.annotation.repository.UserRepository;import com.leezp.spring.beans.annotation.repository.UserRepositoryImpl;import com.leezp.spring.beans.annotation.service.UserService;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "beans-annotation.xml"); // java.lang.ClassNotFoundException: // org.springframework.aop.TargetSource // 这个异常是因为缺少jar包，只需导入spring-aop-4.0.4.RELEASE.jar即可。 TestObject to = (TestObject) ctx.getBean("testObject"); System.out.println(to); UserController u = (UserController) ctx.getBean("userController"); System.out.println(u); UserService us = (UserService) ctx.getBean("userService"); System.out.println(us); /* * UserRepository ur = (UserRepository) ctx.getBean("userRepository"); * System.out.println(ur); */ /* * UserRepositoryImpl xxx = (UserRepositoryImpl) ctx * .getBean("userRepository"); System.out.println(xxx); */ &#125;&#125;``` 这里可能还需要一个Spring的jar包spring-aop-4.0.4.RELEASE.jar，点击下载spring-framework-4.0.4.RELEASE.rar（Spring所需jar包），在里面找到这个jar包添加到项目中并且build path。缺少这个jar包可能报出java.lang.ClassNotFoundException:org.springframework.aop.TargetSource错误。在控制台观察运行结果。12345``` bashcom.leezp.spring.beans.annotation.TestObject@3e431f96com.leezp.spring.beans.annotation.controller.UserController@28ced0c9com.leezp.spring.beans.annotation.service.UserService@21ed510d``` 获取源代码 利用注解来建立Bean之间的引用关系有时候Bean之间是有关联关系的。我们先来建立Bean之间的关联关系，再来研究如何利用注解来建立Bean之间的引用关系。 修改beans-annotation.xml配置文件。123456789101112131415161718192021222324252627282930313233343536``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 指定SpringIOC容器扫描的包 --&gt; &lt;!-- 加上下面这个配置以后项目名称右上角出现&quot;S&quot;的小标签，说明已被Spring管理 --&gt; &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 可以通过resource-pattern指定扫描的资源 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; resource-pattern=&quot;repository/*.class&quot;&gt;&lt;/context:component-scan&gt; --&gt; &lt;!-- context:exclude-filter子节点指定排除哪些指定表达式的组件 ,将不想包含的包粘贴进来 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- context:include-filter子节点指定包含哪些表达式的组件，该子节点需要设置use-default-filters=&quot;false&quot; --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- 不包含UserRepository接口和这个接口所有实现类 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt; &lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.leezp.spring.beans.annotation.repository.UserRepository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.leezp.spring.beans.annotation.repository.UserRepository&quot; /&gt; &lt;/context:component-scan&gt; --&gt;&lt;/beans&gt;``` 修改UserController.java。123456789101112131415161718``` bashpackage com.leezp.spring.beans.annotation.controller;import org.springframework.stereotype.Controller;import com.leezp.spring.beans.annotation.service.UserService;@Controllerpublic class UserController &#123; private UserService userService; public void execute() &#123; System.out.println(&quot;UserController execute...&quot;); userService.add(); &#125;&#125;``` 修改UserService.java。12345678910111213141516171819202122``` bashpackage com.leezp.spring.beans.annotation.service;import org.springframework.stereotype.Service;import com.leezp.spring.beans.annotation.repository.UserRepository;@Servicepublic class UserService &#123; private UserRepository userRepository; public void setUserRepository(UserRepository userRepository) &#123; this.userRepository = userRepository; &#125; public void add() &#123; System.out.println(&quot;UserService add...&quot;); userRepository.save(); &#125;&#125;``` 修改Main.java。12345678910111213141516171819202122232425262728293031323334353637383940414243444546``` bashpackage com.leezp.spring.beans.annotation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.annotation.controller.UserController;import com.leezp.spring.beans.annotation.repository.UserRepository;import com.leezp.spring.beans.annotation.repository.UserRepositoryImpl;import com.leezp.spring.beans.annotation.service.UserService;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-annotation.xml&quot;); // java.lang.ClassNotFoundException: // org.springframework.aop.TargetSource // 这个异常是因为缺少jar包，只需导入spring-aop-4.0.4.RELEASE.jar即可。 /* * TestObject to = (TestObject) ctx.getBean(&quot;testObject&quot;); * System.out.println(to); */ UserController u = (UserController) ctx.getBean(&quot;userController&quot;); System.out.println(u); u.execute(); /* * UserService us = (UserService) ctx.getBean(&quot;userService&quot;); * System.out.println(us); */ /* * UserRepository ur = (UserRepository) ctx.getBean(&quot;userRepository&quot;); * System.out.println(ur); */ /* * UserRepositoryImpl xxx = (UserRepositoryImpl) ctx * .getBean(&quot;userRepository&quot;); System.out.println(xxx); */ &#125;&#125;``` 在控制台观察运行结果。1234567``` bashcom.leezp.spring.beans.annotation.controller.UserController@e28adfbUserController execute...Exception in thread &quot;main&quot; java.lang.NullPointerException at com.leezp.spring.beans.annotation.controller.UserController.execute(UserController.java:14) at com.leezp.spring.beans.annotation.Main.main(Main.java:27)``` 发现报错了。这个错误是因为属性没有被装配。 &lt;context:component-scan&gt;元素还会自动注册AutowiredAnnotationBeanPostProcessor（后置处理器）实例，该实例可以自动装配具有@Autowired和@Resource、@Inject注解的属性。 使用@Autowired自动装配Bean@Autowired注解自动装配具有兼容类型的单个Bean属性。1.构造器，普通字段（即使是非public），一切具有参数的方法（set方法上面）都可以应用@Autowired注解。 给UserController.java添加注解@Autowired。12345678910111213141516171819``` bashpackage com.leezp.spring.beans.annotation.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import com.leezp.spring.beans.annotation.service.UserService;@Controllerpublic class UserController &#123; @Autowired private UserService userService; public void execute() &#123; System.out.println(&quot;UserController execute...&quot;); userService.add(); &#125;&#125;``` 给UserService.java添加注解@Autowired。12345678910111213141516171819202122232425``` bashpackage com.leezp.spring.beans.annotation.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.leezp.spring.beans.annotation.repository.UserRepository;@Servicepublic class UserService &#123; // @Autowired//构造器，普通字段（即使是非public)都可以应用@Autowired注解 private UserRepository userRepository; @Autowired // 一切具有参数的方法（set方法上面）都可以应用@Autowired注解 public void setUserRepository(UserRepository userRepository) &#123; this.userRepository = userRepository; &#125; public void add() &#123; System.out.println(&quot;UserService add...&quot;); userRepository.save(); &#125;&#125;``` 在控制台观察运行结果。123456``` bashcom.leezp.spring.beans.annotation.controller.UserController@730d27f7UserController execute...UserService add...UserRepository Save...``` 2.默认情况下，所有使用@Autowired注解的属性都需要被设置，当Spring找不到匹配的Bean装配属性时，会抛出异常，若某一属性允许不被设置，可以设置@Autowired注解的required属性为false。 修改UserRepositoryImpl.java添加关联关系TestObject。123456789101112131415161718192021``` bashpackage com.leezp.spring.beans.annotation.repository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import com.leezp.spring.beans.annotation.TestObject;@Repository(&quot;userRepository&quot;)public class UserRepositoryImpl implements UserRepository &#123; @Autowired private TestObject testObject; @Override public void save() &#123; System.out.println(&quot;UserRepository Save...&quot;); System.out.println(testObject); &#125;&#125;``` 在控制台观察运行结果。1234567``` com.leezp.spring.beans.annotation.controller.UserController@64bb0423UserController execute...UserService add...UserRepository Save...com.leezp.spring.beans.annotation.TestObject@320cc97f``` 修改TestObject.java去掉@Component使Spring找不到匹配的Bean装配属性。12345678910``` bashpackage com.leezp.spring.beans.annotation;import org.springframework.stereotype.Component;// 只加了@Component以后项目名称右上角还没有&quot;S&quot;的小标签，说明还没有被Spring管理,还要建立Spring配置文件才可以public class TestObject &#123;&#125; 在控制台观察运行结果发现报错：No qualifying bean of type 修改UserRepositoryImpl.java改为@Autowired(required=false)。 12345678910111213141516import org.springframework.stereotype.Repository;import com.leezp.spring.beans.annotation.TestObject;@Repository("userRepository")public class UserRepositoryImpl implements UserRepository &#123; @Autowired(required=false) private TestObject testObject; @Override public void save() &#123; System.out.println("UserRepository Save..."); System.out.println(testObject); &#125;&#125; 在控制台观察运行结果。 123456com.leezp.spring.beans.annotation.controller.UserController@27cacbd9UserController execute...UserService add...UserRepository Save...null``` 3.默认情况下，当IOC容器里存在多个类型兼容的Bean时，通过类型的自动装配将无法工作，此时可以在@Qualifier注解里提供Bean的名称，Spring允许对方法的入参标注@Qualifier已指定注入Bean的名称。 @Qualifier(“XXX”) 中的 XX是 Bean 的名称，所以 @Autowired 和@Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。 百度百科 @Qualifier 在包com.leezp.spring.beans.annotation.repository下新建类UserJdbcRepository.java。1234567891011121314``` bashpackage com.leezp.spring.beans.annotation.repository;import org.springframework.stereotype.Repository;@Repositorypublic class UserJdbcRepository implements UserRepository&#123; @Override public void save() &#123; System.out.println(&quot;UserJdbcRepository save...&quot;); &#125;&#125; 此时即为多个相同类型的bean 解决方法一：@Repository() 括号里的Bean的名字刚好是首字母小写的属性名，即与属性名对应。 解决方法二：@Qualifier注解指定装配哪一个指定的bean。 修改UserService.java。 1234567891011121314151617181920212223242526272829303132333435package com.leezp.spring.beans.annotation.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import com.leezp.spring.beans.annotation.repository.UserRepository;@Servicepublic class UserService &#123; // @Autowired//构造器，普通字段（即使是非public)都可以应用@Autowired注解 private UserRepository userRepository; /* * @Autowired * //@Qualifier使用方式一 * @Qualifier("userRepositoryImpl") // 一切具有参数的方法（set方法上面）都可以应用@Autowired注解 * public void setUserRepository(UserRepository userRepository) &#123; * this.userRepository = userRepository; &#125; */ @Autowired //@Qualifier使用方式二 // 一切具有参数的方法（set方法上面）都可以应用@Autowired注解 public void setUserRepository( @Qualifier("userRepositoryImpl") UserRepository userRepository) &#123; this.userRepository = userRepository; &#125; public void add() &#123; System.out.println("UserService add..."); userRepository.save(); &#125;&#125;``` 4.@Autowired注解也可以应用在数组类型的属性上，此时Spring将会把所有匹配的Bean进行自动装配。5.@Autowired注解也可以应用在集合属性上，此时Spring读取该集合的类型信息，然后自动装配所有与之兼容的Bean。6.@Autowired注解用在java.util.Map上时，若该Map的键值为Spring，那么Spring将自动装配与之Map值类型兼容的Bean，此时Bean的名称作为健值。 使用@Resource或@Inject自动装配Bean1.Spring还支持@Resource和@Inject注解，这两个注解和@Autowired注解的功用类似。2.@Resource注解要求提供一个Bean名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为Bean的名称。3.@Inject和@Autowired注解一样也是按类型匹配注入的Bean，但没有required属性。4.建议使用@Autowired注解。 获取源代码 Spring4.x 新特性： 泛型依赖注入Spring 4.x中可以为子类注入子类对应的泛型类型的成员变量的引用。通俗一点来说：两个子类之间的依赖关系不需要在子类中去声明，而是在父类中进行了声明，而依赖的纽带就是 泛型类型，必须是相同的父类泛型类型才具有依赖关系。 新建包com.leezp.spring.beans.generic.di。在该包下新建BaseRepository.java。123456``` bashpackage com.leezp.spring.beans.generic.di;public class BaseRepository&lt;T&gt; &#123;&#125; 在该包下新建BaseService.java。 1234567891011121314package com.leezp.spring.beans.generic.di;import org.springframework.beans.factory.annotation.Autowired;public class BaseService&lt;T&gt; &#123; @Autowired //在这里加注解会被子类继承 protected BaseRepository&lt;T&gt; repository; public void add() &#123; System.out.println("add..."); System.out.println(repository); &#125;&#125; 新建UserRepository.java。 123456789package com.leezp.spring.beans.generic.di;import org.springframework.stereotype.Repository;@Repositorypublic class UserRepository extends BaseRepository&lt;User&gt;&#123;&#125;``` 新建UserService.java。12345678910``` bashpackage com.leezp.spring.beans.generic.di;import org.springframework.stereotype.Service;@Servicepublic class UserService extends BaseService&lt;User&gt;&#123;&#125;``` 新建User.java。123456``` bashpackage com.leezp.spring.beans.generic.di;public class User&#123;&#125; 新建Main.java。 1234567891011121314package com.leezp.spring.beans.generic.di;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "beans-generic-di.xml"); UserService us = (UserService) ctx.getBean("userService"); us.add(); &#125;&#125; 在控制台观察运行结果。 12add...com.leezp.spring.beans.generic.di.UserRepository@690a614 在以上的代码中，BaseService中引用了BaseRepository，并且在BaseService的add方法中调用了BaseRepository的add方法在他们的子类中，继承了这种关系，因此我们在测试方法中调用userService.add(); 也是可以成功地调用UserRepository中的add方法。获取源代码参考文献Spring jar包详解 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（二）Bean的配置]]></title>
      <url>%2Fblog%2F2016%2F08%2F01%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[在上一节中，我们已经学会了用Eclipse配置Spring4.0环境并创建一个简单的Spring项目。 在这一节中，将介绍Bean的配置。 本教程使用方法从前向后阅读，本文较长，建议分9次学完，每次下载当前的代码。 配置形式基于xml文件的方式，基于注解的方式。 Bean的配置方法通过全类名（反射）、通过工厂方法（静态工厂方法和实例工厂方法）、FactoryBean IOC 容器 BeanFactory 和ApplicationContext 概述在SpringIOC容器读取Bean配置创建Bean实例之前，必须对它进行实例化。只有在容器实例化后，才可以从IOC容器里获取Bean实例并使用。 Spring 提供了两种类型的IOC容器实现。 BeanFactoryIOC容器的基本实现。BeanFactory是Spring 框架的基础设施，面向Spring本身。 ApplicationContext提供了更多高级的特性，是BeanFactory的子接口。ApplicationContext 面向使用Spring框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的BeanFactory。 无论使用何种方式，配置文件是相同的。 ApplicationContext的主要实现类：（Ctrl+T查看）-ClassPathXmlApplicationContext：从类路径下加载配置文件-FileSystemXmlApplicationContext:从文件系统中加载配置文件 ApplicationContext 的子接口ConfigurableApplicationContext,新增加两个主要方法：refresh()和 close(),让ApplicationContext具有启动、刷新和关闭上下文的能力。 ApplicationContext在 初始化上下文 时就 实例化所有单例的Bean。 WebApplicationContext 是专为WEB应用而准备的，它允许从相对于WEB根目录的路径中完成初始化工作。 ApplicationContext的getBean()方法鼠标放在”ApplicationContext”上按住Ctrl 点击进入 ，Window-&gt; show view-&gt; outline 查看方法，其中没有getBean()方法，找到其父接口 ListableBeanFactory ，Ctrl+shit+T 搜索这个父接口，继续用 outline观察它的方法，其中没有getBean()方法，发现它继承了BeanFactory ，继续搜索这个父接口，观察它的方法，找到了getBean()方法。 依赖注入的方式属性注入；构造器注入;工厂方法注入（不推荐） 属性注入属性注入即通过setter 方法注入Bean的属性值或依赖的对象。 属性注入使用元素，使用name 属性指定Bean的属性名称，value属性或子节点指定属性值。 属性注入是实际应用中最常用的注入方式。 构造方法注入构造方法注入属性值或依赖的对象，它保证了Bean实例在实例化以后就可以使用。 构造器注入在&lt;constructor-arg&gt;元素里声明属性，&lt;constructor-arg&gt;中没有name属性。 沿用上一节中的项目。新建一个类 Car.java。 12345678910111213141516171819202122232425262728package com.leezp.spring.beans;public class Car &#123; private String brand; private String corp; private double price; private int maxSpeed; public Car(String brand, String corp, int maxSpeed) &#123; super(); this.brand = brand; this.corp = corp; this.maxSpeed = maxSpeed; &#125; public Car(String brand, String corp, double price) &#123; super(); this.brand = brand; this.corp = corp; this.price = price; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", corp=" + corp + ", price=" + price + ", maxSpeed=" + maxSpeed + "]"; &#125;&#125; 配置 applicationContext.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id="helloWorld" class="com.leezp.spring.beans.HelloWorld"&gt;&lt;!-- 反射 --&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id="car" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Audi" index="0"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="ShangHai" index="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="100000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id="car2" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Baoma" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="int"&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 修改 Main.java 1234567891011121314151617181920212223242526272829303132package com.leezp.spring.beans;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.Car;public class Main &#123; public static void main(String[] args) &#123; /* * // 创建 HelloWorld 的一个对象 HelloWorld helloWorld = new HelloWorld(); * // 为name 属性赋值 helloWorld.setName("lee"); */ // 1. 创建Spring 的IOC 容器对象 // ApplicationContext代表IOC 容器 ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml");// 创建对象时即调用它的set方法对属性赋值 // 2. 从IOC容器中获取Bean实例 // HelloWorld helloWorld = (HelloWorld) ctx.getBean("helloWorld"); // HelloWorld helloWorld = ctx.getBean(HelloWorld.class);//这样做有缺点，配置多个 // bean的时候它不知道访问哪一个，只适用于单个bean // 调用hello方法 // helloWorld.hello(); Car car = (Car) ctx.getBean("car"); System.out.println(car); Car car2 = (Car) ctx.getBean("car2"); System.out.println(car2); &#125;&#125; 运行，在控制台观察结果。 1234HelloWorld's ConstructorsetName:SpringCar [brand=Audi, corp=ShangHai, price=100000.0, maxSpeed=0]Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260] 获取源代码 注入属性值细节可以用字符串表示的值，可以通过元素标签value属性进行注入。若字面值中包含特殊字符，可以使用&lt;![CDATA[]]&gt;把字面值包裹起来。基本数据类型及其封装类、String等类型都可以采取字面值注入的方式，可以自动类型转换。 null值和级联属性可以使用专用的元素标签为Bean的字符串或其他对象类型的属性注入null值（意义不大，因为引用类型默认null）。 为级联属性赋值和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。具体见后面程序applicationContext.xml中的例子。 引用其他bean组成应用程序的Bean经常需要相互协作以完成应用程序的功能，要使Bean能够相互访问，就必须在Bean配置文件中指定对Bean的引用。 在Bean的配置文件中，可以通过元素（标签节点）或ref属性为Bean的属性或构造器参数指定对Bean的引用。 也可以在属性或构造器里包含Bean的声明，这样的Bean称为内部Bean。 新建一个类Person.java。 12345678910111213141516171819202122232425262728293031323334353637383940package com.leezp.spring.beans;public class Person &#123; private String name; private int age; private Car car; public Person() &#123; // TODO Auto-generated constructor stub &#125; public Person(String name, int age, Car car) &#123; super(); this.name = name; this.age = age; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", car=" + car + "]"; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125;&#125; 修改 Car.java。 12345678910111213141516171819202122232425262728293031323334353637package com.leezp.spring.beans;public class Car &#123; private String brand; private String corp; private double price; private int maxSpeed; public Car(String brand, String corp, int maxSpeed) &#123; super(); this.brand = brand; this.corp = corp; this.maxSpeed = maxSpeed; &#125; public Car(String brand, String corp, double price) &#123; super(); this.brand = brand; this.corp = corp; this.price = price; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", corp=" + corp + ", price=" + price + ", maxSpeed=" + maxSpeed + "]"; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125;&#125;``` 修改applicationContext.xml配置文件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.leezp.spring.beans.HelloWorld&quot;&gt;&lt;!-- 反射 --&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;100000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Baoma&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;int&quot;&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car2&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;car&quot;&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;constructor-arg value=&quot;Jerry&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;25&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name=&quot;car.price&quot; value=&quot;300000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 修改Main.java。 1234567891011121314151617181920212223242526272829303132333435363738package com.leezp.spring.beans;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.Person;import com.leezp.spring.beans.Car;public class Main &#123; public static void main(String[] args) &#123; /* * // 创建 HelloWorld 的一个对象 HelloWorld helloWorld = new HelloWorld(); // * 为name 属性赋值 helloWorld.setName("lee"); */ // 1. 创建Spring 的IOC 容器对象 // ApplicationContext代表IOC 容器 ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml");// 创建对象时即调用它的set方法对属性赋值 // 2. 从IOC容器中获取Bean实例 // HelloWorld helloWorld = (HelloWorld) ctx.getBean("helloWorld"); // HelloWorld helloWorld = ctx.getBean(HelloWorld.class);//这样做有缺点，配置多个 // bean的时候它不知道访问哪一个，只适用于单个bean // 调用hello方法 // helloWorld.hello(); Car car = (Car) ctx.getBean("car"); System.out.println(car); Car car2 = (Car) ctx.getBean("car2"); System.out.println(car2); Person p = (Person) ctx.getBean("person"); System.out.println(p); Person p2 = (Person) ctx.getBean("person2"); System.out.println(p2); &#125;&#125; 在控制台观察运行结果。 123456HelloWorld's ConstructorsetName:SpringCar [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260]Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]Person [name=Tom, age=24, car=Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=260]]Person [name=Jerry, age=25, car=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260]] 获取源代码 集合属性在Spring中可以通过一组内置的xml标签（例如：&lt;list&gt;,&lt;set&gt;或&lt;map&gt;来配置集合属性）。 配置java.util.List类型的属性，需要指定&lt;list&gt;标签，在标签里包含一些元素，这些标签可以通过&lt;value&gt;指定简单的常量值，通过&lt;ref&gt;指定对其他Bean的引用。通过&lt;bean&gt;指定内置Bean的定义。通过&lt;null/&gt;指定空元素，甚至可以内嵌其他集合。 数组的定义和List一样，都使用&lt;list&gt;。 配置java.util.Set需要使用&lt;set&gt;标签，定义元素的方法与List一样。 新建一个包命名为com.leezp.spring.beans.collections。 在该包下新建一个类 Person.java。 12345678910111213141516171819202122232425262728293031323334353637383940package com.leezp.spring.beans.collections;import java.util.List;import com.leezp.spring.beans.Car;public class Person &#123; private String name; private int age; private List&lt;Car&gt; cars; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public List&lt;Car&gt; getCars() &#123; return cars; &#125; public void setCars(List&lt;Car&gt; cars) &#123; this.cars = cars; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", cars=" + cars + "]"; &#125;&#125;``` 在该包下新建一个类Main.java。12345678910111213141516``` bashpackage com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); Person p = (Person) ctx.getBean(&quot;person3&quot;); System.out.println(p); &#125;&#125; 修改applicationContext.xml配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id="helloWorld" class="com.leezp.spring.beans.HelloWorld"&gt;&lt;!-- 反射 --&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id="car" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Audi" index="0"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="ShangHai" index="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="100000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id="car2" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Baoma" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="int"&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="person" class="com.leezp.spring.beans.Person"&gt; &lt;property name="name" value="Tom"&gt;&lt;/property&gt; &lt;property name="age" value="24"&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name="car" ref="car2"&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name="car"&gt; &lt;ref bean="car2" /&gt; &lt;/property&gt; --&gt; &lt;property name="car"&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="Changan"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name="car.maxSpeed" value="260"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="person2" class="com.leezp.spring.beans.Person"&gt; &lt;constructor-arg value="Jerry"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="25"&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name="car.price" value="300000"&gt;&lt;/property&gt; &lt;property name="car.maxSpeed" value="260"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id="person3" class="com.leezp.spring.beans.collections.Person"&gt; &lt;property name="name" value="lee"&gt;&lt;/property&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;property name="cars"&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean="car" /&gt; &lt;ref bean="car2" /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="Changan"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 在控制台观察运行结果。12345``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]``` 获取源代码Java.util.Map通过&lt;map&gt;标签定义，&lt;map&gt;标签里可以使用多个&lt;entry&gt;作为子标签，每个条目包含一个键和一个值。 必须在&lt;key&gt;标签里定义键。 因为键和值的类型没有限制，所以可以自由地为它们指定&lt;value&gt;,&lt;ref&gt;,&lt;bean&gt;或&lt;null&gt;元素。 可以将Map的键和值作为&lt;entry&gt;的属性定义：简单常量使用key和value来定义；Bean引用通过key-ref和value-ref属性定义。 使用&lt;props&gt;定义java.util.Properties,该标签使用多个&lt;prop&gt;作为子标签，每个&lt;prop&gt;标签必须定义key属性。 在该包下新建一个类 NewPerson.java。123456789101112131415161718192021222324252627282930313233343536373839404142``` bashpackage com.leezp.spring.beans.collections;import java.util.Map;import com.leezp.spring.beans.Car;public class NewPerson &#123; private String name; private int age; private Map&lt;String,Car&gt; cars; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Map&lt;String, Car&gt; getCars() &#123; return cars; &#125; public void setCars(Map&lt;String, Car&gt; cars) &#123; this.cars = cars; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, cars=&quot; + cars + &quot;]&quot;; &#125;&#125;``` 修改applicationContext.xml配置文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.leezp.spring.beans.HelloWorld&quot;&gt;&lt;!-- 反射 --&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;100000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Baoma&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;int&quot;&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car2&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;car&quot;&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;constructor-arg value=&quot;Jerry&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;25&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name=&quot;car.price&quot; value=&quot;300000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id=&quot;person3&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lee&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Map属性值 --&gt; &lt;bean id=&quot;newPerson&quot; class=&quot;com.leezp.spring.beans.collections.NewPerson&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Candy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用map节点及map的entry子节点配置Map类型的成员变量 --&gt; &lt;map&gt; &lt;entry key=&quot;AA&quot; value-ref=&quot;car&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;BB&quot; value-ref=&quot;car2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。1234567891011121314151617181920``` bashpackage com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); Person p = (Person) ctx.getBean(&quot;person3&quot;); System.out.println(p); NewPerson p2 = (NewPerson) ctx.getBean(&quot;newPerson&quot;); System.out.println(p2); &#125;&#125;``` 在控制台观察运行结果。12345``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]Person [name=Candy, age=20, cars=&#123;AA=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], BB=Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]&#125;] 获取源代码配置Properties属性值。 在com.leezp.spring.beans.collections包下新建一个类 DataSource.java。 123456789101112131415161718192021package com.leezp.spring.beans.collections;import java.util.Properties;public class DataSource &#123; private Properties properties; @Override public String toString() &#123; return "DataSource [properties=" + properties + "]"; &#125; public Properties getProperties() &#123; return properties; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125;&#125;``` 修改applicationContext.xml配置文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.leezp.spring.beans.HelloWorld&quot;&gt;&lt;!-- 反射 --&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;100000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Baoma&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;int&quot;&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car2&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;car&quot;&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;constructor-arg value=&quot;Jerry&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;25&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name=&quot;car.price&quot; value=&quot;300000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id=&quot;person3&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lee&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Map属性值 --&gt; &lt;bean id=&quot;newPerson&quot; class=&quot;com.leezp.spring.beans.collections.NewPerson&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Candy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用map节点及map的entry子节点配置Map类型的成员变量 --&gt; &lt;map&gt; &lt;entry key=&quot;AA&quot; value-ref=&quot;car&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;BB&quot; value-ref=&quot;car2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Properties属性值 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.leezp.spring.beans.collections.DataSource&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!-- 使用props和prop子节点来为Properties属性赋值 --&gt; &lt;props&gt; &lt;prop key=&quot;user&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/prop&gt; &lt;prop key=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。1234567891011121314151617181920212223``` bashpackage com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); Person p = (Person) ctx.getBean(&quot;person3&quot;); System.out.println(p); NewPerson p2 = (NewPerson) ctx.getBean(&quot;newPerson&quot;); System.out.println(p2); DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125;``` 在控制台观察运行结果。123456``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]Person [name=Candy, age=20, cars=&#123;AA=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], BB=Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]&#125;]DataSource [properties=&#123;driverClass=com.mysql.jdbc.Driver, user=root, password=root, jdbcUrl=jdbc:mysql:///test&#125;] 使用 utility scheme定义集合使用基本的集合标签定义集合时，不能将集合作为独立的Bean定义，导致其他Bean无法引用该集合，所以无法在不同Bean之间共享集合。 可以使用 util schema里的集合标签定义独立的集合Bean。需要注意的是，必须在根元素里添加util schema定义。 先开启Spring配置文件中的util标签：打开applicationContext.xml 配置文件。点击下面的Namespaces，在弹出的复选框中将util复选框勾选。 修改applicationContext.xml配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id="helloWorld" class="com.leezp.spring.beans.HelloWorld"&gt;&lt;!-- 反射 --&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id="car" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Audi" index="0"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="ShangHai" index="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="100000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id="car2" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Baoma" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="int"&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="person" class="com.leezp.spring.beans.Person"&gt; &lt;property name="name" value="Tom"&gt;&lt;/property&gt; &lt;property name="age" value="24"&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name="car" ref="car2"&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name="car"&gt; &lt;ref bean="car2" /&gt; &lt;/property&gt; --&gt; &lt;property name="car"&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="Changan"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name="car.maxSpeed" value="260"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="person2" class="com.leezp.spring.beans.Person"&gt; &lt;constructor-arg value="Jerry"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="25"&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name="car.price" value="300000"&gt;&lt;/property&gt; &lt;property name="car.maxSpeed" value="260"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id="person3" class="com.leezp.spring.beans.collections.Person"&gt; &lt;property name="name" value="lee"&gt;&lt;/property&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;property name="cars"&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean="car" /&gt; &lt;ref bean="car2" /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="Changan"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Map属性值 --&gt; &lt;bean id="newPerson" class="com.leezp.spring.beans.collections.NewPerson"&gt; &lt;property name="name" value="Candy"&gt;&lt;/property&gt; &lt;property name="age" value="20"&gt;&lt;/property&gt; &lt;property name="cars"&gt; &lt;!-- 使用map节点及map的entry子节点配置Map类型的成员变量 --&gt; &lt;map&gt; &lt;entry key="AA" value-ref="car"&gt;&lt;/entry&gt; &lt;entry key="BB" value-ref="car2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Properties属性值 --&gt; &lt;bean id="dataSource" class="com.leezp.spring.beans.collections.DataSource"&gt; &lt;property name="properties"&gt; &lt;!-- 使用props和prop子节点来为Properties属性赋值 --&gt; &lt;props&gt; &lt;prop key="user"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;root&lt;/prop&gt; &lt;prop key="jdbcUrl"&gt;jdbc:mysql:///test&lt;/prop&gt; &lt;prop key="driverClass"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置独立的集合Bean，以供多个bean进行引用 ,需要导入util命名空间 --&gt; &lt;util:list id="cars"&gt; &lt;ref bean="car" /&gt; &lt;ref bean="car2" /&gt; &lt;/util:list&gt; &lt;bean id="person4" class="com.leezp.spring.beans.collections.Person"&gt; &lt;property name="name" value="Jack"&gt;&lt;/property&gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &lt;!-- 引用配置的独立的集合Bean --&gt; &lt;property name="cars" ref="cars"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 修改Main.java。 12345678910111213141516171819202122232425package com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml"); Person p = (Person) ctx.getBean("person3"); System.out.println(p); NewPerson p2 = (NewPerson) ctx.getBean("newPerson"); System.out.println(p2); DataSource dataSource = (DataSource) ctx.getBean("dataSource"); System.out.println(dataSource); Person p4 = (Person) ctx.getBean("person4"); System.out.println(p4); &#125;&#125;``` 在控制台观察运行结果。12345678``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]Person [name=Candy, age=20, cars=&#123;AA=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], BB=Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]&#125;]DataSource [properties=&#123;driverClass=com.mysql.jdbc.Driver, user=root, password=root, jdbcUrl=jdbc:mysql:///test&#125;]Person [name=Jack, age=21, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]]]``` 使用 p 命名空间为了简化XML文件的配置，越来越多的XML文件采用属性而非子元素配置信息。 Spring 从2.5版本开始引入了一个新的 p 命名空间，可以通过元素属性的方式配置Bean的属性。 使用p命名空间后，基于XML的配置方式将进一步简化。 修改applicationContext.xml配置文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.leezp.spring.beans.HelloWorld&quot;&gt;&lt;!-- 反射 --&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;100000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Baoma&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;int&quot;&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car2&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;car&quot;&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;constructor-arg value=&quot;Jerry&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;25&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name=&quot;car.price&quot; value=&quot;300000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id=&quot;person3&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lee&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Map属性值 --&gt; &lt;bean id=&quot;newPerson&quot; class=&quot;com.leezp.spring.beans.collections.NewPerson&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Candy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用map节点及map的entry子节点配置Map类型的成员变量 --&gt; &lt;map&gt; &lt;entry key=&quot;AA&quot; value-ref=&quot;car&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;BB&quot; value-ref=&quot;car2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Properties属性值 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.leezp.spring.beans.collections.DataSource&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!-- 使用props和prop子节点来为Properties属性赋值 --&gt; &lt;props&gt; &lt;prop key=&quot;user&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/prop&gt; &lt;prop key=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置独立的集合Bean，以供多个bean进行引用 ,需要导入util命名空间 --&gt; &lt;util:list id=&quot;cars&quot;&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/util:list&gt; &lt;bean id=&quot;person4&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Jack&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;!-- 引用配置的独立的集合Bean --&gt; &lt;property name=&quot;cars&quot; ref=&quot;cars&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过p命名空间为bean的属性赋值，需要先导入p命名空间 ,相对于之前方式更简洁一些 --&gt; &lt;bean id=&quot;person5&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot; p:name=&quot;Ming&quot; p:age=&quot;22&quot; p:cars-ref=&quot;cars&quot;&gt; &lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。1234567891011121314151617181920212223242526272829``` bashpackage com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); Person p = (Person) ctx.getBean(&quot;person3&quot;); System.out.println(p); NewPerson p2 = (NewPerson) ctx.getBean(&quot;newPerson&quot;); System.out.println(p2); DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;); System.out.println(dataSource); Person p4 = (Person) ctx.getBean(&quot;person4&quot;); System.out.println(p4); Person p5 = (Person) ctx.getBean(&quot;person5&quot;); System.out.println(p5); &#125;&#125;``` 在控制台观察运行结果。123456789``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]Person [name=Candy, age=20, cars=&#123;AA=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], BB=Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]&#125;]DataSource [properties=&#123;driverClass=com.mysql.jdbc.Driver, user=root, password=root, jdbcUrl=jdbc:mysql:///test&#125;]Person [name=Jack, age=21, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]]]Person [name=Ming, age=22, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]]]``` 获取源代码 自动装配XML配置里的Bean自动装配SpringIOC容器可以自动装配Bean。需要做的仅仅是在的autowire属性里指定自动装配的模式。 byType(根据类型自动装配)：若IOC容器中有多个与目标Bean类型一致的Bean,在这种情况下，Spring将无法判定哪个Bean最合适该属性，所以不能执行自动装配。 byName(根据名称自动装配)：必须将目标Bean的名称和属性名设置的完全相同。 constructor（通过构造器自动装配）：当Bean中存在多个构造器时，此种自动装配方式将会很复杂。不推荐使用。 新建一个包com.leezp.spring.beans.autowire。 在该包下新建Address.java。123456789101112131415161718192021222324252627282930``` bashpackage com.leezp.spring.beans.autowire;public class Address &#123; private String city; private String street; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getStreet() &#123; return street; &#125; public void setStreet(String street) &#123; this.street = street; &#125; @Override public String toString() &#123; return &quot;Address [city=&quot; + city + &quot;, street=&quot; + street + &quot;]&quot;; &#125;&#125;``` 在该包下新建Car.java。1234567891011121314151617181920212223242526272829``` bashpackage com.leezp.spring.beans.autowire;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;; &#125;&#125; 在该包下新建Person.java。 123456789101112131415161718192021222324252627282930313233343536373839package com.leezp.spring.beans.autowire;public class Person &#123; private String name; private Address address; private Car car; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", address=" + address + ", car=" + car + "]"; &#125;&#125; 在src下新建一个Spring的配置文件beans-autowire.xml。 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="address" class="com.leezp.spring.beans.autowire.Address" p:city="NanJing" p:street="ShangHaiLu"&gt; &lt;/bean&gt; &lt;!-- &lt;bean id="address2" class="com.leezp.spring.beans.autowire.Address" p:city="NanJing" p:street="ShangHaiLu"&gt; &lt;/bean&gt; --&gt; &lt;bean id="car2" class="com.leezp.spring.beans.autowire.Car" p:brand="BMW" p:price="300000"&gt;&lt;/bean&gt; &lt;!-- 手动转配 --&gt; &lt;!-- &lt;bean id="person" class="com.leezp.spring.beans.autowire.Person" p:name="Tom" p:address-ref="address" p:car-ref="car"&gt;&lt;/bean&gt; --&gt; &lt;!-- 可以使用autowire属性指定自动装配的方式，byName根据bean的名字和当前bean的 setter风格的属性名进行自动装配， 若有匹配的，则进行自动装配；若没有匹配的，则不装配。 --&gt; &lt;!-- &lt;bean id="person" class="com.leezp.spring.beans.autowire.Person" p:name="Tom" autowire="byName"&gt;&lt;/bean&gt; --&gt; &lt;!-- byType根据bean的类型和当前bean的属性的类型进行自动装配。若IOC容器中有一个以上的类型匹配的Bean,则抛异常。 --&gt; &lt;bean id="person" class="com.leezp.spring.beans.autowire.Person" p:name="Tom" autowire="byType"&gt;&lt;/bean&gt;&lt;/beans&gt;``` 在该包下新建一个Main.java。1234567891011121314151617``` bashpackage com.leezp.spring.beans.autowire;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-autowire.xml&quot;); Person p = (Person) ctx.getBean(&quot;person&quot;); System.out.println(p); &#125;&#125;``` 在控制台观察运行结果。123``` bashPerson [name=Tom, address=Address [city=NanJing, street=ShangHaiLu], car=Car [brand=BMW, price=300000.0]]``` 获取源代码 XML配置里的Bean自动装配的缺点在Bean配置文件里设置autowire属性进行自动装配将会装配Bean的所有属性。然而，若只希望装配个别属性时，autowire属性就不够灵活了。 autowire属性要么根据类型自动匹配，要么根据名称自动装配，不能两者兼而有之。 一般情况下，在实际的项目中很少使用自动装配功能，因为和自动装配功能所带来的好处比起来，明确清晰的配置文档更有说服力一些。 在整合第三方框架的时候，使用autowire的确给我们带来一些方便。 bean之间的关系继承；依赖。 继承Bean配置Spring允许继承Bean的配置，被继承的Bean称为父Bean,继承这个父Bean的Bean称为子Bean。 子Bean从父Bean中继承配置，包括Bean的属性配置。 子Bean也可以覆盖从父Bean继承过来的配置。 新建一个包com.leezp.spring.beans.relation。 在src下新建一个Spring的配置文件beans-relation.xml。1234567891011121314151617``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:city=&quot;NanJing&quot; p:street=&quot;ShangHaiLu&quot;&gt;&lt;/bean&gt; &lt;!-- &lt;bean id=&quot;address2&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:city=&quot;NanJing&quot; p:street=&quot;XiAnLu&quot;&gt;&lt;/bean&gt; --&gt; &lt;!-- bean配置的继承：使用bean的parent属性指定继承哪个bean的配置 --&gt; &lt;bean id=&quot;address2&quot; p:street=&quot;XiAnLu&quot; parent=&quot;address&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;``` 在该包下新建Main.java。12345678910111213141516171819202122``` bashpackage com.leezp.spring.beans.relation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.autowire.Address;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-relation.xml&quot;); Address address = (Address) ctx.getBean(&quot;address&quot;); System.out.println(address); Address address2 = (Address) ctx.getBean(&quot;address2&quot;); System.out.println(address2); &#125;&#125;``` 在控制台观察运行结果。1234``` bashAddress [city=NanJing, street=ShangHaiLu]Address [city=NanJing, street=XiAnLu]``` 父Bean可以作为配置模板，也可以作为bean实例，若只想把父bean作为模板，可以设置的abstract属性为true，这样Spring将不会实例化这个Bean（用IOC实例化它会报错）。 并不是元素里的所有属性都会被继承，比如：autowire,abstract等。 也可以忽略父bean的class属性，让子bean指定自己的类，而共享相同的属性配置。但此时abstract必须设置为true（若某一个bean的class属性没有指定，则该bean必须是一个抽象bean，否则报错）。 修改beans-relation.xml配置文件。1234567891011121314151617181920212223``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 抽象bean:bean的abstract属性为true的bean。这样的Bean不能被IOC容器实例化，只用来被继承配置 --&gt; &lt;!-- 若某一个bean的class属性没有指定，则该bean必须是一个抽象bean --&gt; &lt;bean id=&quot;address&quot; p:city=&quot;NanJing&quot; p:street=&quot;ShangHaiLu&quot; abstract=&quot;true&quot;&gt;&lt;/bean&gt; &lt;!-- &lt;bean id=&quot;address2&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:city=&quot;NanJing&quot; p:street=&quot;XiAnLu&quot;&gt;&lt;/bean&gt; --&gt; &lt;!-- bean配置的继承：使用bean的parent属性指定继承哪个bean的配置 --&gt; &lt;bean id=&quot;address2&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:street=&quot;XiAnLu&quot; parent=&quot;address&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;address3&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:street=&quot;DaLianLu&quot; parent=&quot;address2&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。1234567891011121314151617181920212223242526272829``` bashpackage com.leezp.spring.beans.relation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.autowire.Address;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-relation.xml&quot;); // 注意抽象Bean不能被创建。否则报错： // Error creating bean with name &apos;address&apos;: Bean definition is abstract /* * Address address = (Address) ctx.getBean(&quot;address&quot;); * System.out.println(address); */ Address address2 = (Address) ctx.getBean(&quot;address2&quot;); System.out.println(address2); Address address3 = (Address) ctx.getBean(&quot;address3&quot;); System.out.println(address3); &#125;&#125;``` 在控制台观察运行结果。1234``` bashAddress [city=NanJing, street=XiAnLu]Address [city=NanJing, street=DaLianLu]``` 依赖Bean配置Spring允许用户通过depends-on属性设定Bean前置依赖的Bean,前置依赖的Bean会在本Bean实例化之前创建好。 如果前置依赖于多个Bean，则可以通过逗号或空格的方式配置Bean的名称。 使用场景：当bean与bean直接 初始化 有先后顺序时，就需要指定他们直接的依赖关系，可以使用depends-on属性。 修改Car.java。123456789101112131415161718192021222324252627282930313233``` bashpackage com.leezp.spring.beans.autowire;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;; &#125; public Car() &#123; System.out.println(&quot;Car被初始化&quot;); &#125;&#125; 修改beans-relation.xml配置文件。 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 抽象bean:bean的abstract属性为true的bean。这样的Bean不能被IOC容器实例化，只用来被继承配置 --&gt; &lt;!-- 若某一个bean的class属性没有指定，则该bean必须是一个抽象bean --&gt; &lt;bean id="address" p:city="NanJing" p:street="ShangHaiLu" abstract="true"&gt;&lt;/bean&gt; &lt;!-- &lt;bean id="address2" class="com.leezp.spring.beans.autowire.Address" p:city="NanJing" p:street="XiAnLu"&gt;&lt;/bean&gt; --&gt; &lt;!-- bean配置的继承：使用bean的parent属性指定继承哪个bean的配置 --&gt; &lt;bean id="address2" class="com.leezp.spring.beans.autowire.Address" p:street="XiAnLu" parent="address"&gt;&lt;/bean&gt; &lt;bean id="address3" class="com.leezp.spring.beans.autowire.Address" p:street="DaLianLu" parent="address2"&gt;&lt;/bean&gt; &lt;bean id="car" class="com.leezp.spring.beans.autowire.Car" p:brand="Audi" p:price="300000"&gt;&lt;/bean&gt; &lt;!-- 要求在配置Person时，必须有一个关联的car！换句话说person这个bean依赖于Car这个bean --&gt; &lt;bean id="person" class="com.leezp.spring.beans.autowire.Person" p:name="Tom" p:address-ref="address2" depends-on="car"&gt;&lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。123456789101112131415161718192021222324252627282930313233``` bashpackage com.leezp.spring.beans.relation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.autowire.Address;import com.leezp.spring.beans.autowire.Car;import com.leezp.spring.beans.autowire.Person;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-relation.xml&quot;); // 注意抽象Bean不能被创建。否则报错： // Error creating bean with name &apos;address&apos;: Bean definition is abstract /* * Address address = (Address) ctx.getBean(&quot;address&quot;); * System.out.println(address); */ Address address2 = (Address) ctx.getBean(&quot;address2&quot;); System.out.println(address2); Address address3 = (Address) ctx.getBean(&quot;address3&quot;); System.out.println(address3); Person person = (Person) ctx.getBean(&quot;person&quot;); System.out.println(person); &#125;&#125;``` 在控制台观察运行结果。12345``` bashCar被初始化Address [city=NanJing, street=XiAnLu]Address [city=NanJing, street=DaLianLu]Person [name=Tom, address=Address [city=NanJing, street=XiAnLu], car=null] 获取源代码 bean的作用域singleton ; prototype ； WEB 环境作用域 singleton:默认值。容器初始化时创建bean实例，在整个容器的生命周期内只创建这一个bean。单例的。 创建Spring配置文件beans-scope.xml。 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 使用bean的scope属性来配置bean的作用域 。 singleton:默认值。**容器初始化时**创建bean实例，在整个容器的生命周期内只创建这一个bean。单例的。 --&gt; &lt;bean id="car" class="com.leezp.spring.beans.autowire.Car" scope="prototype"&gt; &lt;property name="brand" value="Audi"&gt;&lt;/property&gt; &lt;property name="price" value="200000"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 修改包com.leezp.spring.beans.autowire下的Car.java。12345678910111213141516171819202122232425262728293031323334``` bashpackage com.leezp.spring.beans.autowire;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;; &#125; public Car() &#123; System.out.println(&quot;Car被初始化&quot;); &#125;&#125;``` 创建包com.leezp.spring.beans.scope。 在包下创建Main.java。12345678910111213141516171819``` bashpackage com.leezp.spring.beans.scope;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.autowire.Car;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-scope.xml&quot;); Car car = (Car) ctx.getBean(&quot;car&quot;); Car car2 = (Car) ctx.getBean(&quot;car&quot;); System.out.println(car == car2); &#125;&#125;``` 在控制台观察运行结果。12345``` bashCar被初始化Car被初始化false``` 使用外部属性文件在配置文件里配置Bean时，有时需要在Bean的配置里混入系统部署的细节信息（例如：文件路径，数据源配置信息等），而这些部署细节实际上需要和Bean配置相分离。 Spring提供了一个PropertyPlaceholderConfigurer的BeanFactory后置处理器，这个处理器允许用户将Bean配置的部分内容外移到属性文件中。可以在Bean配置文件里使用形式为${var}的变量，PropertyPlaceholderConfigurer从属性文件里加载属性，并使用这些属性来替换变量。 Spring还允许在属性文件中使用${propName}，以实现属性之间的相互引用。 注册PropertyPlaceholderConfigurer。Spring2.0：1234``` bash&lt;!-- &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:db.properties&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt;``` Spring2.5：123``` bash&lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;``` 新建beans-properties.xml配置文件。12345678910111213141516171819202122232425262728293031``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- Spring2.0 --&gt; &lt;!-- &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:db.properties&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- Spring2.5以后：可通过&lt;context:property-placeholder元素简化，导入属性文件 --&gt; &lt;!-- &lt;bean&gt;中添加context Schema定义 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 使用外部属性文件的属性 --&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbcUrl&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 新建db.properties属性文件。123456``` bashuser=rootpassword=rootdriverClass=com.mysql.jdbc.DriverjdbcUrl=jdbc:mysql://localhost:3306/test``` 新建包com.leezp.spring.beans.properties。在该包下新建Main.java。1234567891011121314151617181920``` bashpackage com.leezp.spring.beans.properties;import java.sql.SQLException;import javax.sql.DataSource;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) throws SQLException &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-properties.xml&quot;); DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;); System.out.println(dataSource.getConnection()); &#125;&#125;``` 在控制台观察运行结果。123``` bashcom.mchange.v2.c3p0.impl.NewProxyConnection@170ed6ab``` 获取源代码 spELSpring表达式或语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于EL:SpEL使用#{…}作为界定符，所有在大括号中的字符都将被认为是SpEL。 SpEL为bean的属性进行动态赋值提供了便利。 通过SpEL可以实现：1.通过bean的id对bean进行引用。2.调用方法以及引用对象中的属性。3.计算表达式的值。4.正则表达式的匹配。 SpEL：字面量字面量的表示：1.整数：&lt;property name=”count” value=”#{5}”/&gt;2.小数：&lt;property name=”frequency” value=”#{20.1}”/&gt;3.科学计数法：&lt;property name=”capacity” value=”#{1e3}”/&gt;4.String可以使用单引号或者双引号作为字符串的界定符号：&lt;property name=”name” value=”#{‘lee’}“/&gt; 或 &lt;property name=”name” value=’#{“lee”}‘/&gt;5.Boolean:&lt;property name=”enabled” value=”#{false}”/&gt; 仅仅赋字面值用SpEL的意义不大。重要作用是后面的操作。 SpEL：引用Bean、属性和方法引用其他对象 1.&lt;!–通过value属性和SpEL配置Bean之间的应用关系–&gt;&lt;property name=”prefix” value=”#{prefixGenerator}”&gt;&lt;/property&gt; 2.引用其他对象的属性&lt;!–通过value属性和SpEL配置 suffix属性值为另一个Bean的suffix–&gt;&lt;property name=”suffix” value=”#{sequenceGenerator2.suffix}”/&gt; 3.调用其他方法，还可以链式操作 &lt;!–通过value属性和SpEL配置 suffix属性值为另一个Bean的方法的返回值–&gt;&lt;property name=”suffix” value=”#{sequenceGenerator2.toString()}”/&gt; &lt;!–方法的连缀–&gt;&lt;property name=”suffix” value=”{sequenceGenerator2.toString().toUpperCase()}”/&gt; 4.调用静态方法或静态属性 通过T()调用一个类的静态方法，它将返回一个Class Object，然后再调用相应的方法或属性：&lt;property name=”initValue” value=”#{T(java.lang.Math).PI}”/&gt; 新建一个包com.leezp.spring.beans.spel。 在该包下新建Address.java。123456789101112131415161718192021222324252627282930``` bashpackage com.leezp.spring.beans.spel;public class Address &#123; private String city; private String street; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getStreet() &#123; return street; &#125; public void setStreet(String street) &#123; this.street = street; &#125; @Override public String toString() &#123; return &quot;Address [city=&quot; + city + &quot;, street=&quot; + street + &quot;]&quot;; &#125;&#125;``` 在该包下新建Car.java。123456789101112131415161718192021222324252627282930313233343536373839404142434445``` bashpackage com.leezp.spring.beans.spel;public class Car &#123; private String brand; private double price; // 轮胎周长 private double tyrePerimeter; public double getTyrePerimeter() &#123; return tyrePerimeter; &#125; public void setTyrePerimeter(double tyrePerimeter) &#123; this.tyrePerimeter = tyrePerimeter; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;, typePerimeter=&quot; + tyrePerimeter + &quot;]&quot;; &#125; public Car() &#123; // System.out.println(&quot;Car被初始化&quot;); &#125;&#125; 在该包下新建Person.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.leezp.spring.beans.spel;public class Person &#123; private String name; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; //引用 address bean的city属性 private String city; //根据car的price确定info:car的price&gt;=300000:金领；否则：白领 private String info; private Car car; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", city=" + city + ", info=" + info + ", car=" + car + "]"; &#125;&#125; 新建beans-spel.xml配置文件。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="address" class="com.leezp.spring.beans.spel.Address"&gt; &lt;!-- 使用SpEL为属性赋一个字面值 --&gt; &lt;property name="city" value="#&#123;'ChengDu'&#125;"&gt;&lt;/property&gt; &lt;property name="street" value="#&#123;'YuLinLu'&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="car" class="com.leezp.spring.beans.spel.Car"&gt; &lt;property name="brand" value="Audi"&gt;&lt;/property&gt; &lt;property name="price" value="400000"&gt;&lt;/property&gt; &lt;!-- 使用SpEL引用类的静态属性 --&gt; &lt;property name="tyrePerimeter" value="#&#123;T(java.lang.Math).PI*2*30&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="person" class="com.leezp.spring.beans.spel.Person"&gt; &lt;!-- 使用SpEL来引用其他的Bean --&gt; &lt;property name="car" value="#&#123;car&#125;"&gt;&lt;/property&gt; &lt;!-- 使用SpEL来引用其他的Bean属性 --&gt; &lt;property name="city" value="#&#123;address.city&#125;"&gt;&lt;/property&gt; &lt;property name="info" value="#&#123;address.street&#125;"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 新建Main.java。12345678910111213141516171819202122``` bashpackage com.leezp.spring.beans.spel;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-spel.xml&quot;); Address a = (Address) ctx.getBean(&quot;address&quot;); System.out.println(a); Car car = (Car) ctx.getBean(&quot;car&quot;); System.out.println(car); Person p = (Person) ctx.getBean(&quot;person&quot;); System.out.println(p); &#125;&#125;``` 在控制台观察运行结果。12345``` bashAddress [city=ChengDu, street=YuLinLu]Car [brand=Audi, price=400000.0, typePerimeter=188.49555921538757]Person [name=null, city=ChengDu, info=YuLinLu, car=Car [brand=Audi, price=400000.0, typePerimeter=188.49555921538757]]``` 获取源代码 SpEL支持的运算符号1.算数运算符：+,-,*,/,%,^12345678``` bash&lt;property name=&quot;addition&quot; value=&quot;#&#123;counter.total+1&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;subtraction&quot; value=&quot;#&#123;counter.total-1&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;perimeter&quot; value=&quot;#&#123;2*T(java.lang.Math).PI*circle.radius&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;average&quot; value=&quot;#&#123;counter.total/counter.count&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;remainder&quot; value=&quot;#&#123;counter.total%counter.count&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;area&quot; value=&quot;#&#123;T(java.lang.Math).PI*circle.radius^2&#125;&quot;&gt;&lt;/property&gt;``` 2.加号还可以用作字符串连接：&lt;constructor-arg value=”#{performer.firstName+’’+performer.lastName}”/&gt; 3.比较运算符：&lt;,&gt;,==,&lt;=,&gt;=,lt,gt,eq,le,ge&lt;property name=”equal” value=”#{counter.total==100}”/&gt;&lt;property name=”hasCapacity” value=”#{counter.total le 10000}”/&gt; 4.逻辑运算符号 and,or,not,!&lt;property name=”largeCircle” value=”#{shape.kind==’circle’ and shape.perimeter gr&lt;10000}”/&gt;&lt;property name=”ww” value=”#{!product.available}”/&gt;&lt;property name=”zz” value=”#{not product.available}”/&gt; 5.if-else运算符（三目运算符） ?: 6.if-else的变体&lt;constructor-arg value=”#{lee.song} ?: ‘ChunHua’}”/&gt; 7.正则表达式：matches&lt;constructor-arg value=”#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}’}”/&gt; IOC容器中Bean的生命周期SpringIOC容器可以管理Bean的生命周期，Spring允许在Bean生命周期的特定点执行定制的任务。 SpringIOC容器对Bean的生命周期进行管理的过程：1.通过构造器或工厂方法创建Bean实例2.为Bean的属性设置值和对其他Bean的引用3.调用Bean的初始化方法4.Bean可以使用了5.当容器关闭时，调用Bean的销毁方法 在Bean的声明里设置init-method和destroy-method属性，为Bean指定初始化和销毁方法。 在src下创建包com.leezp.spring.beans.cycle。 在该包下创建Car.java。12345678910111213141516171819202122232425``` bashpackage com.leezp.spring.beans.cycle;public class Car &#123; public Car() &#123; System.out.println(&quot;Car&apos;s Constructor...&quot;); &#125; private String brand; public void setBrand(String brand) &#123; System.out.println(&quot;setBrand...&quot;); this.brand = brand; &#125; public void init() &#123; System.out.println(&quot;init...&quot;); &#125; public void destroy() &#123; System.out.println(&quot;destroy...&quot;); &#125;&#125;``` 创建beans-cycle.xml配置文件。12345678910111213``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.cycle.Car&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt; &lt;property name=&quot;brand&quot; value=&quot;Audi&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 创建Main.java。12345678910111213141516171819``` bashpackage com.leezp.spring.beans.cycle;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-cycle.xml&quot;); Car car = (Car) ctx.getBean(&quot;car&quot;); System.out.println(car); ctx.destroy(); &#125;&#125;``` 在控制台观察运行结果。1234567``` bashCar&apos;s Constructor...setBrand...init...com.leezp.spring.beans.cycle.Car@22967f8edestroy...``` 创建Bean后置处理器Bean后置处理器允许在调用初始化方法前后对Bean进行额外的处理 Bean后置处理器对IOC容器里的所有Bean实例逐一处理，而非单一实例，其典型应用是：检查Bean属性的正确性或根据特定的标准更改Bean的属性。 对Bean后置处理器而言，需要实现Interface BeanPostProcessor接口。在初始化方法被调用前后，Spring将把每个Bean实例分别传递给上述接口的以下两个方法：postProcessBeforeInitialization和postProcessAfterInitialization。 添加Bean后置处理器后Bean的生命周期SpringIOC容器对Bean的生命周期进行管理的过程：1.通过构造器或工厂方法创建Bean实例2.为Bean的属性设置值和对其他Bean的引用3.将Bean实例传递给Bean后置处理器的postProcessBeforeInitialization方法4.调用Bean的初始化方法5.将Bean实例传递给Bean后置处理器的PostProcessAfterInitialization方法6.Bean可以使用了7.当容器关闭时，调用Bean的销毁方法 修改Car.java。1234567891011121314151617181920212223242526272829``` bashpackage com.leezp.spring.beans.cycle;public class Car &#123; public Car() &#123; System.out.println(&quot;Car&apos;s Constructor...&quot;); &#125; private String brand; public void setBrand(String brand) &#123; System.out.println(&quot;setBrand...&quot;); this.brand = brand; &#125; public void init() &#123; System.out.println(&quot;init...&quot;); &#125; public void destroy() &#123; System.out.println(&quot;destroy...&quot;); &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;]&quot;; &#125;&#125; 新建MyBeanPostProcessor.java。 123456789101112131415161718192021222324252627282930package com.leezp.spring.beans.cycle;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessBeforeInitialization" + bean + "," + beanName); if ("car".equals(beanName)) &#123; //可以在这里过滤bean &#125; return bean; &#125; @Override public Object postProcessAfterInitialization(Object arg0, String arg1) throws BeansException &#123; System.out .println("postProcessAfterInitialization" + arg0 + "," + arg1); // 在这里可以对Bean进行额外的配置 Car car = new Car(); car.setBrand("Ford"); return car; &#125;&#125; 修改beans-cycle.xml配置文件。 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="car" class="com.leezp.spring.beans.cycle.Car" init-method="init" destroy-method="destroy"&gt; &lt;property name="brand" value="Audi"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 实现BeanPostProcessor接口，并具体提供两个方法的实现 --&gt; &lt;!-- 配置Bean的后置处理器 --&gt; &lt;bean class="com.leezp.spring.beans.cycle.MyBeanPostProcessor"&gt;&lt;/bean&gt; &lt;/beans&gt; 在控制台观察运行结果。 Car's Constructor... setBrand... postProcessBeforeInitializationCar [brand=Audi],car init... postProcessAfterInitializationCar [brand=Audi],car Car's Constructor... setBrand... Car [brand=Ford] destroy... 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0]]></title>
      <url>%2Fblog%2F2016%2F07%2F30%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%2F</url>
      <content type="text"><![CDATA[从今天起，准备陆续更新Spring4.0的博客，当做自己知识的巩固。 前言Spring 官网 开发工具：推荐使用Eclipse，我用的是Eclipse 4.3(KEPLER) 64bit 版本。 插件：springsource-tool-suite-3.4.0.RELEASE-e4.3.1-updatesite 注意要安装和自己Eclipse版本相对应的插件。 Spring4.0 jar包：spring-framework-4.0.4.RELEASE.rar,下载后解压使用。 正文Spring 简介Spring 是一个开源框架。也是一个 IOC (DI) 和 AOP 容器框架。IOC(反转控制)，DI（依赖注入）。 Spring 是轻量级，非侵入性的（使用Spring的时候不需要实现Spring提供的接口，也不需要继承它的任何父类，可以使用它提供的功能）。Spring 是一个容器，因为它包含并且管理应用对象的生命周期。 核心：1.依赖注入2.面向切面编程AOP Spring 模块：最底层：Beans,Core,Context,SpringEL IOC(Inversion of Control)：其思想是反转资源获取的方向。传统的资源查找要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了IOC之后，则是容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源。这种行为也被称为查找的被动形式。 DI(Dependency Injection)：IOC的另一种表述方式：即组件以一种预先定义好的方式（例如：setter方法）接受来自如容器的资源的注入。相对于IOC而言，这种表述更直接。 Spring4.0 简介Spring4.0是 Spring 推出的一个重大版本升级，进一步加强了 Spring 作为 Java 领域第一开源平台的地位。Spring4.0 引入了众多 Java 开发者期盼的新特性，如泛型依赖注入、SpEL、校验及格式化框架、Rest风格的 WEB 编程模型等。这些新功能实用性强、易用性高，可大幅降低 JavaEE 开发的难度，同时有效提升应用开发的优雅性。 安装Spring Tool SuiteSpring Tool Suite 是一个Eclipse插件，利用该插件可以更方便的在Eclipse平台上开发基于Spring的应用。 打开Eclipse-&gt; Help-&gt; Install New Software…-&gt; Add-&gt; Archive…。选中刚刚下载的压缩文件，点击打开。在弹出的Available Software 窗口将4个带 Spring IDE的项勾选，将下面“联网进行更新”复选框去掉。点击下一步…保存更改。重启Eclipse,点击 Help-&gt; Welcome 打开欢迎页面，显示Spring IDE 图样即为安装成功。点击 Window-&gt; Preferences,如果看到 Spring,则证明插件已经安装成功。 搭建Spring开发环境在Eclipse新建一个项目，命名为spring-01，新建一个bin文件夹，将所需jar包复制到bin目录下。选中导入的jar，右击build path-&gt; Add to Build Path。 新建一个package，命名为 com.leezp.spring.beans，在该包下新建一个类HelloWorld。 1234567891011121314151617181920package com.leezp.spring.beans;public class HelloWorld &#123; private String name; public void setName(String name) &#123; System.out.println("setName:" + name); this.name = name; &#125; // setValue 这里的value和xml 配置文件里 的property 的name属性的值对应 public void hello() &#123; System.out.println("hello:" + name); &#125; public HelloWorld() &#123; System.out.println("HelloWorld's Constructor"); &#125;&#125; src下new-&gt; Spring Bean Configuration File，命名为applicationContext.xml。 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置bean --&gt; &lt;bean id="helloWorld" class="com.leezp.spring.beans.HelloWorld"&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 新建一个Main.java 1234567891011121314151617181920212223242526package com.leezp.spring.beans;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; /* * // 创建 HelloWorld 的一个对象 HelloWorld helloWorld = new HelloWorld(); * // 为name 属性赋值 helloWorld.setName("lee"); */ // 1. 创建Spring 的IOC 容器对象 // ApplicationContext代表IOC 容器 ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml");// 创建对象时即调用它的set方法对属性赋值 // 2. 从IOC容器中获取Bean实例 // HelloWorld helloWorld = (HelloWorld) ctx.getBean("helloWorld"); // HelloWorld helloWorld = ctx.getBean(HelloWorld.class);//这样做有缺点，配置多个 // bean的时候它不知道访问哪一个，只适用于单个bean // 调用hello方法 // helloWorld.hello(); &#125;&#125; 运行该文件，在控制台观察结果。 发现不需要在main里对 helloWorld 赋值，只需创建一个Spring的IOC容器对象，自动进行了赋值。 获取源代码 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建博客之进阶篇]]></title>
      <url>%2Fblog%2F2016%2F07%2F23%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
      <content type="text"><![CDATA[在上一节中，我们已经学会了对Hexo博客配置文件和Next主题配置文件进行配置以达到我们想要的效果。 在这一节中，将介绍一些Hexo博客的进阶设计，有了这些设计，博客看起来会美美哒。 前言之前的章节已经讲到如何搭建Hexo博客并选择自己喜欢的主题进行配置。那么如何添加自己喜欢的样式或效果来使自己的网站更加美观，在众多Hexo博客中脱颖而出呢？ 正文为Hexo博客添加一个主页跳转思路：可以直接把hexo部署到一个分支，比如blog，然后首页自己写个html（这里的首页不是hexo生成的），手动上传到master，在master下手动上传个CNAME绑定域名。 思维导图 总结Hexo博客可配置的地方还有很多，这里只是抛砖引玉。 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建博客之Next主题精析]]></title>
      <url>%2Fblog%2F2016%2F07%2F17%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BNext%E4%B8%BB%E9%A2%98%E7%B2%BE%E6%9E%90%2F</url>
      <content type="text"><![CDATA[在上一节中，我们已经学会了使用hexo搭建博客，并且可以使用hexo发布博文。 在这一节中，将介绍一些基于Next主题配置的实用功能，有了这些功能，博客看起来会更美观和充实。 准备配置Next主题 打开站点配置文件（这里要注意不是主题配置文件而是站点配置文件），将theme 后的主题改成你选择的主题，我的是Next。 正文下面开始配置主题配置文件_config.yml 配置网站的图标1favicon: /blog/images/favicon.ico 在favicon 后填写图标的路径 添加悬赏功能123reward_comment: 您的支持将鼓励我继续创作,我一直在期待那个最帅的人出现！wechatpay: /blog/images/wechat-image.pngalipay: /blog/images/alipay-image.png 配置主页显示的菜单可以根据自己喜好进行配置。 12345678menu: home: / categories: /categories about: /about archives: /archives tags: /tags #sitemap: /sitemap.xml #commonweal: /404.html 配置博客的字体12345678910111213141516171819202122232425262728293031323334353637font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: 配置代码高亮样式123# Available value:# normal | night | night eighties | night blue | night brighthighlight_theme: night eighties 添加百度统计注册并登陆百度统计。点击 管理-&gt;新增网站，添加自己网站的域名，添加成功以后点击获取代码，这里有两种情况。常规方法：在管理–&gt;获取代码-&gt;复制代码，复制到你的网站主页head标签内的script标签里。在Next主题中已经帮我们完成了这个步骤，只需要将你的Baidu Analytics ID 复制到主题配置文件中即可。 12# Baidu Analytics IDbaidu_analytics: 添加百度分享123456# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare: #type: slide 这里可以配置百度分享，但要注意百度分享会覆盖掉多说分享，所以如果你想使用多说分享，一定要把这段话注释掉。下面开始配置站点配置文件_config.yml。 多说和多说热评配置duoshuo_shortname为博客中显示的你的昵称。 12345# 多说shareduoshuo_shortname: leezpduoshuo_share: true# hot commentsduoshuo_hotartical: true 站点概览显示的栏目配置123456# Menu configurationmenu: home: / archives: /archives tags: /tags categories: /categories 社交媒体配置123456social: GitHub: https://github.com/leezp #Twitter: your-twitter-url Weibo: your-weibo-url DouBan: your-douban-url ZhiHu: your-zhihu-url 总结Hexo博客和Next主题可配置的地方还有很多，这里只是抛砖引玉。 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo从零开始搭建Blog]]></title>
      <url>%2Fblog%2F2016%2F07%2F16%2F%E4%BD%BF%E7%94%A8Hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BABlog%2F</url>
      <content type="text"><![CDATA[今天是农历6月13，对我来说是一个特别的日子。 我们来使用hexo生成静态博客并架设在免费的github page平台，看看会发生什么。 准备我的电脑系统是win7 64bit，node.js 版本 v4.4.4，本教程只针对windows用户。 正文安装git安装方法请自行百度 安装Node.js安装方法请自行百度 安装hexo安装前先介绍几个hexo常用的命令,#后面为注释。 1234$ hexo g #完整命令为hexo generate，用于生成静态文件$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上$ hexo n #完整命令为hexo new，用于新建一篇文章 在电脑里选择一个目录建立一个文件夹（例如D:\hexo），双击建好的文件夹进入文件夹，鼠标右键任意地方，选择Git Bash，使用以下命令安装hexo（ps：以下命令中的$符号只为了让教程和实际看起来一致，实际输入命令只需输入$ 后面的命令即可） 1$ npm install hexo-cli -g 验证软件是否正确安装 123$ git --version$ node -v$ npm -v hexo初始化 1$ hexo init 安装依赖包 1$ npm install 让我们看看刚刚下载的hexo文件带来了什么，在D:\hexo内执行以下命令， 12$ hexo g$ hexo s 然后用浏览器访问 http://localhost:4000/ ，此时，你应该看到了一个漂亮的博客了，当然这个博客只是在本地的，别人是看不到的，hexo3.0使用的默认主题是landscape。 注册Github帐号已经有Github帐号跳过此步，首先进入Github进行注册，用户名、邮箱和密码之后都需要用到，自己记好。 创建repositoryrepository相当于一个仓库，用来放置你的代码文件。首先，登陆进入Github，并进入个人页面，选择Repositories(下图第一个红圈的地方)，然后New一个repository(下图第二个红圈的地方) 创建时，只需要填写Repository name即可，当然这个名字的格式必须为youname.github.io，例如我的为leezp.github.io 部署本地文件到github既然Repository已经创建了，当然是先把博客放到Github上去看看效果。编辑E：\hexo下的_config.yml文件，建议使用Notepad++。在_config.yml最下方，添加如下配置(命令中的第一个leezp为Github的用户名,第二个leezp为之前New的Repository的名字,记得改成自己的。另外记得一点，hexo的配置文件中任何’:’后面都是带一个空格的),如果配置以下命令出现ERROR Deployer not found : github，则$ npm install hexo-deployer-git –save 在_config.yml最下方，添加如下配置1234deploy: type: git repository: http://github.com/leezp/leezp.github.io.git branch: master 配置好_config.yml并保存后，执行以下命令部署到Github上。如果你是第一次使用Github或者是已经使用过，但没有配置过SSH，则可能需要配置一下，具体方法史上最全github使用方法：github入门到精通里面有介绍到。 12$ hexo g$ hexo d 执行上面的第二个命令，可能会要你输入用户名和密码，皆为注册Github时的数据，输入密码是不显示任何东西的，输入完毕回车即可。此时，我们的博客已经搭建起来，并发布到Github上了，在浏览器访问leezp.github.io就能看到自己的博客了。第一次访问刚地址，可能访问不了，您可以在几分钟后进行访问，一般不超过10分钟。 hexo的配置文件hexo里面有两个常用到的配置文件，分别是整个博客的配置文件D:\hexo_config.yml和主题的配置文件D:\hexo\themes\next_config.yml,此地址是对于我来说，hexo3.0使用的默认主题是landscape，因此你们的地址应该是D:\hexo\themes\landscape_config.yml，下文所有讲到next的地方，你们将之换为自己的主题名即可。接下来介绍整个博客的配置文件。D:\hexo_config.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思title: leezp #博客名subtitle: #副标题description: #用于搜索，没有直观表现author: lee #作者language: zh-Hans #语言timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值# URL 暂不配置，使用默认值## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://leezp.space #域名root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 暂不配置，使用默认值source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局等，使用默认值new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true tab_replace:# Category &amp; Tag 暂不配置，使用默认值default_category: uncategorizedcategory_map:tag_map:# Date / Time format 时间格式，使用默认值## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章数，0表示不分页pagination_dir: page# Extensions 插件配置，暂时不配置## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/#plugins:#- hexo-generator-feedtheme: next #使用的主题，即：E:\myblog\themes文件夹下的主题文件夹名feed: #之后配置rss会用，使用如下配置即可 type: atom path: atom.xml limit: 20 # Deployment 用于部署到github，之前已经配置过## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: http://github.com/leezp/leezp.github.io.git branch: master 按照自己的意愿修改完后，执行hexo g，hexo s，打开localhost:4000看看效果。 发表一篇文章1.在Git Bash执行命令：$ hexo new “my new post”2.在D:\hexo\source_post中打开my-new-post.md，打开方式使用记事本或notepad++。hexo中写文章使用的是Markdown，没接触过的可以看下Markdown语法说明。1234567title: my new post #可以改成中文的，如“新文章”date: 2016-07-16 22:00:00 #发表日期，一般不改动categories: blog #文章文类tags: [博客，文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上&lt;!--more--&gt; #在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，你可以使用1.$ hexo g生成静态文件。2.$ hexo s在本地预览效果。3.hexo d同步到github，然后使用http://leezp.github.io进行访问。 另一种发布到github的配置现在提供另一种配置方式，这种方式在发布时不需要同时输入用户名和邮箱账号，也是我目前使用的方法，配置代码如下。 1234deploy: type: git repository: git@github.com:leezp/leezp.github.io.git branch: master 这种配置方式，需要配置SSH key，教程如下：鼠标右键任意地方，选择Git Bash， 1$ ssh-keygen -t rsa -C "your_email@youremail.com" 后面的your_email@youremail.com改为你的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在C:\Users\Administrator下生成.ssh文件夹，进入该文件夹，打开id_rsa.pub，复制里面的key。回到github，进入Settings，选择SSH and GPG Keys -&gt; New SSH Key，title随便填，粘贴key。为了验证是否成功，在git bash下输入： 1$ ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated， but GitHub does not provide shell access ，这就表示已成功连上github。接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。12$ git config --global user.name "your name" $ git config --global user.email "your_email@youremail.com" 总结到目前为止，实现了用hexo搭建博客的基本功能。由于本文是博主工作之余写的，比较仓促，难免有错误，欢迎指正。后面的文章将介绍本博客使用到的一些实用的功能，如访问次数，新浪微博秀，RSS，多说评论等，喜欢这些功能的朋友可以继续跟随。 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
  
  
</search>
