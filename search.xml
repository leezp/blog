<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[快速搭建php环境并使用phpstorm调试php代码]]></title>
      <url>%2Fblog%2F2017%2F01%2F11%2F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAphp%E7%8E%AF%E5%A2%83%E5%B9%B6%E4%BD%BF%E7%94%A8phpstorm%E8%B0%83%E8%AF%95php%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[教你从零基础升级成会完美调试php的大神！ 前言最近由于工作的关系调研一些php的webshell，为了更好的理解一些语句的作用，我想到了用调试来解决，但是搜索了全网也没有找到一份适合于新手、可配置性高、完整且实用的教程，于是决定自己写一份，正所谓“前人栽树，后人乘凉”。就当做给以后新手小白们的福利了。有过php调试经验的同学也可以看看我这份文档中所讲述的内容是否能使你的php代码调试、发布等等变得更加方便，我本人经过几天的认真研究总结出的这些方法的确使代码调试达到了eclipse、Visual Studio相当的十分流畅的用户体验，代码发布达到了eclipse相当的简洁高效的用户体验，总结起来就是用了科学的配置方法以后，感觉很爽。 准备操作系统：win7 64bitPhp版本是：5.6.27PhpStorm版本是：PhpStorm 10.0.1Apache版本：2.4.17我用的是Chrome浏览器，版本：55.0.2883.87 m 如果只发布项目不进行调试，使用phpStudy集成环境来发布php项目也是不错的选择，特别适合新手学习使用。 安装Php这里的Php相当于Php代码的编译环境。跟教程里的其他配置操作的难度相比，这部分可以忽略不计，对纯小白来说可能稍微有一点难度，请自行百度，安装好以后配置好环境变量。本教程将留更大篇幅给后面有难度的章节。 安装PhpStormPhpStorm是Php代码运行环境和调试工具。安装方法请自行百度。 安装Apache服务器Apache服务器是适合搭载Php项目的服务器，也是世界上使用最广泛的服务器。百度下载Apache服务器到本地文件夹。 安装XdebugXdebug是对Php代码进行调试所需要的插件。把它放置在php安装的文件夹下的ext文件夹里。我的Xdebug的安装路径为：D:\D\software\php\php-5.6.27-Win32-VC11-x64\ext。注意要安装与自己Php对应版本的Xdebug，我安装的php_xdebug-2.5.0-5.6-vc11-x86_64.dll，2.5.0是xdebug的版本，5.6是我本地安装的php的版本。如果你要安装和我相同版本的xdebug(php_xdebug-2.5.0-5.6-vc11-x86_64.dll)，可以点击进入我的百度云下载。 打开php的安装目录，找到php.ini配置文件。将下面这段话复制到php.ini 文件任意位置。 1234567891011[xdebug]xdebug.profiler_output_dir="D:\D\workspace\xdebug_output\xdebug";输出目录自己定义xdebug.trace_output_dir="D:\D\workspace\xdebug_output\xdebug";输出目录自己定义zend_extension="D:\D\software\php\php-5.6.27-Win32-VC11-x64\ext\php_xdebug-2.5.0-5.6-vc11-x86_64.dll";zend_extension为Xdebug在你电脑里安装的物理地址xdebug.remote_enable=onxdebug.profiler_enable=off ;一般不要打开性能监控，会生成很大的缓存文件，几个g到几十g都有xdebug.idekey="PHPSTORM" 检查Xdebug是否安装成功：用记事本写一个php文件，1.php。 12&lt;?php phpinfo(); 作用是打印php的信息。放置到Apache服务器的htdocs目录下。启动Apache服务器（不懂的在正文第一节中有介绍启动方法），在浏览器中输入localhost/1.php，在弹出的php信息页面Ctrl+F搜索是否有Xdebug。如果找不到说明Xdebug没有安装成功。如果显示下面的信息，说明xdebug已经安装成功。对于按照上面每一步操作下来，仍然没有显示Xdebug的解决办法： 打开Apache服务器的配置文件httpd.conf（不懂的在正文第一节中有介绍配置文件位置）,Ctrl+F搜索PHPIniDir，将后面的地址改成php.ini（php的配置文件）的地址。这样做是因为Apache服务器对PHP.Ini加载有个默认路径，如果和你的安装路径不一致，就读取不了php.ini，我的Apache2.4.17默认：PHPIniDir “D:/php”,改成自己的 php.ini 文件路径，重启Apache服务器，就可以了，这个时候发现Xdebug也加载出来了。 安装xdebug helperxdebug helper是一款浏览器插件，跟phpStorm配合用于调试你的php代码。如果你也使用的Chrome浏览器，xdebug helper可以点击进入我的百度云下载。安装方法为 Chrome浏览器-&gt;设置-&gt;扩展程序 ,将下载好的插件拖动进去即可。安装好以后在Chrome浏览器的右上角，会出现一个小虫子的图标。 正文到这里我默认你已经安装好了上面的几个工具。 检查Apache默认端口是否被占用Apache服务器的默认端口号是80，跟IIS服务器的默认端口号相同。因为我常用IIS发布一些.NET的项目，所以IIS服务器的端口号我十分不愿意修改，这里我选择修改Apache的默认端口号，把它改成8081（电脑上没装IIS服务器的可以忽略这个问题，检测方法：浏览器地址栏输入localhost,看看会不会显示IIS服务器的起始页，会有IIS字样）。 找到Apache服务器的所在文件夹。用文本编辑器打开/conf/httpd.conf，Ctrl+F搜索“Listen”，紧接着Listen的数字就是端口号，默认状态下为“Listen 80/8080”，改成8081。 切换到Apache目录下的bin文件夹下（例如我的是D:\Apache2.4.17-x64\bin）。双击打开httpd.exe即可启动，启动后弹出一个黑色的命令框。在浏览器中输入localhost:8081/检查是否启动Apache服务器，成功启动后会看到Apache服务器的欢迎页。 配置phpStorm打开自己的phpStorm。 1.新建一个php文件test.php。不需要知道我写的这个文件的意思，感兴趣的同学可以继续进行研究，这个就说来话长了。 将项目拷贝到apache服务器htdocs目录下，启动phpStorm时打开的文件路径为Apache服务器下项目的路径 File-&gt; Settings-&gt; Build,Execution,Deployment-&gt; Debugger，设置端口号Port为8081。 2.发布项目。 File-&gt; Settings-&gt; Build,Execution,Deployment-&gt; Deployment，点击左上角加号，新增一个发布的项目。Type下拉框选择In place，Name文本框对边填写一个名字。我填的是Test。点击Ok，在这个界面配置Web server root URL，地址是用浏览器访问的地址，一般写成http://服务器IP地址:服务器端口号，这里我写为http://localhost:8081，也可以写成http://localhost:8081/Test，这里的Test为刚刚发布项目时取的名字。保存更改。 3.打开File-&gt; Settings-&gt; Languages &amp; Frameworks-&gt; PHP-&gt; Servers，点击Import，导入一个部署好的项目。在下拉框里选择刚刚发布的项目Test。点击确定，保存修改。 4.点菜单栏的Run&gt;Edit Configurations… 在弹出的窗口中添加一个调试配置：点击左上角加号，选择PHP Web Application,在右侧的Configuration里点击“更多”按钮。弹出了刚刚配置好的Servers,点击确定保存修改。在Name里随便取个名字，我取的是Test。 5.进入File-&gt; Settings-&gt; Languages &amp; Frameworks-&gt; PHP -&gt;Debug，找到Xdebug选项卡，port填9000(Debug port要和php.ini里面的 xdebug.remote_port相一致！默认是9000)。 6.进入File-&gt; Settings-&gt;Languages &amp; Frameworks -&gt;PHP -&gt;Debug -&gt;DBGp Proxy 填写：IDE key: phpStormhost: localhostport: 8081 需要注意的问题1.File-&gt; Settings-&gt; Build,Execution,Deployment-&gt; Deployment下的 Web server root URL 下将启动后的默认url改为”http://” +你的 ip后，发现总是默认启动80端口，原来还要加上服务器的端口号（我设置的8081），这样才会找到正确的路径。 2.更改完Apache的配置后一定要重启服务器。 高阶配置更改默认的网站目录为PHPStorm的工作目录。 由于默认的网站目录在Apache服务器目录下的htdocs里，可是我的phpStrom用的工作目录(WorkSpace)却不是这个,在phpstorm里点击Chrome浏览器图标默认打开的url不是服务器下的，所以会出错，影响浏览php页面的心情。 怎样才能不再浏览器里输入Apache下的工作路径而直接在phpStorm里点击Chrome浏览器图标访问自己编写的项目呢？ 解决方法1.将此php项目的工作目录赋值到Apache服务器的htdocs目录下，这样省去了粘贴项目到htdocs目录下的繁琐，但不是最佳解决方案。 2.在Apache的配置文件httpd.conf 里面修改Apache的默认工作目录在Apache配置文件里搜索”DocumentRoot”，将DocumentRoot和Directory改为你PHPStrom的工作目录即可，注意两个值一定要相同,重启Apache服务器。 12DocumentRoot "D:/D/workspace/phpStorm10.0.1_WorkSpace"&lt;Directory "D:/D/workspace/phpStorm10.0.1_WorkSpace"&gt; 上面的步骤实际上是手动完成了 相当于Eclipse在 IDE中自动配置发布的过程。按照这个步骤配置好以后就达到了相当于WebStorm里点击浏览器直接查看网页的功能，但这里配置的更完美，在phpStorm里直接点开Chrome浏览器图标以后在浏览器的地址栏里面显示的是服务器下的路径，究竟有多完美，自行体会。 php debug说到这里又非常有趣了。 1.检查谷歌浏览器扩展插件是否下载了xdebug插件。2.检查本地php下安装对应php版本的xdebug.dll文件。3.启动Apache服务器。4.phpstorm里打开调试的监听器5.加断点6.点击phpStorm里的Chrome浏览器图标，像run 项目一样，就自动进入debug模式了。7.不想debug？ 关掉phpstorm里debug监听器即可，这时候点击 浏览器图标就只是run了。 配置好之后调试php就一个字，爽！！！ 总结这篇博客是博主良心之作。教程里有特别多的细节和注意点，应用好这些注意点可以极大方便你的php开发，调试。让你拥有不弱于VS/Eclipse 的用户体验！！！希望各位看官在转载之余不忘写明出处，本人将不胜感激。参考文献PHP 设置调试工具XDebug PHPStorm IDE 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[离线搭建Docker环境]]></title>
      <url>%2Fblog%2F2016%2F12%2F31%2F%E7%A6%BB%E7%BA%BF%E6%90%AD%E5%BB%BAdocker%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[最近由于工作的原因，需要在内网用docker环境搭建靶场来复现一些漏洞的attack。 特此简单记录自己docker的学习过程。 Daocloud官网 准备操作系统：虚拟机 ubuntu 16.04 LTS 我收集的Docker资料包下载 Docker简介Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker是一个由GO语言写的程序运行的“容器”（Linux containers， LXCs）。 Docker是为开发者和系统管理员设计的，用来发布和运行分布式应用程序的一个开放性平台。 Docker相对于VM虚拟机的优势十分明显，那就是轻量和高性能和便捷性。 Docker 架构Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。 应用场景在docker的网站上提到了docker的典型场景：1.Automating the packaging and deployment of applications（使应用的打包与部署自动化）2.Creation of lightweight, private PAAS environments（创建轻量、私密的PAAS环境）3.Automated testing and continuous integration/deployment（使连续的集成/部署、测试自动化）4.Deploying and scaling web apps, databases and backend services（部署、衡量网页app、数据库和后台服务） 局限Docker并不是全能的，设计之初也不是KVM之类虚拟化手段的替代品，简单总结几点：1.Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用2.LXC是基于cgroup等linux kernel功能的，因此container的guest系统只能是linux base的3.隔离性相比KVM之类的虚拟化方案还是有些欠缺，所有container公用一部分的运行库4.网络管理相对简单，主要是基于namespace隔离5.cgroup的cpu和cpuset提供的cpu功能相比KVM的等虚拟化方案相比难以度量(所以dotcloud主要是按内存收费)6.docker对disk的管理比较有限7.container随着用户进程的停止而销毁，container中的log等用户数据不便收集。 Docker安装本教程只针对 ubuntu 16.04 LTS,我是在虚拟机上面安装的。 将下载好的资料包拷贝到ubuntu的文件系统中去。在当前目录空白处点击右键，选择Opern in Terminal。安装vim。在命令行输入 1$ dpkg -i vim-common_2%3a7.4.1689-3ubuntu1.2_amd64.deb 如果报错 1dpkg: error: requested operation requires superuser privilege 在前面加上sudo意为用管理员权限操作，重新输入 1$ sudo dpkg -i vim-common_2%3a7.4.1689-3ubuntu1.2_amd64.deb 依次安装 123$ sudo dpkg -i vim-tiny_2%3a7.4.1689-3ubuntu1.2_amd64.deb $ sudo dpkg -i vim-runtime_2%3a7.4.1689-3ubuntu1.2_all.deb $ sudo dpkg -i vim_2%3a7.4.1689-3ubuntu1.2_amd64.deb 安装AUFS文件系统。 12$ sudo dpkg -i aufs-tools_1%3a3.2+20130722-1.1ubuntu1_amd64.deb ``` 安装cgroup工具。12``` bash$ sudo dpkg -i cgroupfs-mount_1.2_all.deb 想详细了解cgroup的同学可以看看下面两个链接：cgroup介绍、安装和配置文件解析cgroups介绍.pdf 安装liberror-perl（可用来以后配置git）。 1$ sudo dpkg -i liberror-perl_0.17-1.2_all.deb 安装docker-engine（Docker 引擎） The Docker Engine is a lightweight container runtime and robust tooling that builds and runs your container. Docker allows you to package up application code and dependencies together in an isolated container that share the OS kernel on the host system. The in-host daemon communicates with the Docker Client to execute commands to build, ship and run containers.Docker引擎是一个轻量级容器运行时和强大的工具，构建和运行您的容器。Docker允许将应用程序代码和依赖关系打包在一个隔离的容器中，这些容器共享主机系统上的操作系统内核。主机内守护程序与Docker客户端进行通信，以执行命令来构建，运送和运行容器。 Docker Engine runs on both Linux and Windows operating systems on any infrastructure to create the operating environment for your applications. From a single container on a single host to a multi-container application networked across a cluster of hosts, Docker Engine delivers powerful tooling with a very simple user interface.Docker Engine在任何基础架构上的Linux和Windows操作系统上运行，为应用程序创建操作环境。从单个主机上的单个容器到跨群集主机联网的多容器应用程序，Docker Engine提供了具有非常简单的用户界面的强大的工具。 摘自https://www.docker.com 12$ sudo dpkg -i docker-engine_1.12.5-0~ubuntu-xenial_amd64.deb ``` 到这里Docker容器已经安装好了。 查看Docker版本。12``` bash$ docker -v 如果返回Docker version 1.12.5, build 7392c3b,证明前面的操作顺利。 查看Docker镜像。 1$ docker images 如果报错Cannot connect to the Docker daemon. Is the docker daemon running on this host?,在前面加上sudo意为用管理员权限操作，重新输入 1$ sudo docker images 观察到返回： 1REPOSITORY TAG IMAGE ID CREATED SIZE 都是空即为没有镜像的意思，下面我们来导入一个镜像。资料里的bwapp.tar.gz是一个demo，它是一个漏洞环境的镜像。 1$ sudo docker load &lt; bwapp.tar.gz 稍微等一小会儿。查看Docker镜像。 1$ docker images 结果： 123REPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; 41e984bb619b 17 months ago 465.9 MB``` 修改镜像的标签。123``` bash$ sudo docker tag 41e9 bwapp:latest ``` 查看Docker镜像。12``` bash$ sudo docker images 结果：1234``` bashREPOSITORY TAG IMAGE ID CREATED SIZEbwapp latest 41e984bb619b 17 months ago 465.9 MB``` 查看docker镜像所占用的端口。 1$ docker inspect 41e9 如图查看docker镜像所占端口。启动镜像bwapp。 12$ sudo docker run -d -p 0.0.0.0:8000:80 bwapp ``` 前面的”0.0.0.0：”是为了方便局域网中其他ip访问，可以省略。省略后”0.0.0.0:”仅虚拟机的宿主机（物理机）可以访问。8000是物理机中的端口号，80是虚拟机中docker镜像占用的端口号。 返回一长串code即为启动成功。3d23ce867614b04ae7fb7e438fb5676b73e6f9fbc42f232d994a39cbdf6d1621 检查docker占用的线程号确认docker镜像是否启动。12```bash$ sudo docker ps -l 我的运行结果： 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3d23ce867614 bwapp "/run.sh" About a minute ago Up About a minute 80/tcp, 3306/tcp, 0.0.0.0:8000-&gt;80/tcp sick_brown 到这里docker镜像已启动且已做好端口映射。可以在物理机的浏览器中根据虚拟机的ip+刚才给物理机设置的端口号8000即http://192.168.183.131:8000来访问。 注意：第一次在浏览器中访问要在ip和端口号后面输入”/install.php初始化一下”。bwapp是仅我上传的一个demo镜像，用作方便docker的讲解，不属于docker的插件。 让你的Docker连上服务器仓库1234$ cd /etc/docker/$ ls$ touch daemon.json // 将这句话拷贝到daemon.json中： &#123;"insecure-registries": ["192.168.1.105:5000"]&#125; // 192.168.1.105为你的服务器在局域网的ip。$ service docker restart //重启 如果提示没权限，输入 1$ su 接着输入root用户的密码即可保持root权限操作。 如果忘记root用户密码，用以下命令重置root用户密码： 1$ sudo passwd root 拉取服务器仓库中的镜像12$ curl -XGET http://192.168.1.150:5000/v2/_catalog //search 仓库中的镜像 // 添加服务器仓库的ip$ docker pull 192.168.1.150:5000/test_bwapp //拉取一个服务器的镜像 总结因本人水平有限，故此文只作为自己学习过程中的记录。并不是什么教程，如有纰漏，还望指正，定当不胜感激。 参考文献百度百科 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（七）Spring整合Hibernate]]></title>
      <url>%2Fblog%2F2016%2F09%2F11%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring整合Hibernate。 准备JBoss官网 根据自己Eclipse版本下载对应的插件。我的是Eclipse Kepler 4.3.2，所以我下载了JBoss Tools 4.1.2.Final。官网上写它的Requirements: Java 6 or Java 7 and Eclipse Kepler 4.3.2 为eclipse安装Hibernate Tools 目标1.有IOC容器来生成Hibernate的SessionFactory。2.让Hibernate使用上Spring的声明式事务。 步骤1.加入Hibernate①.添加jar包。②.新建Hibernate配置文件：hibernate.cfg.xml。2.加入Spring 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（六）Spring中的事务管理]]></title>
      <url>%2Fblog%2F2016%2F09%2F03%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring中的事务管理。 Spring中的事务管理事务就是一系列的动作，它们被当做一个单独的工作单元，这些动作要么全部完成，要么全部不起作用。用来确保数据的完整性和一致性。事务的四个关键属性（ACID）1.原子性（atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成要么完全不起作用。2.一致性（consistency）：一旦所有事务动作完成，事务就被提交，数据和资源就处于一种满足业务规则的一致性状态中。3.隔离性（isolation）：可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据破坏。4.持久性（durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，通常情况下，事务的结果被写到持久化存储器中。 Spring的事务管理机制Spring在不同的事务管理API之上定义了一个抽象层。而应用程序开发人员不必了解底层的事务管理API，就可以使用Spring的事务管理机制。Spring既支持编程式事务管理，也支持声明式的事务管理。编程式事务管理：将事务管理代码嵌入到业务方法中来控制事务的提交和回滚。在编程式管理事务时，必须在每个事务操作中包含额外的事务管理代码。声明式事务管理：大多数情况下比编程式事务管理更好用。它将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过SpringAOP框架支持声明式事务管理。 Spring中的事务管理器Spring从不同的事务管理API中抽象了一整套的事务机制。开发人员不必了解底层的事务API，就可以利用这些事务机制。有了这些事务机制，事务管理代码就能独立于特定的事务技术了。Spring的核心事务管理抽象是 org.springframework.transaction Interface Platform TransactionManager管理和封装了一组独立于技术的方法。无论使用Spring的哪种事务管理策略（编程式或声明式），事务管理器都是必须的。 Spring中事务管理器的不同实现org.springframework.jdbc.datasourceClass DataSource TransactionManager:在应用程序中只需要处理一个数据源，而且通过JDBC存取。 org.springframework.transaction.jtaClass JtaTransactionManager:在JavaEE应用服务器上用JTA（Java Transaction API）进行事务管理。 org.springframework.orm.hibernate3Class Hibernate TransactionManager:用Hibernate框架存取数据库。 事务管理器以普通的Bean形式声明在SpringIOC容器中。 声明式事务一共三步。1.在配置文件中配置事务管理器2.在配置文件中配置注解驱动3.在要应用事务的方法前添加@Transaction。 沿用上一节中的项目。在项目下新建包com.leezp.spring.tx。在该包下新建接口BookShopDao.java。 12345678910111213package com.leezp.spring.tx;public interface BookShopDao &#123; //根据书号获取书的单价 public int findBookPriceByIsbn(String isbn); //更新书的库存，使书号对应的库存 -1 public void updateBookStock(String isbn); //更新用户的账户余额：使username的balance - price public void updateUserAccount(String username,int price);&#125; 新建异常类BookStockException.java。 1234567891011121314151617181920212223242526272829303132333435363738package com.leezp.spring.tx;//继承RuntimeException,Generate Constructors from SuperClass添加构造器// Add default serial version IDpublic class BookStockException extends RuntimeException &#123; /** * */ private static final long serialVersionUID = 1L; public BookStockException() &#123; super(); // TODO Auto-generated constructor stub &#125; public BookStockException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); // TODO Auto-generated constructor stub &#125; public BookStockException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public BookStockException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125; public BookStockException(Throwable cause) &#123; super(cause); // TODO Auto-generated constructor stub &#125;&#125; 新建异常类UserAccountException.java。 123456789101112131415161718192021222324252627282930313233343536package com.leezp.spring.tx;public class UserAccountException extends RuntimeException &#123; /** * */ private static final long serialVersionUID = 1L; public UserAccountException() &#123; super(); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public UserAccountException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125; public UserAccountException(Throwable cause) &#123; super(cause); // TODO Auto-generated constructor stub &#125;&#125; 新建接口BookShopDao的实现类BookShopDaoImpl.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.leezp.spring.tx;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repository("bookShopDao")public class BookShopDaoImpl implements BookShopDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public int findBookPriceByIsbn(String isbn) &#123; String sql = " select price from book where isbn = ? "; return jdbcTemplate.queryForObject(sql, Integer.class, isbn); &#125; @Override public void updateBookStock(String isbn) &#123; // 检查书的库存是否足够，若不够，则抛出异常 String sql2 = " select stock from book_stock where isbn = ? "; int stock = jdbcTemplate.queryForObject(sql2, Integer.class, isbn); if (stock == 0) &#123; // 定义一个异常类 throw new BookStockException("库存不足"); &#125; String sql = " update book_stock set stock= stock -1 where isbn = ? "; jdbcTemplate.update(sql, isbn); &#125; @Override public void updateUserAccount(String username, int price) &#123; // 验证余额是否足够，若不足，则抛出异常 String sql2 = " select balance from account where username = ? "; int balance = jdbcTemplate .queryForObject(sql2, Integer.class, username); if (balance &lt; price) &#123; throw new UserAccountException("余额不足"); &#125; String sql = " update account set balance=balance - ? where username = ? "; jdbcTemplate.update(sql, price, username); &#125;&#125; 新建接口BookShopService.java。 123456package com.leezp.spring.tx;public interface BookShopService &#123; public void purchase(String username, String isbn);&#125; 新建接口BookShopService的实现类BookShopServiceImpl.java。注意在要应用事务的方法上添加@Transaction。 12345678910111213141516171819202122232425package com.leezp.spring.tx;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service("bookShopService")public class BookShopServiceImpl implements BookShopService &#123; @Autowired private BookShopDao bookShopDao; //添加事务注解 @Transactional @Transactional @Override public void purchase(String username, String isbn) &#123; // 1.获取书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); // 2.更新书的库存 -1 bookShopDao.updateBookStock(isbn); // 3.更新用户余额 bookShopDao.updateUserAccount(username, price); &#125;&#125; 重新配置db.properties属性文件里的连接字符串。 1jdbc.jdbcUrl=jdbc:mysql://localhost:3306/spring_demo2 修改applicationContext.xml配置文件。 1&lt;context:component-scan base-package="com.leezp.spring"&gt;&lt;/context:component-scan&gt; 向该配置文件中添加： 123456789&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 添加数据源 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 启用事务注解 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; 新建测试类（JUnit Test Case）SpringTransactionTest.java。 123456789101112131415161718192021222324252627282930313233343536373839package com.leezp.spring.tx;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTransactionTest &#123; private ApplicationContext ctx = null; private BookShopDao bookShopDao = null; private BookShopService bookShopService=null; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); bookShopDao=ctx.getBean(BookShopDao.class); bookShopService=ctx.getBean(BookShopService.class); &#125; @Test public void testBookShopService()&#123; bookShopService.purchase("AA", "1001"); &#125; @Test public void testBookShopDaoUpdateUserAccount()&#123; bookShopDao.updateUserAccount("AA", 200); &#125; @Test public void testBookShopDaoUpdateBookStock()&#123; bookShopDao.updateBookStock("1001"); &#125; @Test public void testBookShopDaoFindPriceByIsbn() &#123; System.out.println(bookShopDao.findBookPriceByIsbn("1001")); &#125;&#125; 获取源代码获取数据库文件 其他细节事务的属性：1.事务的传播行为 propagation2.事务的隔离级别 isolation3.对哪些异常不回滚 noRollbackFor/rollbackFor4.事务的过期时间 timeout 事务传播属性当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。 事务的传播行为可以由传播属性指定。Spring定义了7种传播行为。 Spring支持的事务传播行为REQUIRED(默认)：如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行。 REQUIRES_NEW：当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起。 SUPPORTS：如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中。 NOT_SUPPORTED：当前的方法不应该运行在事务中，如果有运行的事务，将它挂起。 MANDATORY：当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常。 NEVER：当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常。 NESTED：如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行。 事务的传播属性可以在@Transactional注解的propagation属性中定义。eg:@Transactional(propagation=Propagation.REQUIRED) 在项目中新建接口Cashier.java。 12345678package com.leezp.spring.tx;import java.util.List;public interface Cashier &#123; public void checkout(String username, List&lt;String&gt; isbns);&#125; 新建接口Cashier的实现类CashierImpl.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.leezp.spring.tx;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;/** * 事务的传播行为（事务之间的调用） * * @author Lee * */@Service("cashier")public class CashierImpl implements Cashier &#123; @Autowired private BookShopService bookShopService; /** * 当bookService的purchase()方法被另一个事务方法checkout()调用时， * * 它默认会在**已有**的事务内运行，这个默认的传播行为就是REQUIRED。 * * 因此在checkout()方法的开始和终止边界内只有一个事务， * * 这个事务只在checkout()方法结束的时候被提交， * * 因为用户余额只够买第一本书的，所以最终结果用户一本书都买不了。 * */ // 使用propagation 指定事务的传播行为，即当前的事务方法被另一个事务方法调用时，如何使用事务 // 默认取值REQUIRED,即使用调用方法的事务 // REQUIRES_NEW:使用自己的事务，调用事务的方法的事务被挂起 @Transactional(propagation = Propagation.REQUIRED) @Override public void checkout(String username, List&lt;String&gt; isbns) &#123; for (String isbn : isbns) &#123; bookShopService.purchase(username, isbn); &#125; &#125;&#125; 修改SpringTransactionTest.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.leezp.spring.tx;import java.util.Arrays;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringTransactionTest &#123; private ApplicationContext ctx = null; private BookShopDao bookShopDao = null; private BookShopService bookShopService = null; private Cashier cashier = null; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); bookShopDao = ctx.getBean(BookShopDao.class); bookShopService = ctx.getBean(BookShopService.class); cashier = ctx.getBean(Cashier.class); &#125; @Test public void testTransactionlPropagation() &#123; cashier.checkout("AA", Arrays.asList("1001", "1002")); &#125; @Test public void testBookShopService() &#123; bookShopService.purchase("AA", "1001"); &#125; @Test public void testBookShopDaoUpdateUserAccount() &#123; bookShopDao.updateUserAccount("AA", 200); &#125; @Test public void testBookShopDaoUpdateBookStock() &#123; bookShopDao.updateBookStock("1001"); &#125; @Test public void testBookShopDaoFindPriceByIsbn() &#123; System.out.println(bookShopDao.findBookPriceByIsbn("1001")); &#125;&#125; 获取源代码 并发事务所导致的问题当同一个应用程序或者不同应用程序中的多个事务在同一个数据集上并发执行时，可能会出现许多意外的问题。 并发事务所导致的问题可以分为下面三种类型：1.脏读：对于两个事务T1,T2,T1读取了已经被T2更新但还没有被提交的字段。之后，若T2回滚，T1读取的内容就是临时且无效的。2.不可重复读：对于两个事务T1,T2,T1读取了一个字段，然后T2更新了该字段。之后，T1再次读取同一个字段，值就不同了。3.幻读：对于两个事务T1,T2,T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行。之后，如果T1再次读取同一个表，就会多出几行。 事务的隔离级别：使用isolation指定事务的隔离级别，最常用的取值为 READ_COMMITTED：保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 超时和只读属性由于事务可以在行和表上获得锁，因此长事务会占用资源，并对整体性能产生影响。如果一个事务只读取数据但不做修改，数据库引擎可以对这个事务进行优化。超时事务属性：事务在强制回滚之前可以保持多久。这样可以防止长期运行的事务占用资源。只读事务属性：表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。 修改CashierImpl.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.leezp.spring.tx;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;/** * 事务的传播行为（事务之间的调用） * * @author Lee * */@Service("cashier")public class CashierImpl implements Cashier &#123; @Autowired private BookShopService bookShopService; /** * 当bookService的purchase()方法被另一个事务方法checkout()调用时， * * 它默认会在**已有**的事务内运行，这个默认的传播行为就是REQUIRED。 * * 因此在checkout()方法的开始和终止边界内只有一个事务， * * 这个事务只在checkout()方法结束的时候被提交， * * 因为用户余额只够买第一本书的，所以最终结果用户一本书都买不了。 * */ // 1.使用propagation 指定事务的传播行为，即当前的事务方法被另一个事务方法调用时，如何使用事务 // 默认取值REQUIRED,即使用调用方法的事务 // REQUIRES_NEW:使用自己的事务，调用事务的方法的事务被挂起 // 2.使用isolation指定事务的隔离级别，最常用的取值为 READ_COMMITTED // 3.默认情况下Spring的声明式事务对所有的运行时异常进行回滚，也可以通过对应的属性进行设置。 // noRollbackFor:指定对哪些异常不进行回滚，通常情况下取默认值即可。 // @Transactional(propagation = Propagation.REQUIRED, isolation = // Isolation.READ_COMMITTED, noRollbackFor = &#123; UserAccountException.class &#125;) // 4.使用readOnly指定事务是否只读，即没有写操作，表示这个事务只读取数据但不更新数据， // 这样可以帮助数据库引擎优化事务，若真的是一个只读取数据库值的方法，应设置 readonly=true // 5.timeout:单位 秒，使用timeout指定强制回滚之前事务可以占用的时间。 @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, readOnly = false, timeout = 3) @Override public void checkout(String username, List&lt;String&gt; isbns) &#123; for (String isbn : isbns) &#123; bookShopService.purchase(username, isbn); &#125; &#125;&#125; 获取源代码 基于XML文件方式新建包com.leezp.spring.tx.xml。复制com.leezp.spring.tx包下的BookShopDao.java、BookStockException.java、UserAccountException.java到com.leezp.spring.tx.xml包。在该包下新建BookShopDaoImpl.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.leezp.spring.tx.xml;import org.springframework.jdbc.core.JdbcTemplate;public class BookShopDaoImpl implements BookShopDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public int findBookPriceByIsbn(String isbn) &#123; String sql = " select price from book where isbn = ? "; return jdbcTemplate.queryForObject(sql, Integer.class, isbn); &#125; @Override public void updateBookStock(String isbn) &#123; // 检查书的库存是否足够，若不够，则抛出异常 String sql2 = " select stock from book_stock where isbn = ? "; int stock = jdbcTemplate.queryForObject(sql2, Integer.class, isbn); if (stock == 0) &#123; // 定义一个异常类 throw new BookStockException("库存不足"); &#125; String sql = " update book_stock set stock= stock -1 where isbn = ? "; jdbcTemplate.update(sql, isbn); &#125; @Override public void updateUserAccount(String username, int price) &#123; // 验证余额是否足够，若不足，则抛出异常 String sql2 = " select balance from account where username = ? "; int balance = jdbcTemplate .queryForObject(sql2, Integer.class, username); if (balance &lt; price) &#123; throw new UserAccountException("余额不足"); &#125; String sql = " update account set balance=balance - ? where username = ? "; jdbcTemplate.update(sql, price, username); &#125;&#125; 新建包com.leezp.spring.tx.xml.service。复制com.leezp.spring.tx.xml包下的Cashier.java、BookShopService.java到包com.leezp.spring.tx.xml.service。新建包com.leezp.spring.tx.xml.service.impl。在该包下新建BookShopServiceImpl.java。 123456789101112131415161718192021222324package com.leezp.spring.tx.xml.service.impl;import com.leezp.spring.tx.xml.BookShopDao;import com.leezp.spring.tx.xml.service.BookShopService;public class BookShopServiceImpl implements BookShopService &#123; private BookShopDao bookShopDao; public void setBookShopDao(BookShopDao bookShopDao) &#123; this.bookShopDao = bookShopDao; &#125; @Override public void purchase(String username, String isbn) &#123; // 1.获取书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); // 2.更新书的库存 -1 bookShopDao.updateBookStock(isbn); // 3.更新用户余额 bookShopDao.updateUserAccount(username, price); &#125;&#125; 在该包下新建CashierImpl.java。 1234567891011121314151617public class CashierImpl implements Cashier &#123; private BookShopService bookShopService; public void setBookShopService(BookShopService bookShopService) &#123; this.bookShopService = bookShopService; &#125; @Override public void checkout(String username, List&lt;String&gt; isbns) &#123; for (String isbn : isbns) &#123; bookShopService.purchase(username, isbn); &#125; &#125;&#125; 新建配置文件applicationContext-tx-xml.xml。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;context:component-scan base-package="com.leezp.spring"&gt;&lt;/context:component-scan&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置c3p0数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Spring 的jdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Bean --&gt; &lt;bean id="bookShopDao" class="com.leezp.spring.tx.xml.BookShopDaoImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="bookShopService" class="com.leezp.spring.tx.xml.service.impl.BookShopServiceImpl"&gt; &lt;property name="bookShopDao" ref="bookShopDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="cashier" class="com.leezp.spring.tx.xml.service.impl.CashierImpl"&gt; &lt;property name="bookShopService" ref="bookShopService"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 1.配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2.配置事务属性：传播行为、隔离级别、回滚、过期时间 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 根据方法名指定事务的属性 --&gt; &lt;tx:method name="purchase" propagation="REQUIRES_NEW" /&gt; &lt;tx:method name="*" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 3.配置事务切入点（在哪个方法起作用）以及把事务切入点和事务属性关联起来 --&gt; &lt;aop:config&gt; &lt;!-- 设置 任意返回值任意类型任意方法任意参数 --&gt; &lt;aop:pointcut expression="execution(* com.leezp.spring.tx.xml.service.*.*(..))" id="txPointCut" /&gt; &lt;!-- 用 &lt;aop:advisor&gt;将事务切入点和事务属性关联起来 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 在包com.leezp.spring.tx.xml下新建SpringTransactionTest.java。 123456789101112131415161718192021222324252627282930313233343536package com.leezp.spring.tx.xml;import java.util.Arrays;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.tx.xml.service.BookShopService;import com.leezp.spring.tx.xml.service.Cashier;public class SpringTransactionTest &#123; private ApplicationContext ctx = null; private BookShopDao bookShopDao = null; private BookShopService bookShopService = null; private Cashier cashier = null; &#123; ctx = new ClassPathXmlApplicationContext( "applicationContext-tx-xml.xml"); bookShopDao = ctx.getBean(BookShopDao.class); bookShopService = ctx.getBean(BookShopService.class); cashier = ctx.getBean(Cashier.class); &#125; @Test public void testTransactionlPropagation() &#123; cashier.checkout("AA", Arrays.asList("1001", "1002")); &#125; @Test public void testBookShopService() &#123; bookShopService.purchase("AA", "1001"); &#125;&#125; 获取源代码 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（五）Spring对JDBC的支持]]></title>
      <url>%2Fblog%2F2016%2F08%2F27%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring对JDBC的支持。 JdbcTemplate 简介为了使JDBC更加易于使用，Spring在JDBC API上定义了一个抽象层，以此建立一个JDBC存取框架。 作为Spring JDBC框架的核心，JDBC模板的设计目的是为不同类型的JDBC操作提供模板方法。每个模板方法都能控制整个过程，并允许覆盖过程中的特定任务。通过这种方式，可以在尽可能保留灵活性的情况下，将数据库存取的工作量降到最低。 使用 JdbcTemplate更新数据库用sql语句和参数更新数据库：update public int update(String sql,Object… args) throw DataAccessException 批量更新数据库batchUpdate public int[] batchUpdate(String sql,List batchArgs) 使用 JdbcTemplate查询数据库查询单行queryForObject public T queryForObject(String sql,ParameterizedRowMapper n,Object… args)throws DataAccessException 便利的BeanPropertyRowMappper实现org.springframework.jdbc.core.simpleClass ParameterizedBeanPropertyRowMapper java.lang.ObjectBeanPropertyRowMapperParameterizedBeanPropertyRowMapper 查询多行query public List query(String sql,ParameterizedRowMapper n,Object… args) throws DataAccessException 单值查询queryForObject public T queryForObject(String sql,Class requiredType,Object… args) throws DataAccessException 简化JDBC模板查询每次使用都创建一个JdbcTemplate的新实例，这种做法效率很低下。JdbcTemplate类被设计成为线程安全的，所以可以在IOC容器中声明它的单个实例，并将这个实例注入到所有的DAO实例中。JdbcTemplate 也利用了Java 1.5 的特定（自动装箱，泛型，可变长度等）来简化开发。SpringJDBC框架还提供了一个JdbcDaoSupport类来简化DAO实现。该类声明了jdbcTemplate属性，它可以从IOC容器中注入，或者自动从数据源中创建。不推荐使用 JdbcDaoSupport，而推荐直接使用 JdbcTemplate作为Dao类的成员变量。 新建项目spring-03。新建文件夹lib。导入如下的包并build path。c3p0-0.9.1.2.jarcom.springsource.net.sf.cglib-2.2.0.jarcom.springsource.org.aopalliance-1.0.0.jarcom.springsource.org.aspectj.weaver-1.6.8.RELEASE.jarcommons-logging-1.2.jarmysql-connector-java-5.1.22-bin.jarspring-aop-4.0.4.RELEASE.jarspring-aspects-4.0.4.RELEASE.jarspring-beans-4.0.4.RELEASE.jarspring-context-4.0.4.RELEASE.jarspring-core-4.0.4.RELEASE.jarspring-expression-4.0.4.RELEASE.jarspring-jdbc-4.0.4.RELEASE.jarspring-orm-4.0.4.RELEASE.jarspring-tx-4.0.4.RELEASE.jarspring-web-4.0.4.RELEASE.jarspring-webmvc-4.0.4.RELEASE.jar 在该项目下新建包com.leezp.spring.jdbc。在该包下新建Department.java。 1234567891011121314151617181920212223242526272829package com.leezp.spring.jdbc;public class Department &#123; private Integer id; private String name; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return "Department [id=" + id + ", name=" + name + "]"; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 在该包下新建Employee.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.leezp.spring.jdbc;public class Employee &#123; private Integer id; private String lastName; private String email; private Department department; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastname() &#123; return lastName; &#125; public void setLastname(String lastname) &#123; this.lastName = lastname; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; @Override public String toString() &#123; return "Employee [id=" + id + ", lastname=" + lastName + ", email=" + email + ", department=" + department + "]"; &#125;&#125; 新建EmployeeDao.java。 1234567891011121314151617181920212223242526272829package com.leezp.spring.jdbc;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.stereotype.Repository;/** * 注解方式使用JdbcTemplate * * @author Lee * */@Repositorypublic class EmployeeDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public Employee get(Integer id) &#123; String sql = " select id,last_name lastName,email from employees where id = ? "; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, id); return employee; &#125;&#125; 新建DepartmentDao.java。 1234567891011121314151617181920212223242526272829303132package com.leezp.spring.jdbc;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;import org.springframework.stereotype.Repository;import com.leezp.spring.jdbc.Department;/** * 不推荐使用 JdbcDaoSupport，而推荐直接使用 JdbcTemplate作为Dao类的成员变量 * * @author Lee * */@Repositorypublic class DepartmentDao extends JdbcDaoSupport &#123; @Autowired public void setDataSource2(DataSource dataSource) &#123; setDataSource(dataSource); &#125; public Department get(Integer id) &#123; String sql = " select id,dept_name name from departments where id=? "; RowMapper&lt;Department&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Department.class); return getJdbcTemplate().queryForObject(sql, rowMapper, id); &#125;&#125; 新建db.properties属性文件。 1234567jdbc.user=rootjdbc.password=rootjdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql://localhost:3306/spring_demojdbc.initPoolSize=5jdbc.maxPoolSize=10 新建applicationContext.xml配置文件。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;context:component-scan base-package="com.leezp.spring.jdbc"&gt;&lt;/context:component-scan&gt; &lt;!-- 导入资源文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties" /&gt; &lt;!-- 配置c3p0数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="$&#123;jdbc.initPoolSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="$&#123;jdbc.maxPoolSize&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Spring 的jdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在该包下new-&gt; JUnit Test Case-&gt; 新建一个JDBCTest.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.leezp.spring.jdbc;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import javax.sql.DataSource;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;public class JDBCTest &#123; private ApplicationContext ctx = null; private JdbcTemplate jdbcTemplate; private EmployeeDao employeeDao; private DepartmentDao departmentDao; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate"); employeeDao = ctx.getBean(EmployeeDao.class); departmentDao = ctx.getBean(DepartmentDao.class); &#125; // 可以 双击方法名，使其变蓝，右键，run as-&gt; JUnit Test 单独运行这一个测试方法 @Test public void testDepartmentDao() &#123; System.out.println(departmentDao.get(1)); &#125; @Test public void testEmployeeDao() &#123; System.out.println(employeeDao.get(1)); &#125; /** * 获取单个Bean的值，或做统计查询 * * queryForObject(String sql, Class&lt;Long&gt; requiredType) */ @Test public void testQueryForObject2() &#123; String sql = " select count(id) from employees "; long count = jdbcTemplate.queryForObject(sql, Long.class); System.out.println(count); &#125; /** * 查到实体类的集合 * * query(sql, rowMapper, args) */ @Test public void testQueryForList() &#123; String sql = " SELECT id,last_name lastName,email,dept_id From employees where id&gt;? "; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper, 5); System.out.println(employees); &#125; /** * 从数据库中获取一条记录，实际得到对应的一个对象 * * 注意不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, * Object...args)方法 * * 而是调用queryForObject(sql, rowMapper, args)方法。 * * 1.其中的 RowMapper 指定如何去映射结果集的行，常用的实现类为BeanPropertyRowMapper。 * * 2.使用SQL中列的别名完成列名和类的属性名的映射。例如 last_name lastName。 * * 3.不支持级联属性，JdbcTemplate到底是一个JDBC的小工具，而不是ORM框架。 */ // 结果：Employee [id=1, lastname=Tom, email=tom@qq.com, department=null] @Test public void testQueryForObject() &#123; String sql = " SELECT id,last_name lastName,email,dept_id as \"department.id\" From employees where id=? "; // import org.springframework.jdbc.core.RowMapper; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1); System.out.println(employee); &#125; /** * 执行批量insert/update/delete * * 最后一个参数是 Object[] 的 List 类型: 因为修改一条记录需要一个Object的数组，那么多条不就需要多个Object的数组吗 */ @Test public void testBatchUpdate() &#123; String sql = " INSERT INTO employees(last_name,email,dept_id) values(?,?,?) "; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(new Object[] &#123; "AA", "AA@qq.com", 1 &#125;); batchArgs.add(new Object[] &#123; "BB", "BB@qq.com", 2 &#125;); batchArgs.add(new Object[] &#123; "CC", "CC@qq.com", 3 &#125;); jdbcTemplate.batchUpdate(sql, batchArgs); &#125; /** * 执行 INSERT,UPDATE,DELETE */ @Test public void testUpdate() &#123; String sql = "UPDATE employees SET LAST_NAME=? where ID =? "; jdbcTemplate.update(sql, "Jack", 5); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125; 获取源代码获取数据库文件 在JDBC模板中使用具名参数在经典的JDBC用法中，SQL参数是用占位符？表示，并且受到位置的限制。定位参数的问题在于，一旦参数的顺序发生变化，就必须改变参数绑定。在SpringJDBC框架中，绑定SQL参数的另一种选择是使用具名参数(named parameter)。具名参数：SQL按名称（以冒号开头）而不是按位置进行指定。具名参数更易于维护，也提升了可读性。具名参数由框架类在运行时用占位符取代。具名参数只在NamedParameterJdbcTemplate中得到支持。 修改applicationContext.xml配合文件。增加以下内容。 12345&lt;!-- 配置namedParameterJdbcTemplate,该对象可以使用具名参数，其没有无参数的构造器，所以必须为其构造器指定参数 --&gt; &lt;bean id="namedParameterJdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"&gt; &lt;constructor-arg ref="dataSource"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 修改Employee.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.leezp.spring.jdbc;public class Employee &#123; private Integer deptId; private String lastName; private String email; private Department department; public Integer getDeptId() &#123; return deptId; &#125; public void setDeptId(Integer deptId) &#123; this.deptId = deptId; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getLastname() &#123; return lastName; &#125; public void setLastname(String lastname) &#123; this.lastName = lastname; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; @Override public String toString() &#123; return "Employee [deptId=" + deptId + ", lastName=" + lastName + ", email=" + email + ", department=" + department + "]"; &#125;&#125; 修改JDBCTest.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package com.leezp.spring.jdbc;import java.sql.SQLException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.sql.DataSource;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;import org.springframework.jdbc.core.namedparam.SqlParameterSource;public class JDBCTest &#123; private ApplicationContext ctx = null; private JdbcTemplate jdbcTemplate; private EmployeeDao employeeDao; private DepartmentDao departmentDao; private NamedParameterJdbcTemplate namedParameterJdbcTemplate; &#123; ctx = new ClassPathXmlApplicationContext("applicationContext.xml"); jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate"); employeeDao = ctx.getBean(EmployeeDao.class); departmentDao = ctx.getBean(DepartmentDao.class); namedParameterJdbcTemplate = ctx .getBean(NamedParameterJdbcTemplate.class); &#125; /** * 使用具名参数时，可以使用update(String sql, SqlParameterSource paramSource)方法进行更新操作 * 1.SQL语句中的参数名和类的属性一致 * 2.使用SqlParameterSource 的 BeanPropertySqlParameterSource实现类作为参数。 */ @Test public void testNamedParameterJdbcTemplate2() &#123; String sql = " INSERT INTO employees(last_name,email,dept_id) values(:lastName,:email,:deptId) "; Employee employee = new Employee(); employee.setLastname("ABC"); employee.setEmail("lee@leezp.space"); employee.setDeptId(3); SqlParameterSource paramSource = new BeanPropertySqlParameterSource( employee); namedParameterJdbcTemplate.update(sql, paramSource); &#125; /** * 优点：参数多的时候可以为参数起名字，便于维护 * * 缺点：较为繁琐 * */ @Test public void testNamedParameterJdbcTemplate() &#123; String sql = " INSERT INTO employees(last_name,email,dept_id) values(:ln,:email,:deptid) "; Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put("ln", "FF"); paramMap.put("email", "ff@leezp.space"); paramMap.put("deptid", 2); namedParameterJdbcTemplate.update(sql, paramMap); &#125; // 可以 双击方法名，使其变蓝，右键，run as-&gt; JUnit Test 单独运行这一个测试方法 @Test public void testDepartmentDao() &#123; System.out.println(departmentDao.get(1)); &#125; @Test public void testEmployeeDao() &#123; System.out.println(employeeDao.get(1)); &#125; /** * 获取单个Bean的值，或做统计查询 * * queryForObject(String sql, Class&lt;Long&gt; requiredType) */ @Test public void testQueryForObject2() &#123; String sql = " select count(id) from employees "; long count = jdbcTemplate.queryForObject(sql, Long.class); System.out.println(count); &#125; /** * 查到实体类的集合 * * query(sql, rowMapper, args) */ @Test public void testQueryForList() &#123; String sql = " SELECT id,last_name lastName,email,dept_id From employees where id&gt;? "; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper, 5); System.out.println(employees); &#125; /** * 从数据库中获取一条记录，实际得到对应的一个对象 * * 注意不是调用 queryForObject(String sql, Class&lt;Employee&gt; requiredType, * Object...args)方法 * * 而是调用queryForObject(sql, rowMapper, args)方法。 * * 1.其中的 RowMapper 指定如何去映射结果集的行，常用的实现类为BeanPropertyRowMapper。 * * 2.使用SQL中列的别名完成列名和类的属性名的映射。例如 last_name lastName。 * * 3.不支持级联属性，JdbcTemplate到底是一个JDBC的小工具，而不是ORM框架。 */ // 结果：Employee [id=1, lastname=Tom, email=tom@qq.com, department=null] @Test public void testQueryForObject() &#123; String sql = " SELECT id,last_name lastName,email,dept_id as \"department.id\" From employees where id=? "; // import org.springframework.jdbc.core.RowMapper; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;( Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1); System.out.println(employee); &#125; /** * 执行批量insert/update/delete * * 最后一个参数是 Object[] 的 List 类型: 因为修改一条记录需要一个Object的数组，那么多条不就需要多个Object的数组吗 */ @Test public void testBatchUpdate() &#123; String sql = " INSERT INTO employees(last_name,email,dept_id) values(?,?,?) "; List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); batchArgs.add(new Object[] &#123; "AA", "AA@qq.com", 1 &#125;); batchArgs.add(new Object[] &#123; "BB", "BB@qq.com", 2 &#125;); batchArgs.add(new Object[] &#123; "CC", "CC@qq.com", 3 &#125;); jdbcTemplate.batchUpdate(sql, batchArgs); &#125; /** * 执行 INSERT,UPDATE,DELETE */ @Test public void testUpdate() &#123; String sql = "UPDATE employees SET LAST_NAME=? where ID =? "; jdbcTemplate.update(sql, "Jack", 5); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125; 获取源代码 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（四）Spring AOP]]></title>
      <url>%2Fblog%2F2016%2F08%2F20%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[本节讲述Spring AOP（面向切面编程）。 代理设计模式的原理使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 新建项目 spring-02。在项目下新建包com.leezp.spring.aop.helloworld。在该包下新建ArithmeticCalculator.java接口。 1234567891011package com.leezp.spring.aop.helloworld;public interface ArithmeticCalculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125; 新建接口的实现类ArithmeticCalculatorImpl.java。 12345678910111213141516171819202122232425262728package com.leezp.spring.aop.helloworld;public class ArithmeticCalculatorImpl implements ArithmeticCalculator &#123; @Override public int add(int i, int j) &#123; int res = i + j; return res; &#125; @Override public int sub(int i, int j) &#123; int res = i - j; return res; &#125; @Override public int mul(int i, int j) &#123; int res = i * j; return res; &#125; @Override public int div(int i, int j) &#123; int res = i / j; return res; &#125;&#125; 新建动态代理类ArithmeticCalculatorLoggingProxy.java。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.leezp.spring.aop.helloworld;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/** * 动态代理 * * @author Lee * */public class ArithmeticCalculatorLoggingProxy &#123; // 要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; public ArithmeticCalculator getLoggingproxy() &#123; ArithmeticCalculator proxy = null; // 代理对象由哪一个类加载器负责加载 ClassLoader loader = target.getClass().getClassLoader(); // 代理对象的类型，即其中有哪些方法 Class[] interfaces = new Class[] &#123; ArithmeticCalculator.class &#125;; // 当调用代理对象其中的方法时，该执行的代码 InvocationHandler h = new InvocationHandler() &#123; /** * proxy：正在返回的那个代理对象。一般情况下，在invoke方法中都不使用该对象或该对象的方法， * 防止出现再次调用invoke函数的死循环 ；method:正在被调用的方法 ；args:调用方法时，传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); // 日志 System.out.println("The method " + methodName + " begins with " + Arrays.asList(args)); // 执行方法 Object res = method.invoke(target, args); // 日志 System.out.println("The method " + methodName + " ends with " + res); return res; &#125; &#125;; proxy = (ArithmeticCalculator) Proxy.newProxyInstance(loader, interfaces, h); return proxy; &#125;&#125;``` 新建Main.java。123456789101112131415161718192021222324``` bashpackage com.leezp.spring.aop.helloworld;public class Main &#123; public static void main(String[] args) &#123; /* * ArithmeticCalculator ari = null; ari = new * ArithmeticCalculatorImpl(); */ ArithmeticCalculator target = new ArithmeticCalculatorImpl(); ArithmeticCalculator proxy = new ArithmeticCalculatorLoggingProxy( target).getLoggingproxy(); System.out.println(proxy.getClass().getName());// 打印代理名称 int res = proxy.add(1, 2); System.out.println(res); res = proxy.div(4, 2); System.out.println(res); &#125;&#125; 在控制台观察运行结果。 1234567$Proxy0The method add begins with [1, 2]The method add ends with 33The method div begins with [4, 2]The method div ends with 22 获取源代码 AOP 简介AOP(Aspect-Oriented Programming,面向切面编程):是一种新的方法论，是对传统OOP(Object-Oriented Programming,面向对象编程)的补充。 AOP的主要编程对象是切面(aspect)，而切面模块化横切关注点。 在应用AOP编程时，仍然需要定义公共功能，但可以明确的定义这个功能在哪里，以什么方式应用，并且不必修改受影响的类。这样一来横切关注点就被模块化到特殊的对象（切面）里。 AOP的好处：1.每个事物逻辑位于一个位置，代码不分散，便于维护和升级。2.业务模块更简洁，只包含核心业务代码。 AOP 术语切面(Aspect)：横切关注点（跨越应用程序多个模块的功能）被模块化的特殊对象。 通知(Active)：切面必须要完成的工作。 目标(Target)：被通知的对象。 代理(Proxy)：向目标对象应用通知之后创建的对象。 连接点(Joinpoint)：程序执行的某个特定位置:如类某个方法调用前、调用后、方法抛出异常后等。连接点由两个信息确定：方法表示的程序执行点。相对点表示方位。例如ArithmeticCalculator#add()方法执行前的连接点执行点为ArithmeticCalculator#add()；方位为该方法执行前的位置。 切点(pointcut)：每个类都拥有多个连接点：例如ArithmeticCalculator的所有方法实际上都是连接点，即连接点是程序类中客观存在的事务。AOP通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 AspectJJava社区里最完整最流行的AOP框架。 在Spring2.0以上版本中，可以使用基于AspectJ注解或基于XML配置的AOP。 在Spring中启用AspectJ注解支持要在Spring应用中使用AspectJ注解，必须在classpath下包含AspectJ类库：aopalliance.jar、aspectj.weaver.jar和spring-aspects.jar。 将aop Schema添加到根元素中。 要在Spring IOC容器中启动AspectJ注解支持，只要在Bean配置文件中定义一个空的XML元素。 当Spring IOC容器侦测到Bean配置文件中的元素时，会自动为与AspectJ切面匹配的Bean创建代理。 将下图的jar包添加到lib文件夹下并build path。 要在Spring中声明AspectJ切面，只需要在IOC容器中将切面声明为Bean实例。当在Spring IOC容器中初始化AspectJ切面之后，Spring IOC 容器就会为那些与AspectJ切面相匹配的Bean创建代理。 在AspectJ注解中，切面只是一个带有@Aspect注解的Java类。 新建包com.leezp.spring.aop.impl。在该包下新建接口ArithmeticCalculator.java。 1234567891011package com.leezp.spring.aop.impl;public interface ArithmeticCalculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j);&#125; 新建接口的实现类ArithmeticCalculatorImpl.java。 1234567891011121314151617181920212223242526272829303132package com.leezp.spring.aop.impl;import org.springframework.stereotype.Component;@Componentpublic class ArithmeticCalculatorImpl implements ArithmeticCalculator &#123; @Override public int add(int i, int j) &#123; int res = i + j; return res; &#125; @Override public int sub(int i, int j) &#123; int res = i - j; return res; &#125; @Override public int mul(int i, int j) &#123; int res = i * j; return res; &#125; @Override public int div(int i, int j) &#123; int res = i / j; return res; &#125;&#125; 新建applicationContext.xml并添加beans、aop、context节点。 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;context:component-scan base-package="com.leezp.spring.aop.impl"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 新建Main.java。 123456789101112131415161718package com.leezp.spring.aop.impl;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml"); ArithmeticCalculator arithmeticCalculator = ctx .getBean(ArithmeticCalculator.class); int res = arithmeticCalculator.add(3, 4); System.out.println(res); &#125;&#125; 在控制台观察运行结果。 17 获取源代码 新建一个日志处理的切面LoggingAspect.java。 12345678910111213141516171819202122232425262728293031323334353637383940package com.leezp.spring.aop.impl;import java.util.Arrays;import java.util.List;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;//把这个类声明为一个切面：需要1.把该类放入到IOC容器中@Component;2.声明为一个切面@Aspect@Aspect@Componentpublic class LoggingAspect &#123; // 声明该方法是一个前置通知：在目标方法开始之前执行 // 执行（public 返回值 包名 接口名 方法（参数）） // **还需要在配置文件中加配置&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;使@Before这个注解起作用** // @Before作用：当调用一个目标方法和声明的注解相匹配的时候， // aop框架自动为那个方法所在的类生成一个代理对象， // 在调用目标方法之前，将这句话加进去。 // .*代表接口里的所有方法 @Before("execution(public int com.leezp.spring.aop.impl.ArithmeticCalculator.*(int,int))") public void beforeMethod(JoinPoint joinPoint) &#123; // 连接点 JoinPoint String methodName = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println("The method " + methodName + " begins with" + args); &#125; // 后置通知：在目标方法执行后（无论是否发生异常）执行的通知 // 注意：在后置通知中还不能访问目标方法的执行结果，要在**返回通知**里访问。 @After("execution(public int com.leezp.spring.aop.impl.ArithmeticCalculator.*(int,int))") public void afterMethod(JoinPoint joinPoint) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println("The method " + methodName + " ends"); &#125;&#125; 修改 applicationContext.xml。 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;context:component-scan base-package="com.leezp.spring.aop.impl"&gt;&lt;/context:component-scan&gt; &lt;!-- 在配置文件中加配置使@Before起作用 --&gt; &lt;!-- 使AspectJ注解起作用:自动为匹配的类生成代理对象 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt; 修改Main.java。 12345678910111213141516171819202122package com.leezp.spring.aop.impl;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml"); ArithmeticCalculator arithmeticCalculator = ctx .getBean(ArithmeticCalculator.class); int res = arithmeticCalculator.add(3, 4); System.out.println(res); res = arithmeticCalculator.div(12, 0); System.out.println(res); &#125;&#125;``` 在控制台观察运行结果。123456789101112131415161718192021222324``` bashException in thread &quot;main&quot; java.lang.ArithmeticException: / by zeroThe method add begins with[3, 4]The method add ends7The method div begins with[12, 0] at com.leezp.spring.aop.impl.ArithmeticCalculatorImpl.div(ArithmeticCalculatorImpl.java:28) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.aspectj.AspectJAfterAdvice.invoke(AspectJAfterAdvice.java:43) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207) at $Proxy8.div(Unknown Source) at com.leezp.spring.aop.impl.Main.main(Main.java:17)The method div ends 获取源代码 Spring AOP配置总结1.加入jar包。com.springsource.org.aopalliance-1.0.0.jarcom.springsource.org.aspectj.weaver-1.6.8.RELEASE.jarcommons-logging-1.2.jarspring-aop-4.0.4.RELEASE.jarspring-aspects-4.0.4.RELEASE.jarspring-beans-4.0.4.RELEASE.jarspring-context-4.0.4.RELEASE.jarspring-core-4.0.4.RELEASE.jarspring-expression-4.0.4.RELEASE.jar2.在配置文件中加入aop的命名空间。3.基于注解的方式①.在配置文件中加入如下配置：&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;②.把横切关注点的代码抽象到切面的类中。i.切面首先是一个IOC中的bean，即加入@Component注解ii.切面还需要加入@Aspect注解③.在类中声明各种通知：通知是标注有某种注解的简单的Java方法。一个切面可以包括一个或多个通知。AspectJ支持5种类型的通知注解：——@Before：前置通知，在方法执行之前执行——@After：后置通知，在方法执行之后执行（连接点返回结果或者抛异常的时候，都执行）——@AfterRunning：返回通知，在方法返回结果之后执行——@AfterThrowing：异常通知，在方法抛出异常之后执行——@Around：环绕通知，围绕着方法执行 i.声明一个方法ii.在方法前加一个注解 例如 @Before(“方法签名“), 利用方法签名编写AspectJ切入点表达式：最典型的切入点表达式是根据方法的签名来匹配各种方法：匹配ArithmeticCalculator中声明的所有方法：第一个代表任意修饰符即任意返回值，第二个代表任意方法，“..”代表匹配任意数量的参数。若目标类与接口与该平面在同一个包中，可以省略包名。匹配ArithmeticCalculator接口的所有公共方法。匹配ArithmeticCalculator中返回double类型数值的方法。匹配第一个参数为double类型的方法，”..”匹配任意数量任意类型的参数。匹配参数类型为double，double类型的方法。④.可以在通知方法中声明一个类型 JoinPoint的参数。然后就能访问链接细节，如方法名称和参数值。 AspectJ支持的5种类型的通知注解、设置切面优先级、相同名称切入点的引用的Demo 基于配置文件方式配置AOPcom.leezp.spring.aop包是用注解方式配置AOP。com.leezp.spring.aop.xml包时用配置文件的方式来配置AOP。 获取源代码 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（三）]]></title>
      <url>%2Fblog%2F2016%2F08%2F13%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[在上一节中，我们已经学会了Bean的一些基本配置。 在这一节中，将补充介绍Bean的配置。 沿用上一节的项目。 Bean的其他配置方法配置Bean之方法二工厂方法通过调用静态工厂方法创建Bean调用静态工厂方法创建Bean是将对象创建的过程封装到静态方法中。当客户端需要对象时，只需要简单地调用静态方法，而不用关心创建对象的细节。 要声明通过静态方法创建的Bean1.在Bean的class属性里指定拥有该工厂方法的类2.在factory-method属性里指定工厂方法的名称3.使用&lt;constructor-arg&gt;元素为该方法传递方法参数。 在src下新建包com.leezp.spring.beans.factory。 在该包下新建Car.java。 12345678910111213141516171819202122232425262728293031323334package com.leezp.spring.beans.factory;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", price=" + price + "]"; &#125; public Car(String brand, double price) &#123; super(); this.brand = brand; this.price = price; &#125;&#125; 新建StaticCarFactory.java。 12345678910111213141516171819202122232425package com.leezp.spring.beans.factory;import java.util.HashMap;import java.util.Map;/** * 静态工厂方法：直接调用某一个类的静态方法就可以返回Bean的实例 * * @author Lee * */public class StaticCarFactory &#123; private static Map&lt;String, Car&gt; cars = new HashMap&lt;String, Car&gt;(); static &#123; cars.put("audi", new Car("audi", 300000)); cars.put("ford", new Car("ford", 400000)); &#125; public static Car getCar(String name) &#123; return cars.get(name); &#125;&#125;``` 新建beans-factory.xml配置文件。123456789101112131415``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 通过静态工厂方法来配置Bean。注意不是配置静态工厂方法实例，而是配置Bean实例 --&gt; &lt;!-- class属性：指向静态工厂方法的全类名；factory-method:指向静态工厂方法的名字； constructor-arg:如果工厂方法需要传入参数，则使用constructor-arg 来配置参数 --&gt; &lt;bean id=&quot;car1&quot; class=&quot;com.leezp.spring.beans.factory.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt; &lt;constructor-arg value=&quot;audi&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt;``` 新建Main.java。12345678910111213141516``` bashpackage com.leezp.spring.beans.factory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-factory.xml&quot;); Car car1 = (Car) ctx.getBean(&quot;car1&quot;);新建beans-beanfactory.xml配置文件。 System.out.println(car1); &#125;&#125;``` 在控制台观察运行结果。123``` bashCar [brand=audi, price=300000.0]``` 通过调用实例工厂方法创建Bean实例工厂方法：将对象的创建过程封装到另外一个对象实例的方法里。当客户端需要请求对象时，只需要简单的调用该实例方法而不需要关心对象的创建细节。 要声明通过实例工厂方法创建的Bean1.在bean的factory-bean属性里指定拥有该工厂方法的Bean。2.在factory-method属性里指定该工厂方法的名称。3.使用constructor-arg元素为工厂方法传递方法参数。 新建InstanceCarFactory.java。12345678910111213141516171819202122232425``` bashpackage com.leezp.spring.beans.factory;import java.util.HashMap;import java.util.Map;/** * 实例工厂方法：实例工厂的方法，即先需要创建工厂本身，再调用工厂的实例方法 * * @author Lee * */public class InstanceCarFactory &#123; private Map&lt;String, Car&gt; cars = null; public InstanceCarFactory() &#123; cars = new HashMap&lt;String, Car&gt;(); cars.put(&quot;audi&quot;, new Car(&quot;audi&quot;, 400000)); cars.put(&quot;ford&quot;, new Car(&quot;ford&quot;, 300000)); &#125; public Car getCar(String brand) &#123; return cars.get(brand); &#125;&#125; 修改beans-factory.xml配置文件。 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 通过静态工厂方法来配置Bean。注意不是配置静态工厂方法实例，而是配置Bean实例 --&gt; &lt;!-- class属性：指向静态工厂方法的全类名；factory-method:指向静态工厂方法的名字； constructor-arg:如果工厂方法需要传入参数，则使用constructor-arg 来配置参数 --&gt; &lt;bean id="car1" class="com.leezp.spring.beans.factory.StaticCarFactory" factory-method="getCar"&gt; &lt;constructor-arg value="audi"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- Invalid bean definition with name 'car2' defined in class path resource [beans-factory.xml]: factory-bean reference points back to the same bean definition --&gt; &lt;!-- 配置工厂的实例 --&gt; &lt;bean id="carFactory" class="com.leezp.spring.beans.factory.InstanceCarFactory"&gt;&lt;/bean&gt; &lt;bean id="car2" factory-bean="carFactory" factory-method="getCar"&gt; &lt;constructor-arg value="audi"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 修改Main.java。 123456789101112131415161718package com.leezp.spring.beans.factory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "beans-factory.xml"); Car car1 = (Car) ctx.getBean("car1"); System.out.println(car1); Car car2 = (Car) ctx.getBean("car2"); System.out.println(car2); &#125;&#125; 在控制台观察运行结果。 123Car [brand=audi, price=300000.0]Car [brand=audi, price=400000.0]``` 获取源代码 配置Bean之方法三FactoryBean新建包com.leezp.spring.beans.factorybean。 在该包下新建Car.java。123456789101112131415161718192021222324252627282930313233343536``` bashpackage com.leezp.spring.beans.factorybean;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;; &#125; public Car(String brand, double price) &#123; super(); this.brand = brand; this.price = price; &#125;&#125;``` 新建CarFactoryBean.java。123456789101112131415161718192021222324252627282930313233``` bashpackage com.leezp.spring.beans.factorybean;import org.springframework.beans.factory.FactoryBean;//自定义的FactoryBean需要实现 FactoryBean 接口public class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; private String brand; public void setBrand(String brand) &#123; this.brand = brand; &#125; // 返回Bean的对象 @Override public Car getObject() throws Exception &#123; return new Car(&quot;BMW&quot;, 500000); &#125; // 返回bean的类型 @Override public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; // 是否为单实例 @Override public boolean isSingleton() &#123; return true; &#125;&#125; 新建beans-beanfactory.xml配置文件。 1234567891011121314151617181920212223242526272829303132package com.leezp.spring.beans.factorybean;import org.springframework.beans.factory.FactoryBean;//自定义的FactoryBean需要实现 FactoryBean 接口public class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; private String brand; public void setBrand(String brand) &#123; this.brand = brand; &#125; // 返回Bean的对象 @Override public Car getObject() throws Exception &#123; return new Car("BMW", 500000); &#125; // 返回bean的类型 @Override public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; // 是否为单实例 @Override public boolean isSingleton() &#123; return true; &#125;&#125; 新建Main.java。 123456789101112131415package com.leezp.spring.beans.factorybean;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "beans-beanfactory.xml"); Car c = (Car) ctx.getBean("car"); System.out.println(c); &#125;&#125;``` 在控制台观察运行结果。123``` bashCar [brand=BMW, price=500000.0]``` 获取源代码 Bean的第二种配置形式——基于注解的方式spring从2.5版本开始支持注解注入，注解注入可以省去很多的xml配置工作。由于注解是写入java代码中的，所以注解注入会失去一定的灵活性，我们要根据需要来选择是否启用注解注入。 在classpath中扫描组件组件扫描（component scanning）:Spring能够从classpath下自动扫描，侦测和实例化具有特定注解的组件。 特定组件包括：1.@Component:基本注解，标识了一个受Spring管理的组件2.@Repository:标识持久层组件(可将DAO类声明为Bean )3.@Service：标识服务层（业务层）组件4.@Controller:标识表现层组件 对于扫描到的组件，Spring有默认的命名策略：使用非限定类名，第一个字母小写。也可以在注解中通过value属性值标识组件的名称。 当在组件类上使用了特定的注解之后，还需要在Spring的配置文件中声明&lt;context:component-scan&gt;:1.base-package属性指定一个需要扫描的基类包，Spring容器将会扫描这个基类包里及其子包中的所有类。2.当需要扫描多个包时，可以使用逗号分隔。3.如果仅希望扫描特定的类而非基包下的所有类，可使用resource-pattern属性过滤特定的类，示例：1234``` bash&lt;context:component-scan base-package=&quot;com.leezp.spring.beans&quot; resource-pattern=&quot;autowire/*.class&quot; /&gt;``` 4.&lt;context:include-filter&gt;子节点表示要包含的目标类。5.&lt;context:exclude-filter&gt;子节点表示要排除在外的目标类。6.&lt;context:component-scan&gt;下可以拥有若干个&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子节点。&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子节点支持多种类型的过滤表达式： filter标签的type和表达式说明如下图。annotation:所有标注了XxxAnnotation的类。该类型采用目标类是否标注了某个注解进行过滤。assinable:所有继承或扩展XxxService的类。该类型采用目标类是否继承或扩展某个特定类进行过滤。aspectj:所有类名以Service结束的类及继承或扩展它们的类。该类型采用aspectj表达式进行过滤。regex:示例：com.\leezp.anno_*:所有com.leezp.anno包下的类。该类型采用正则表达式根据类的类名进行过滤custom:采用XxxTypeFilter通过代码的方式定义过滤规则。该类必须实现org.springframework.core.type.TypeFilter接口。 新建包com.leezp.spring.beans.annotation。 在该包下新建TestObject.java。1234567891011``` bashpackage com.leezp.spring.beans.annotation;import org.springframework.stereotype.Component;// 只加了@Component以后项目名称右上角还没有&quot;S&quot;的小标签，说明还没有被Spring管理,还要建立Spring配置文件才可以@Componentpublic class TestObject &#123;&#125;``` 新建包com.leezp.spring.beans.annotation.controller。 在该包下新建UserController.java。12345678910111213``` bashpackage com.leezp.spring.beans.annotation.controller;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; public void execute() &#123; System.out.println(&quot;UserController execute...&quot;); &#125;&#125;``` 新建包com.leezp.spring.beans.annotation.repository。 在该包下新建UserRepository.java接口。12345678``` bashpackage com.leezp.spring.beans.annotation.repository;public interface UserRepository &#123; void save();&#125;``` 在该包下新建UserRepository接口的实现类UserRepositoryImpl.java。123456789101112131415``` bashpackage com.leezp.spring.beans.annotation.repository;import org.springframework.stereotype.Repository;@Repository(&quot;userRepository&quot;)public class UserRepositoryImpl implements UserRepository &#123; @Override public void save() &#123; System.out.println(&quot;UserRepository Save...&quot;); &#125;&#125;``` 新建包com.leezp.spring.beans.annotation.service。 在该包下新建业务类UserService.java。12345678910111213``` bashpackage com.leezp.spring.beans.annotation.service;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; public void add() &#123; System.out.println(&quot;UserService add...&quot;); &#125;&#125;``` 新建beans-annotation.xml配置文件。123456789101112131415161718192021222324252627282930313233343536``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 指定SpringIOC容器扫描的包 --&gt; &lt;!-- 加上下面这个配置以后项目名称右上角出现&quot;S&quot;的小标签，说明已被Spring管理 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt;&lt;/context:component-scan&gt; --&gt; &lt;!-- 可以通过resource-pattern指定扫描的资源 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; resource-pattern=&quot;repository/*.class&quot;&gt;&lt;/context:component-scan&gt; --&gt; &lt;!-- context:exclude-filter子节点指定排除哪些指定表达式的组件 ,将不想包含的包粘贴进来 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- context:include-filter子节点指定包含哪些表达式的组件，该子节点需要设置use-default-filters=&quot;false&quot; --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- 不包含UserRepository接口和这个接口所有实现类 --&gt; &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt; &lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.leezp.spring.beans.annotation.repository.UserRepository&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.leezp.spring.beans.annotation.repository.UserRepository&quot; /&gt; &lt;/context:component-scan&gt; --&gt;&lt;/beans&gt; 在com.leezp.spring.beans.annotation包下新建Main.java。 12345678910111213141516171819202122232425262728293031323334353637383940package com.leezp.spring.beans.annotation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.annotation.controller.UserController;import com.leezp.spring.beans.annotation.repository.UserRepository;import com.leezp.spring.beans.annotation.repository.UserRepositoryImpl;import com.leezp.spring.beans.annotation.service.UserService;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "beans-annotation.xml"); // java.lang.ClassNotFoundException: // org.springframework.aop.TargetSource // 这个异常是因为缺少jar包，只需导入spring-aop-4.0.4.RELEASE.jar即可。 TestObject to = (TestObject) ctx.getBean("testObject"); System.out.println(to); UserController u = (UserController) ctx.getBean("userController"); System.out.println(u); UserService us = (UserService) ctx.getBean("userService"); System.out.println(us); /* * UserRepository ur = (UserRepository) ctx.getBean("userRepository"); * System.out.println(ur); */ /* * UserRepositoryImpl xxx = (UserRepositoryImpl) ctx * .getBean("userRepository"); System.out.println(xxx); */ &#125;&#125;``` 这里可能还需要一个Spring的jar包spring-aop-4.0.4.RELEASE.jar，点击下载spring-framework-4.0.4.RELEASE.rar（Spring所需jar包），在里面找到这个jar包添加到项目中并且build path。缺少这个jar包可能报出java.lang.ClassNotFoundException:org.springframework.aop.TargetSource错误。在控制台观察运行结果。12345``` bashcom.leezp.spring.beans.annotation.TestObject@3e431f96com.leezp.spring.beans.annotation.controller.UserController@28ced0c9com.leezp.spring.beans.annotation.service.UserService@21ed510d``` 获取源代码 利用注解来建立Bean之间的引用关系有时候Bean之间是有关联关系的。我们先来建立Bean之间的关联关系，再来研究如何利用注解来建立Bean之间的引用关系。 修改beans-annotation.xml配置文件。123456789101112131415161718192021222324252627282930313233343536``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 指定SpringIOC容器扫描的包 --&gt; &lt;!-- 加上下面这个配置以后项目名称右上角出现&quot;S&quot;的小标签，说明已被Spring管理 --&gt; &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 可以通过resource-pattern指定扫描的资源 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; resource-pattern=&quot;repository/*.class&quot;&gt;&lt;/context:component-scan&gt; --&gt; &lt;!-- context:exclude-filter子节点指定排除哪些指定表达式的组件 ,将不想包含的包粘贴进来 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- context:include-filter子节点指定包含哪些表达式的组件，该子节点需要设置use-default-filters=&quot;false&quot; --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- 不包含UserRepository接口和这个接口所有实现类 --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot;&gt; &lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.leezp.spring.beans.annotation.repository.UserRepository&quot; /&gt; &lt;/context:component-scan&gt; --&gt; &lt;!-- &lt;context:component-scan base-package=&quot;com.leezp.spring.beans.annotation&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.leezp.spring.beans.annotation.repository.UserRepository&quot; /&gt; &lt;/context:component-scan&gt; --&gt;&lt;/beans&gt;``` 修改UserController.java。123456789101112131415161718``` bashpackage com.leezp.spring.beans.annotation.controller;import org.springframework.stereotype.Controller;import com.leezp.spring.beans.annotation.service.UserService;@Controllerpublic class UserController &#123; private UserService userService; public void execute() &#123; System.out.println(&quot;UserController execute...&quot;); userService.add(); &#125;&#125;``` 修改UserService.java。12345678910111213141516171819202122``` bashpackage com.leezp.spring.beans.annotation.service;import org.springframework.stereotype.Service;import com.leezp.spring.beans.annotation.repository.UserRepository;@Servicepublic class UserService &#123; private UserRepository userRepository; public void setUserRepository(UserRepository userRepository) &#123; this.userRepository = userRepository; &#125; public void add() &#123; System.out.println(&quot;UserService add...&quot;); userRepository.save(); &#125;&#125;``` 修改Main.java。12345678910111213141516171819202122232425262728293031323334353637383940414243444546``` bashpackage com.leezp.spring.beans.annotation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.annotation.controller.UserController;import com.leezp.spring.beans.annotation.repository.UserRepository;import com.leezp.spring.beans.annotation.repository.UserRepositoryImpl;import com.leezp.spring.beans.annotation.service.UserService;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-annotation.xml&quot;); // java.lang.ClassNotFoundException: // org.springframework.aop.TargetSource // 这个异常是因为缺少jar包，只需导入spring-aop-4.0.4.RELEASE.jar即可。 /* * TestObject to = (TestObject) ctx.getBean(&quot;testObject&quot;); * System.out.println(to); */ UserController u = (UserController) ctx.getBean(&quot;userController&quot;); System.out.println(u); u.execute(); /* * UserService us = (UserService) ctx.getBean(&quot;userService&quot;); * System.out.println(us); */ /* * UserRepository ur = (UserRepository) ctx.getBean(&quot;userRepository&quot;); * System.out.println(ur); */ /* * UserRepositoryImpl xxx = (UserRepositoryImpl) ctx * .getBean(&quot;userRepository&quot;); System.out.println(xxx); */ &#125;&#125;``` 在控制台观察运行结果。1234567``` bashcom.leezp.spring.beans.annotation.controller.UserController@e28adfbUserController execute...Exception in thread &quot;main&quot; java.lang.NullPointerException at com.leezp.spring.beans.annotation.controller.UserController.execute(UserController.java:14) at com.leezp.spring.beans.annotation.Main.main(Main.java:27)``` 发现报错了。这个错误是因为属性没有被装配。 &lt;context:component-scan&gt;元素还会自动注册AutowiredAnnotationBeanPostProcessor（后置处理器）实例，该实例可以自动装配具有@Autowired和@Resource、@Inject注解的属性。 使用@Autowired自动装配Bean@Autowired注解自动装配具有兼容类型的单个Bean属性。1.构造器，普通字段（即使是非public），一切具有参数的方法（set方法上面）都可以应用@Autowired注解。 给UserController.java添加注解@Autowired。12345678910111213141516171819``` bashpackage com.leezp.spring.beans.annotation.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import com.leezp.spring.beans.annotation.service.UserService;@Controllerpublic class UserController &#123; @Autowired private UserService userService; public void execute() &#123; System.out.println(&quot;UserController execute...&quot;); userService.add(); &#125;&#125;``` 给UserService.java添加注解@Autowired。12345678910111213141516171819202122232425``` bashpackage com.leezp.spring.beans.annotation.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.leezp.spring.beans.annotation.repository.UserRepository;@Servicepublic class UserService &#123; // @Autowired//构造器，普通字段（即使是非public)都可以应用@Autowired注解 private UserRepository userRepository; @Autowired // 一切具有参数的方法（set方法上面）都可以应用@Autowired注解 public void setUserRepository(UserRepository userRepository) &#123; this.userRepository = userRepository; &#125; public void add() &#123; System.out.println(&quot;UserService add...&quot;); userRepository.save(); &#125;&#125;``` 在控制台观察运行结果。123456``` bashcom.leezp.spring.beans.annotation.controller.UserController@730d27f7UserController execute...UserService add...UserRepository Save...``` 2.默认情况下，所有使用@Autowired注解的属性都需要被设置，当Spring找不到匹配的Bean装配属性时，会抛出异常，若某一属性允许不被设置，可以设置@Autowired注解的required属性为false。 修改UserRepositoryImpl.java添加关联关系TestObject。123456789101112131415161718192021``` bashpackage com.leezp.spring.beans.annotation.repository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import com.leezp.spring.beans.annotation.TestObject;@Repository(&quot;userRepository&quot;)public class UserRepositoryImpl implements UserRepository &#123; @Autowired private TestObject testObject; @Override public void save() &#123; System.out.println(&quot;UserRepository Save...&quot;); System.out.println(testObject); &#125;&#125;``` 在控制台观察运行结果。1234567``` com.leezp.spring.beans.annotation.controller.UserController@64bb0423UserController execute...UserService add...UserRepository Save...com.leezp.spring.beans.annotation.TestObject@320cc97f``` 修改TestObject.java去掉@Component使Spring找不到匹配的Bean装配属性。12345678910``` bashpackage com.leezp.spring.beans.annotation;import org.springframework.stereotype.Component;// 只加了@Component以后项目名称右上角还没有&quot;S&quot;的小标签，说明还没有被Spring管理,还要建立Spring配置文件才可以public class TestObject &#123;&#125; 在控制台观察运行结果发现报错：No qualifying bean of type 修改UserRepositoryImpl.java改为@Autowired(required=false)。 12345678910111213141516import org.springframework.stereotype.Repository;import com.leezp.spring.beans.annotation.TestObject;@Repository("userRepository")public class UserRepositoryImpl implements UserRepository &#123; @Autowired(required=false) private TestObject testObject; @Override public void save() &#123; System.out.println("UserRepository Save..."); System.out.println(testObject); &#125;&#125; 在控制台观察运行结果。 123456com.leezp.spring.beans.annotation.controller.UserController@27cacbd9UserController execute...UserService add...UserRepository Save...null``` 3.默认情况下，当IOC容器里存在多个类型兼容的Bean时，通过类型的自动装配将无法工作，此时可以在@Qualifier注解里提供Bean的名称，Spring允许对方法的入参标注@Qualifier已指定注入Bean的名称。 @Qualifier(“XXX”) 中的 XX是 Bean 的名称，所以 @Autowired 和@Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。 百度百科 @Qualifier 在包com.leezp.spring.beans.annotation.repository下新建类UserJdbcRepository.java。1234567891011121314``` bashpackage com.leezp.spring.beans.annotation.repository;import org.springframework.stereotype.Repository;@Repositorypublic class UserJdbcRepository implements UserRepository&#123; @Override public void save() &#123; System.out.println(&quot;UserJdbcRepository save...&quot;); &#125;&#125; 此时即为多个相同类型的bean 解决方法一：@Repository() 括号里的Bean的名字刚好是首字母小写的属性名，即与属性名对应。 解决方法二：@Qualifier注解指定装配哪一个指定的bean。 修改UserService.java。 1234567891011121314151617181920212223242526272829303132333435package com.leezp.spring.beans.annotation.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import com.leezp.spring.beans.annotation.repository.UserRepository;@Servicepublic class UserService &#123; // @Autowired//构造器，普通字段（即使是非public)都可以应用@Autowired注解 private UserRepository userRepository; /* * @Autowired * //@Qualifier使用方式一 * @Qualifier("userRepositoryImpl") // 一切具有参数的方法（set方法上面）都可以应用@Autowired注解 * public void setUserRepository(UserRepository userRepository) &#123; * this.userRepository = userRepository; &#125; */ @Autowired //@Qualifier使用方式二 // 一切具有参数的方法（set方法上面）都可以应用@Autowired注解 public void setUserRepository( @Qualifier("userRepositoryImpl") UserRepository userRepository) &#123; this.userRepository = userRepository; &#125; public void add() &#123; System.out.println("UserService add..."); userRepository.save(); &#125;&#125;``` 4.@Autowired注解也可以应用在数组类型的属性上，此时Spring将会把所有匹配的Bean进行自动装配。5.@Autowired注解也可以应用在集合属性上，此时Spring读取该集合的类型信息，然后自动装配所有与之兼容的Bean。6.@Autowired注解用在java.util.Map上时，若该Map的键值为Spring，那么Spring将自动装配与之Map值类型兼容的Bean，此时Bean的名称作为健值。 使用@Resource或@Inject自动装配Bean1.Spring还支持@Resource和@Inject注解，这两个注解和@Autowired注解的功用类似。2.@Resource注解要求提供一个Bean名称的属性，若该属性为空，则自动采用标注处的变量或方法名作为Bean的名称。3.@Inject和@Autowired注解一样也是按类型匹配注入的Bean，但没有required属性。4.建议使用@Autowired注解。 获取源代码 Spring4.x 新特性： 泛型依赖注入Spring 4.x中可以为子类注入子类对应的泛型类型的成员变量的引用。通俗一点来说：两个子类之间的依赖关系不需要在子类中去声明，而是在父类中进行了声明，而依赖的纽带就是 泛型类型，必须是相同的父类泛型类型才具有依赖关系。 新建包com.leezp.spring.beans.generic.di。在该包下新建BaseRepository.java。123456``` bashpackage com.leezp.spring.beans.generic.di;public class BaseRepository&lt;T&gt; &#123;&#125; 在该包下新建BaseService.java。 1234567891011121314package com.leezp.spring.beans.generic.di;import org.springframework.beans.factory.annotation.Autowired;public class BaseService&lt;T&gt; &#123; @Autowired //在这里加注解会被子类继承 protected BaseRepository&lt;T&gt; repository; public void add() &#123; System.out.println("add..."); System.out.println(repository); &#125;&#125; 新建UserRepository.java。 123456789package com.leezp.spring.beans.generic.di;import org.springframework.stereotype.Repository;@Repositorypublic class UserRepository extends BaseRepository&lt;User&gt;&#123;&#125;``` 新建UserService.java。12345678910``` bashpackage com.leezp.spring.beans.generic.di;import org.springframework.stereotype.Service;@Servicepublic class UserService extends BaseService&lt;User&gt;&#123;&#125;``` 新建User.java。123456``` bashpackage com.leezp.spring.beans.generic.di;public class User&#123;&#125; 新建Main.java。 1234567891011121314package com.leezp.spring.beans.generic.di;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "beans-generic-di.xml"); UserService us = (UserService) ctx.getBean("userService"); us.add(); &#125;&#125; 在控制台观察运行结果。 12add...com.leezp.spring.beans.generic.di.UserRepository@690a614 在以上的代码中，BaseService中引用了BaseRepository，并且在BaseService的add方法中调用了BaseRepository的add方法在他们的子类中，继承了这种关系，因此我们在测试方法中调用userService.add(); 也是可以成功地调用UserRepository中的add方法。获取源代码参考文献Spring jar包详解 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0（二）Bean的配置]]></title>
      <url>%2Fblog%2F2016%2F08%2F01%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[在上一节中，我们已经学会了用Eclipse配置Spring4.0环境并创建一个简单的Spring项目。 在这一节中，将介绍Bean的配置。 本教程使用方法从前向后阅读，本文较长，建议分9次学完，每次下载当前的代码。 配置形式基于xml文件的方式，基于注解的方式。 Bean的配置方法通过全类名（反射）、通过工厂方法（静态工厂方法和实例工厂方法）、FactoryBean IOC 容器 BeanFactory 和ApplicationContext 概述在SpringIOC容器读取Bean配置创建Bean实例之前，必须对它进行实例化。只有在容器实例化后，才可以从IOC容器里获取Bean实例并使用。 Spring 提供了两种类型的IOC容器实现。 BeanFactoryIOC容器的基本实现。BeanFactory是Spring 框架的基础设施，面向Spring本身。 ApplicationContext提供了更多高级的特性，是BeanFactory的子接口。ApplicationContext 面向使用Spring框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的BeanFactory。 无论使用何种方式，配置文件是相同的。 ApplicationContext的主要实现类：（Ctrl+T查看）-ClassPathXmlApplicationContext：从类路径下加载配置文件-FileSystemXmlApplicationContext:从文件系统中加载配置文件 ApplicationContext 的子接口ConfigurableApplicationContext,新增加两个主要方法：refresh()和 close(),让ApplicationContext具有启动、刷新和关闭上下文的能力。 ApplicationContext在 初始化上下文 时就 实例化所有单例的Bean。 WebApplicationContext 是专为WEB应用而准备的，它允许从相对于WEB根目录的路径中完成初始化工作。 ApplicationContext的getBean()方法鼠标放在”ApplicationContext”上按住Ctrl 点击进入 ，Window-&gt; show view-&gt; outline 查看方法，其中没有getBean()方法，找到其父接口 ListableBeanFactory ，Ctrl+shit+T 搜索这个父接口，继续用 outline观察它的方法，其中没有getBean()方法，发现它继承了BeanFactory ，继续搜索这个父接口，观察它的方法，找到了getBean()方法。 依赖注入的方式属性注入；构造器注入;工厂方法注入（不推荐） 属性注入属性注入即通过setter 方法注入Bean的属性值或依赖的对象。 属性注入使用元素，使用name 属性指定Bean的属性名称，value属性或子节点指定属性值。 属性注入是实际应用中最常用的注入方式。 构造方法注入构造方法注入属性值或依赖的对象，它保证了Bean实例在实例化以后就可以使用。 构造器注入在&lt;constructor-arg&gt;元素里声明属性，&lt;constructor-arg&gt;中没有name属性。 沿用上一节中的项目。新建一个类 Car.java。 12345678910111213141516171819202122232425262728package com.leezp.spring.beans;public class Car &#123; private String brand; private String corp; private double price; private int maxSpeed; public Car(String brand, String corp, int maxSpeed) &#123; super(); this.brand = brand; this.corp = corp; this.maxSpeed = maxSpeed; &#125; public Car(String brand, String corp, double price) &#123; super(); this.brand = brand; this.corp = corp; this.price = price; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", corp=" + corp + ", price=" + price + ", maxSpeed=" + maxSpeed + "]"; &#125;&#125; 配置 applicationContext.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id="helloWorld" class="com.leezp.spring.beans.HelloWorld"&gt;&lt;!-- 反射 --&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id="car" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Audi" index="0"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="ShangHai" index="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="100000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id="car2" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Baoma" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="int"&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 修改 Main.java 1234567891011121314151617181920212223242526272829303132package com.leezp.spring.beans;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.Car;public class Main &#123; public static void main(String[] args) &#123; /* * // 创建 HelloWorld 的一个对象 HelloWorld helloWorld = new HelloWorld(); * // 为name 属性赋值 helloWorld.setName("lee"); */ // 1. 创建Spring 的IOC 容器对象 // ApplicationContext代表IOC 容器 ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml");// 创建对象时即调用它的set方法对属性赋值 // 2. 从IOC容器中获取Bean实例 // HelloWorld helloWorld = (HelloWorld) ctx.getBean("helloWorld"); // HelloWorld helloWorld = ctx.getBean(HelloWorld.class);//这样做有缺点，配置多个 // bean的时候它不知道访问哪一个，只适用于单个bean // 调用hello方法 // helloWorld.hello(); Car car = (Car) ctx.getBean("car"); System.out.println(car); Car car2 = (Car) ctx.getBean("car2"); System.out.println(car2); &#125;&#125; 运行，在控制台观察结果。 1234HelloWorld's ConstructorsetName:SpringCar [brand=Audi, corp=ShangHai, price=100000.0, maxSpeed=0]Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260] 获取源代码 注入属性值细节可以用字符串表示的值，可以通过元素标签value属性进行注入。若字面值中包含特殊字符，可以使用&lt;![CDATA[]]&gt;把字面值包裹起来。基本数据类型及其封装类、String等类型都可以采取字面值注入的方式，可以自动类型转换。 null值和级联属性可以使用专用的元素标签为Bean的字符串或其他对象类型的属性注入null值（意义不大，因为引用类型默认null）。 为级联属性赋值和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。具体见后面程序applicationContext.xml中的例子。 引用其他bean组成应用程序的Bean经常需要相互协作以完成应用程序的功能，要使Bean能够相互访问，就必须在Bean配置文件中指定对Bean的引用。 在Bean的配置文件中，可以通过元素（标签节点）或ref属性为Bean的属性或构造器参数指定对Bean的引用。 也可以在属性或构造器里包含Bean的声明，这样的Bean称为内部Bean。 新建一个类Person.java。 12345678910111213141516171819202122232425262728293031323334353637383940package com.leezp.spring.beans;public class Person &#123; private String name; private int age; private Car car; public Person() &#123; // TODO Auto-generated constructor stub &#125; public Person(String name, int age, Car car) &#123; super(); this.name = name; this.age = age; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", car=" + car + "]"; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125;&#125; 修改 Car.java。 12345678910111213141516171819202122232425262728293031323334353637package com.leezp.spring.beans;public class Car &#123; private String brand; private String corp; private double price; private int maxSpeed; public Car(String brand, String corp, int maxSpeed) &#123; super(); this.brand = brand; this.corp = corp; this.maxSpeed = maxSpeed; &#125; public Car(String brand, String corp, double price) &#123; super(); this.brand = brand; this.corp = corp; this.price = price; &#125; @Override public String toString() &#123; return "Car [brand=" + brand + ", corp=" + corp + ", price=" + price + ", maxSpeed=" + maxSpeed + "]"; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125;&#125;``` 修改applicationContext.xml配置文件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.leezp.spring.beans.HelloWorld&quot;&gt;&lt;!-- 反射 --&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;100000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Baoma&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;int&quot;&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car2&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;car&quot;&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;constructor-arg value=&quot;Jerry&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;25&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name=&quot;car.price&quot; value=&quot;300000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 修改Main.java。 1234567891011121314151617181920212223242526272829303132333435363738package com.leezp.spring.beans;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.Person;import com.leezp.spring.beans.Car;public class Main &#123; public static void main(String[] args) &#123; /* * // 创建 HelloWorld 的一个对象 HelloWorld helloWorld = new HelloWorld(); // * 为name 属性赋值 helloWorld.setName("lee"); */ // 1. 创建Spring 的IOC 容器对象 // ApplicationContext代表IOC 容器 ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml");// 创建对象时即调用它的set方法对属性赋值 // 2. 从IOC容器中获取Bean实例 // HelloWorld helloWorld = (HelloWorld) ctx.getBean("helloWorld"); // HelloWorld helloWorld = ctx.getBean(HelloWorld.class);//这样做有缺点，配置多个 // bean的时候它不知道访问哪一个，只适用于单个bean // 调用hello方法 // helloWorld.hello(); Car car = (Car) ctx.getBean("car"); System.out.println(car); Car car2 = (Car) ctx.getBean("car2"); System.out.println(car2); Person p = (Person) ctx.getBean("person"); System.out.println(p); Person p2 = (Person) ctx.getBean("person2"); System.out.println(p2); &#125;&#125; 在控制台观察运行结果。 123456HelloWorld's ConstructorsetName:SpringCar [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260]Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]Person [name=Tom, age=24, car=Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=260]]Person [name=Jerry, age=25, car=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260]] 获取源代码 集合属性在Spring中可以通过一组内置的xml标签（例如：&lt;list&gt;,&lt;set&gt;或&lt;map&gt;来配置集合属性）。 配置java.util.List类型的属性，需要指定&lt;list&gt;标签，在标签里包含一些元素，这些标签可以通过&lt;value&gt;指定简单的常量值，通过&lt;ref&gt;指定对其他Bean的引用。通过&lt;bean&gt;指定内置Bean的定义。通过&lt;null/&gt;指定空元素，甚至可以内嵌其他集合。 数组的定义和List一样，都使用&lt;list&gt;。 配置java.util.Set需要使用&lt;set&gt;标签，定义元素的方法与List一样。 新建一个包命名为com.leezp.spring.beans.collections。 在该包下新建一个类 Person.java。 12345678910111213141516171819202122232425262728293031323334353637383940package com.leezp.spring.beans.collections;import java.util.List;import com.leezp.spring.beans.Car;public class Person &#123; private String name; private int age; private List&lt;Car&gt; cars; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public List&lt;Car&gt; getCars() &#123; return cars; &#125; public void setCars(List&lt;Car&gt; cars) &#123; this.cars = cars; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", cars=" + cars + "]"; &#125;&#125;``` 在该包下新建一个类Main.java。12345678910111213141516``` bashpackage com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); Person p = (Person) ctx.getBean(&quot;person3&quot;); System.out.println(p); &#125;&#125; 修改applicationContext.xml配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id="helloWorld" class="com.leezp.spring.beans.HelloWorld"&gt;&lt;!-- 反射 --&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id="car" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Audi" index="0"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="ShangHai" index="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="100000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id="car2" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Baoma" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="int"&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="person" class="com.leezp.spring.beans.Person"&gt; &lt;property name="name" value="Tom"&gt;&lt;/property&gt; &lt;property name="age" value="24"&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name="car" ref="car2"&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name="car"&gt; &lt;ref bean="car2" /&gt; &lt;/property&gt; --&gt; &lt;property name="car"&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="Changan"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name="car.maxSpeed" value="260"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="person2" class="com.leezp.spring.beans.Person"&gt; &lt;constructor-arg value="Jerry"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="25"&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name="car.price" value="300000"&gt;&lt;/property&gt; &lt;property name="car.maxSpeed" value="260"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id="person3" class="com.leezp.spring.beans.collections.Person"&gt; &lt;property name="name" value="lee"&gt;&lt;/property&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;property name="cars"&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean="car" /&gt; &lt;ref bean="car2" /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="Changan"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 在控制台观察运行结果。12345``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]``` 获取源代码Java.util.Map通过&lt;map&gt;标签定义，&lt;map&gt;标签里可以使用多个&lt;entry&gt;作为子标签，每个条目包含一个键和一个值。 必须在&lt;key&gt;标签里定义键。 因为键和值的类型没有限制，所以可以自由地为它们指定&lt;value&gt;,&lt;ref&gt;,&lt;bean&gt;或&lt;null&gt;元素。 可以将Map的键和值作为&lt;entry&gt;的属性定义：简单常量使用key和value来定义；Bean引用通过key-ref和value-ref属性定义。 使用&lt;props&gt;定义java.util.Properties,该标签使用多个&lt;prop&gt;作为子标签，每个&lt;prop&gt;标签必须定义key属性。 在该包下新建一个类 NewPerson.java。123456789101112131415161718192021222324252627282930313233343536373839404142``` bashpackage com.leezp.spring.beans.collections;import java.util.Map;import com.leezp.spring.beans.Car;public class NewPerson &#123; private String name; private int age; private Map&lt;String,Car&gt; cars; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Map&lt;String, Car&gt; getCars() &#123; return cars; &#125; public void setCars(Map&lt;String, Car&gt; cars) &#123; this.cars = cars; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, cars=&quot; + cars + &quot;]&quot;; &#125;&#125;``` 修改applicationContext.xml配置文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.leezp.spring.beans.HelloWorld&quot;&gt;&lt;!-- 反射 --&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;100000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Baoma&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;int&quot;&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car2&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;car&quot;&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;constructor-arg value=&quot;Jerry&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;25&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name=&quot;car.price&quot; value=&quot;300000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id=&quot;person3&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lee&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Map属性值 --&gt; &lt;bean id=&quot;newPerson&quot; class=&quot;com.leezp.spring.beans.collections.NewPerson&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Candy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用map节点及map的entry子节点配置Map类型的成员变量 --&gt; &lt;map&gt; &lt;entry key=&quot;AA&quot; value-ref=&quot;car&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;BB&quot; value-ref=&quot;car2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。1234567891011121314151617181920``` bashpackage com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); Person p = (Person) ctx.getBean(&quot;person3&quot;); System.out.println(p); NewPerson p2 = (NewPerson) ctx.getBean(&quot;newPerson&quot;); System.out.println(p2); &#125;&#125;``` 在控制台观察运行结果。12345``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]Person [name=Candy, age=20, cars=&#123;AA=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], BB=Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]&#125;] 获取源代码配置Properties属性值。 在com.leezp.spring.beans.collections包下新建一个类 DataSource.java。 123456789101112131415161718192021package com.leezp.spring.beans.collections;import java.util.Properties;public class DataSource &#123; private Properties properties; @Override public String toString() &#123; return "DataSource [properties=" + properties + "]"; &#125; public Properties getProperties() &#123; return properties; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125;&#125;``` 修改applicationContext.xml配置文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.leezp.spring.beans.HelloWorld&quot;&gt;&lt;!-- 反射 --&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;100000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Baoma&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;int&quot;&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car2&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;car&quot;&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;constructor-arg value=&quot;Jerry&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;25&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name=&quot;car.price&quot; value=&quot;300000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id=&quot;person3&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lee&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Map属性值 --&gt; &lt;bean id=&quot;newPerson&quot; class=&quot;com.leezp.spring.beans.collections.NewPerson&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Candy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用map节点及map的entry子节点配置Map类型的成员变量 --&gt; &lt;map&gt; &lt;entry key=&quot;AA&quot; value-ref=&quot;car&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;BB&quot; value-ref=&quot;car2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Properties属性值 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.leezp.spring.beans.collections.DataSource&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!-- 使用props和prop子节点来为Properties属性赋值 --&gt; &lt;props&gt; &lt;prop key=&quot;user&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/prop&gt; &lt;prop key=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。1234567891011121314151617181920212223``` bashpackage com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); Person p = (Person) ctx.getBean(&quot;person3&quot;); System.out.println(p); NewPerson p2 = (NewPerson) ctx.getBean(&quot;newPerson&quot;); System.out.println(p2); DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;); System.out.println(dataSource); &#125;&#125;``` 在控制台观察运行结果。123456``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]Person [name=Candy, age=20, cars=&#123;AA=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], BB=Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]&#125;]DataSource [properties=&#123;driverClass=com.mysql.jdbc.Driver, user=root, password=root, jdbcUrl=jdbc:mysql:///test&#125;] 使用 utility scheme定义集合使用基本的集合标签定义集合时，不能将集合作为独立的Bean定义，导致其他Bean无法引用该集合，所以无法在不同Bean之间共享集合。 可以使用 util schema里的集合标签定义独立的集合Bean。需要注意的是，必须在根元素里添加util schema定义。 先开启Spring配置文件中的util标签：打开applicationContext.xml 配置文件。点击下面的Namespaces，在弹出的复选框中将util复选框勾选。 修改applicationContext.xml配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id="helloWorld" class="com.leezp.spring.beans.HelloWorld"&gt;&lt;!-- 反射 --&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id="car" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Audi" index="0"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="ShangHai" index="1"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="100000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id="car2" class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Baoma" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type="java.lang.String"&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type="int"&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="person" class="com.leezp.spring.beans.Person"&gt; &lt;property name="name" value="Tom"&gt;&lt;/property&gt; &lt;property name="age" value="24"&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name="car" ref="car2"&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name="car"&gt; &lt;ref bean="car2" /&gt; &lt;/property&gt; --&gt; &lt;property name="car"&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="Changan"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name="car.maxSpeed" value="260"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="person2" class="com.leezp.spring.beans.Person"&gt; &lt;constructor-arg value="Jerry"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="25"&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref="car"&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name="car.price" value="300000"&gt;&lt;/property&gt; &lt;property name="car.maxSpeed" value="260"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id="person3" class="com.leezp.spring.beans.collections.Person"&gt; &lt;property name="name" value="lee"&gt;&lt;/property&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;property name="cars"&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean="car" /&gt; &lt;ref bean="car2" /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class="com.leezp.spring.beans.Car"&gt; &lt;constructor-arg value="Ford"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="Changan"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="200000" type="double"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Map属性值 --&gt; &lt;bean id="newPerson" class="com.leezp.spring.beans.collections.NewPerson"&gt; &lt;property name="name" value="Candy"&gt;&lt;/property&gt; &lt;property name="age" value="20"&gt;&lt;/property&gt; &lt;property name="cars"&gt; &lt;!-- 使用map节点及map的entry子节点配置Map类型的成员变量 --&gt; &lt;map&gt; &lt;entry key="AA" value-ref="car"&gt;&lt;/entry&gt; &lt;entry key="BB" value-ref="car2"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Properties属性值 --&gt; &lt;bean id="dataSource" class="com.leezp.spring.beans.collections.DataSource"&gt; &lt;property name="properties"&gt; &lt;!-- 使用props和prop子节点来为Properties属性赋值 --&gt; &lt;props&gt; &lt;prop key="user"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;root&lt;/prop&gt; &lt;prop key="jdbcUrl"&gt;jdbc:mysql:///test&lt;/prop&gt; &lt;prop key="driverClass"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置独立的集合Bean，以供多个bean进行引用 ,需要导入util命名空间 --&gt; &lt;util:list id="cars"&gt; &lt;ref bean="car" /&gt; &lt;ref bean="car2" /&gt; &lt;/util:list&gt; &lt;bean id="person4" class="com.leezp.spring.beans.collections.Person"&gt; &lt;property name="name" value="Jack"&gt;&lt;/property&gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &lt;!-- 引用配置的独立的集合Bean --&gt; &lt;property name="cars" ref="cars"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 修改Main.java。 12345678910111213141516171819202122232425package com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml"); Person p = (Person) ctx.getBean("person3"); System.out.println(p); NewPerson p2 = (NewPerson) ctx.getBean("newPerson"); System.out.println(p2); DataSource dataSource = (DataSource) ctx.getBean("dataSource"); System.out.println(dataSource); Person p4 = (Person) ctx.getBean("person4"); System.out.println(p4); &#125;&#125;``` 在控制台观察运行结果。12345678``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]Person [name=Candy, age=20, cars=&#123;AA=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], BB=Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]&#125;]DataSource [properties=&#123;driverClass=com.mysql.jdbc.Driver, user=root, password=root, jdbcUrl=jdbc:mysql:///test&#125;]Person [name=Jack, age=21, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]]]``` 使用 p 命名空间为了简化XML文件的配置，越来越多的XML文件采用属性而非子元素配置信息。 Spring 从2.5版本开始引入了一个新的 p 命名空间，可以通过元素属性的方式配置Bean的属性。 使用p命名空间后，基于XML的配置方式将进一步简化。 修改applicationContext.xml配置文件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 配置bean class:bean 的全类名，通过反射的方式在IOC容器中创建Bean,所以要求Bean中必须有无参的构造器 id:标识容器中的Bean,唯一 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.leezp.spring.beans.HelloWorld&quot;&gt;&lt;!-- 反射 --&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过构造方法配置bean的属性 --&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;100000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 通过参数的个数和类型区分重载 ,可以在后面加个type参数区分不同构造方法 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Baoma&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;ShangHai^&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;int&quot;&gt; &lt;!-- 属性值也可以使用value子节点进行配置 --&gt; &lt;value&gt;260&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt; &lt;!-- 使用 porperty的ref属性或ref元素建立bean之间的引用关系 --&gt; &lt;!-- 指向car2 --&gt; &lt;!-- &lt;property name=&quot;car&quot; ref=&quot;car2&quot;&gt;&lt;/property&gt; --&gt; &lt;!-- &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/property&gt; --&gt; &lt;property name=&quot;car&quot;&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 在struts2框架，会自动为car创建一个对象，在Spring中不可以，为级联属性赋值要先对对象Car赋值。 --&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.leezp.spring.beans.Person&quot;&gt; &lt;constructor-arg value=&quot;Jerry&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;25&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; --&gt; &lt;!-- 测试赋值null --&gt; &lt;!-- &lt;constructor-arg&gt; &lt;null /&gt; &lt;/constructor-arg&gt; --&gt; &lt;constructor-arg ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;!-- 和Struts、Hibernate等框架一样，Spring 支持级联属性的配置。 为级联属性赋值。 --&gt; &lt;!-- 为级联属性赋值注意：属性要先初始化后才可以为级联属性赋值，否则会有异常。和Struts2不同。 --&gt; &lt;property name=&quot;car.price&quot; value=&quot;300000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car.maxSpeed&quot; value=&quot;260&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 测试如何配置集合属性 --&gt; &lt;bean id=&quot;person3&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lee&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用 list 节点为List类型的属性赋值 --&gt; &lt;list&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;!-- 内部bean ,不能被外部引用，只能在内部使用 --&gt; &lt;bean class=&quot;com.leezp.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Ford&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;Changan&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200000&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Map属性值 --&gt; &lt;bean id=&quot;newPerson&quot; class=&quot;com.leezp.spring.beans.collections.NewPerson&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Candy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;!-- 使用map节点及map的entry子节点配置Map类型的成员变量 --&gt; &lt;map&gt; &lt;entry key=&quot;AA&quot; value-ref=&quot;car&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;BB&quot; value-ref=&quot;car2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Properties属性值 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.leezp.spring.beans.collections.DataSource&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!-- 使用props和prop子节点来为Properties属性赋值 --&gt; &lt;props&gt; &lt;prop key=&quot;user&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/prop&gt; &lt;prop key=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置独立的集合Bean，以供多个bean进行引用 ,需要导入util命名空间 --&gt; &lt;util:list id=&quot;cars&quot;&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/util:list&gt; &lt;bean id=&quot;person4&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Jack&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;!-- 引用配置的独立的集合Bean --&gt; &lt;property name=&quot;cars&quot; ref=&quot;cars&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过p命名空间为bean的属性赋值，需要先导入p命名空间 ,相对于之前方式更简洁一些 --&gt; &lt;bean id=&quot;person5&quot; class=&quot;com.leezp.spring.beans.collections.Person&quot; p:name=&quot;Ming&quot; p:age=&quot;22&quot; p:cars-ref=&quot;cars&quot;&gt; &lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。1234567891011121314151617181920212223242526272829``` bashpackage com.leezp.spring.beans.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;); Person p = (Person) ctx.getBean(&quot;person3&quot;); System.out.println(p); NewPerson p2 = (NewPerson) ctx.getBean(&quot;newPerson&quot;); System.out.println(p2); DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;); System.out.println(dataSource); Person p4 = (Person) ctx.getBean(&quot;person4&quot;); System.out.println(p4); Person p5 = (Person) ctx.getBean(&quot;person5&quot;); System.out.println(p5); &#125;&#125;``` 在控制台观察运行结果。123456789``` bashHelloWorld&apos;s ConstructorsetName:SpringPerson [name=lee, age=18, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260], Car [brand=Ford, corp=Changan, price=200000.0, maxSpeed=0]]]Person [name=Candy, age=20, cars=&#123;AA=Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], BB=Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]&#125;]DataSource [properties=&#123;driverClass=com.mysql.jdbc.Driver, user=root, password=root, jdbcUrl=jdbc:mysql:///test&#125;]Person [name=Jack, age=21, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]]]Person [name=Ming, age=22, cars=[Car [brand=Audi, corp=ShangHai, price=300000.0, maxSpeed=260], Car [brand=Baoma, corp=&lt;ShangHai^&gt;, price=0.0, maxSpeed=260]]]``` 获取源代码 自动装配XML配置里的Bean自动装配SpringIOC容器可以自动装配Bean。需要做的仅仅是在的autowire属性里指定自动装配的模式。 byType(根据类型自动装配)：若IOC容器中有多个与目标Bean类型一致的Bean,在这种情况下，Spring将无法判定哪个Bean最合适该属性，所以不能执行自动装配。 byName(根据名称自动装配)：必须将目标Bean的名称和属性名设置的完全相同。 constructor（通过构造器自动装配）：当Bean中存在多个构造器时，此种自动装配方式将会很复杂。不推荐使用。 新建一个包com.leezp.spring.beans.autowire。 在该包下新建Address.java。123456789101112131415161718192021222324252627282930``` bashpackage com.leezp.spring.beans.autowire;public class Address &#123; private String city; private String street; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getStreet() &#123; return street; &#125; public void setStreet(String street) &#123; this.street = street; &#125; @Override public String toString() &#123; return &quot;Address [city=&quot; + city + &quot;, street=&quot; + street + &quot;]&quot;; &#125;&#125;``` 在该包下新建Car.java。1234567891011121314151617181920212223242526272829``` bashpackage com.leezp.spring.beans.autowire;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;; &#125;&#125; 在该包下新建Person.java。 123456789101112131415161718192021222324252627282930313233343536373839package com.leezp.spring.beans.autowire;public class Person &#123; private String name; private Address address; private Car car; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", address=" + address + ", car=" + car + "]"; &#125;&#125; 在src下新建一个Spring的配置文件beans-autowire.xml。 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="address" class="com.leezp.spring.beans.autowire.Address" p:city="NanJing" p:street="ShangHaiLu"&gt; &lt;/bean&gt; &lt;!-- &lt;bean id="address2" class="com.leezp.spring.beans.autowire.Address" p:city="NanJing" p:street="ShangHaiLu"&gt; &lt;/bean&gt; --&gt; &lt;bean id="car2" class="com.leezp.spring.beans.autowire.Car" p:brand="BMW" p:price="300000"&gt;&lt;/bean&gt; &lt;!-- 手动转配 --&gt; &lt;!-- &lt;bean id="person" class="com.leezp.spring.beans.autowire.Person" p:name="Tom" p:address-ref="address" p:car-ref="car"&gt;&lt;/bean&gt; --&gt; &lt;!-- 可以使用autowire属性指定自动装配的方式，byName根据bean的名字和当前bean的 setter风格的属性名进行自动装配， 若有匹配的，则进行自动装配；若没有匹配的，则不装配。 --&gt; &lt;!-- &lt;bean id="person" class="com.leezp.spring.beans.autowire.Person" p:name="Tom" autowire="byName"&gt;&lt;/bean&gt; --&gt; &lt;!-- byType根据bean的类型和当前bean的属性的类型进行自动装配。若IOC容器中有一个以上的类型匹配的Bean,则抛异常。 --&gt; &lt;bean id="person" class="com.leezp.spring.beans.autowire.Person" p:name="Tom" autowire="byType"&gt;&lt;/bean&gt;&lt;/beans&gt;``` 在该包下新建一个Main.java。1234567891011121314151617``` bashpackage com.leezp.spring.beans.autowire;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-autowire.xml&quot;); Person p = (Person) ctx.getBean(&quot;person&quot;); System.out.println(p); &#125;&#125;``` 在控制台观察运行结果。123``` bashPerson [name=Tom, address=Address [city=NanJing, street=ShangHaiLu], car=Car [brand=BMW, price=300000.0]]``` 获取源代码 XML配置里的Bean自动装配的缺点在Bean配置文件里设置autowire属性进行自动装配将会装配Bean的所有属性。然而，若只希望装配个别属性时，autowire属性就不够灵活了。 autowire属性要么根据类型自动匹配，要么根据名称自动装配，不能两者兼而有之。 一般情况下，在实际的项目中很少使用自动装配功能，因为和自动装配功能所带来的好处比起来，明确清晰的配置文档更有说服力一些。 在整合第三方框架的时候，使用autowire的确给我们带来一些方便。 bean之间的关系继承；依赖。 继承Bean配置Spring允许继承Bean的配置，被继承的Bean称为父Bean,继承这个父Bean的Bean称为子Bean。 子Bean从父Bean中继承配置，包括Bean的属性配置。 子Bean也可以覆盖从父Bean继承过来的配置。 新建一个包com.leezp.spring.beans.relation。 在src下新建一个Spring的配置文件beans-relation.xml。1234567891011121314151617``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:city=&quot;NanJing&quot; p:street=&quot;ShangHaiLu&quot;&gt;&lt;/bean&gt; &lt;!-- &lt;bean id=&quot;address2&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:city=&quot;NanJing&quot; p:street=&quot;XiAnLu&quot;&gt;&lt;/bean&gt; --&gt; &lt;!-- bean配置的继承：使用bean的parent属性指定继承哪个bean的配置 --&gt; &lt;bean id=&quot;address2&quot; p:street=&quot;XiAnLu&quot; parent=&quot;address&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;``` 在该包下新建Main.java。12345678910111213141516171819202122``` bashpackage com.leezp.spring.beans.relation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.autowire.Address;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-relation.xml&quot;); Address address = (Address) ctx.getBean(&quot;address&quot;); System.out.println(address); Address address2 = (Address) ctx.getBean(&quot;address2&quot;); System.out.println(address2); &#125;&#125;``` 在控制台观察运行结果。1234``` bashAddress [city=NanJing, street=ShangHaiLu]Address [city=NanJing, street=XiAnLu]``` 父Bean可以作为配置模板，也可以作为bean实例，若只想把父bean作为模板，可以设置的abstract属性为true，这样Spring将不会实例化这个Bean（用IOC实例化它会报错）。 并不是元素里的所有属性都会被继承，比如：autowire,abstract等。 也可以忽略父bean的class属性，让子bean指定自己的类，而共享相同的属性配置。但此时abstract必须设置为true（若某一个bean的class属性没有指定，则该bean必须是一个抽象bean，否则报错）。 修改beans-relation.xml配置文件。1234567891011121314151617181920212223``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 抽象bean:bean的abstract属性为true的bean。这样的Bean不能被IOC容器实例化，只用来被继承配置 --&gt; &lt;!-- 若某一个bean的class属性没有指定，则该bean必须是一个抽象bean --&gt; &lt;bean id=&quot;address&quot; p:city=&quot;NanJing&quot; p:street=&quot;ShangHaiLu&quot; abstract=&quot;true&quot;&gt;&lt;/bean&gt; &lt;!-- &lt;bean id=&quot;address2&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:city=&quot;NanJing&quot; p:street=&quot;XiAnLu&quot;&gt;&lt;/bean&gt; --&gt; &lt;!-- bean配置的继承：使用bean的parent属性指定继承哪个bean的配置 --&gt; &lt;bean id=&quot;address2&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:street=&quot;XiAnLu&quot; parent=&quot;address&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;address3&quot; class=&quot;com.leezp.spring.beans.autowire.Address&quot; p:street=&quot;DaLianLu&quot; parent=&quot;address2&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。1234567891011121314151617181920212223242526272829``` bashpackage com.leezp.spring.beans.relation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.autowire.Address;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-relation.xml&quot;); // 注意抽象Bean不能被创建。否则报错： // Error creating bean with name &apos;address&apos;: Bean definition is abstract /* * Address address = (Address) ctx.getBean(&quot;address&quot;); * System.out.println(address); */ Address address2 = (Address) ctx.getBean(&quot;address2&quot;); System.out.println(address2); Address address3 = (Address) ctx.getBean(&quot;address3&quot;); System.out.println(address3); &#125;&#125;``` 在控制台观察运行结果。1234``` bashAddress [city=NanJing, street=XiAnLu]Address [city=NanJing, street=DaLianLu]``` 依赖Bean配置Spring允许用户通过depends-on属性设定Bean前置依赖的Bean,前置依赖的Bean会在本Bean实例化之前创建好。 如果前置依赖于多个Bean，则可以通过逗号或空格的方式配置Bean的名称。 使用场景：当bean与bean直接 初始化 有先后顺序时，就需要指定他们直接的依赖关系，可以使用depends-on属性。 修改Car.java。123456789101112131415161718192021222324252627282930313233``` bashpackage com.leezp.spring.beans.autowire;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;; &#125; public Car() &#123; System.out.println(&quot;Car被初始化&quot;); &#125;&#125; 修改beans-relation.xml配置文件。 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 抽象bean:bean的abstract属性为true的bean。这样的Bean不能被IOC容器实例化，只用来被继承配置 --&gt; &lt;!-- 若某一个bean的class属性没有指定，则该bean必须是一个抽象bean --&gt; &lt;bean id="address" p:city="NanJing" p:street="ShangHaiLu" abstract="true"&gt;&lt;/bean&gt; &lt;!-- &lt;bean id="address2" class="com.leezp.spring.beans.autowire.Address" p:city="NanJing" p:street="XiAnLu"&gt;&lt;/bean&gt; --&gt; &lt;!-- bean配置的继承：使用bean的parent属性指定继承哪个bean的配置 --&gt; &lt;bean id="address2" class="com.leezp.spring.beans.autowire.Address" p:street="XiAnLu" parent="address"&gt;&lt;/bean&gt; &lt;bean id="address3" class="com.leezp.spring.beans.autowire.Address" p:street="DaLianLu" parent="address2"&gt;&lt;/bean&gt; &lt;bean id="car" class="com.leezp.spring.beans.autowire.Car" p:brand="Audi" p:price="300000"&gt;&lt;/bean&gt; &lt;!-- 要求在配置Person时，必须有一个关联的car！换句话说person这个bean依赖于Car这个bean --&gt; &lt;bean id="person" class="com.leezp.spring.beans.autowire.Person" p:name="Tom" p:address-ref="address2" depends-on="car"&gt;&lt;/bean&gt;&lt;/beans&gt;``` 修改Main.java。123456789101112131415161718192021222324252627282930313233``` bashpackage com.leezp.spring.beans.relation;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.autowire.Address;import com.leezp.spring.beans.autowire.Car;import com.leezp.spring.beans.autowire.Person;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-relation.xml&quot;); // 注意抽象Bean不能被创建。否则报错： // Error creating bean with name &apos;address&apos;: Bean definition is abstract /* * Address address = (Address) ctx.getBean(&quot;address&quot;); * System.out.println(address); */ Address address2 = (Address) ctx.getBean(&quot;address2&quot;); System.out.println(address2); Address address3 = (Address) ctx.getBean(&quot;address3&quot;); System.out.println(address3); Person person = (Person) ctx.getBean(&quot;person&quot;); System.out.println(person); &#125;&#125;``` 在控制台观察运行结果。12345``` bashCar被初始化Address [city=NanJing, street=XiAnLu]Address [city=NanJing, street=DaLianLu]Person [name=Tom, address=Address [city=NanJing, street=XiAnLu], car=null] 获取源代码 bean的作用域singleton ; prototype ； WEB 环境作用域 singleton:默认值。容器初始化时创建bean实例，在整个容器的生命周期内只创建这一个bean。单例的。 创建Spring配置文件beans-scope.xml。 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 使用bean的scope属性来配置bean的作用域 。 singleton:默认值。**容器初始化时**创建bean实例，在整个容器的生命周期内只创建这一个bean。单例的。 --&gt; &lt;bean id="car" class="com.leezp.spring.beans.autowire.Car" scope="prototype"&gt; &lt;property name="brand" value="Audi"&gt;&lt;/property&gt; &lt;property name="price" value="200000"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 修改包com.leezp.spring.beans.autowire下的Car.java。12345678910111213141516171819202122232425262728293031323334``` bashpackage com.leezp.spring.beans.autowire;public class Car &#123; private String brand; private double price; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;]&quot;; &#125; public Car() &#123; System.out.println(&quot;Car被初始化&quot;); &#125;&#125;``` 创建包com.leezp.spring.beans.scope。 在包下创建Main.java。12345678910111213141516171819``` bashpackage com.leezp.spring.beans.scope;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.leezp.spring.beans.autowire.Car;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-scope.xml&quot;); Car car = (Car) ctx.getBean(&quot;car&quot;); Car car2 = (Car) ctx.getBean(&quot;car&quot;); System.out.println(car == car2); &#125;&#125;``` 在控制台观察运行结果。12345``` bashCar被初始化Car被初始化false``` 使用外部属性文件在配置文件里配置Bean时，有时需要在Bean的配置里混入系统部署的细节信息（例如：文件路径，数据源配置信息等），而这些部署细节实际上需要和Bean配置相分离。 Spring提供了一个PropertyPlaceholderConfigurer的BeanFactory后置处理器，这个处理器允许用户将Bean配置的部分内容外移到属性文件中。可以在Bean配置文件里使用形式为${var}的变量，PropertyPlaceholderConfigurer从属性文件里加载属性，并使用这些属性来替换变量。 Spring还允许在属性文件中使用${propName}，以实现属性之间的相互引用。 注册PropertyPlaceholderConfigurer。Spring2.0：1234``` bash&lt;!-- &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:db.properties&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt;``` Spring2.5：123``` bash&lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;``` 新建beans-properties.xml配置文件。12345678910111213141516171819202122232425262728293031``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- Spring2.0 --&gt; &lt;!-- &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:db.properties&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- Spring2.5以后：可通过&lt;context:property-placeholder元素简化，导入属性文件 --&gt; &lt;!-- &lt;bean&gt;中添加context Schema定义 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 使用外部属性文件的属性 --&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbcUrl&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 新建db.properties属性文件。123456``` bashuser=rootpassword=rootdriverClass=com.mysql.jdbc.DriverjdbcUrl=jdbc:mysql://localhost:3306/test``` 新建包com.leezp.spring.beans.properties。在该包下新建Main.java。1234567891011121314151617181920``` bashpackage com.leezp.spring.beans.properties;import java.sql.SQLException;import javax.sql.DataSource;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) throws SQLException &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-properties.xml&quot;); DataSource dataSource = (DataSource) ctx.getBean(&quot;dataSource&quot;); System.out.println(dataSource.getConnection()); &#125;&#125;``` 在控制台观察运行结果。123``` bashcom.mchange.v2.c3p0.impl.NewProxyConnection@170ed6ab``` 获取源代码 spELSpring表达式或语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于EL:SpEL使用#{…}作为界定符，所有在大括号中的字符都将被认为是SpEL。 SpEL为bean的属性进行动态赋值提供了便利。 通过SpEL可以实现：1.通过bean的id对bean进行引用。2.调用方法以及引用对象中的属性。3.计算表达式的值。4.正则表达式的匹配。 SpEL：字面量字面量的表示：1.整数：&lt;property name=”count” value=”#{5}”/&gt;2.小数：&lt;property name=”frequency” value=”#{20.1}”/&gt;3.科学计数法：&lt;property name=”capacity” value=”#{1e3}”/&gt;4.String可以使用单引号或者双引号作为字符串的界定符号：&lt;property name=”name” value=”#{‘lee’}“/&gt; 或 &lt;property name=”name” value=’#{“lee”}‘/&gt;5.Boolean:&lt;property name=”enabled” value=”#{false}”/&gt; 仅仅赋字面值用SpEL的意义不大。重要作用是后面的操作。 SpEL：引用Bean、属性和方法引用其他对象 1.&lt;!–通过value属性和SpEL配置Bean之间的应用关系–&gt;&lt;property name=”prefix” value=”#{prefixGenerator}”&gt;&lt;/property&gt; 2.引用其他对象的属性&lt;!–通过value属性和SpEL配置 suffix属性值为另一个Bean的suffix–&gt;&lt;property name=”suffix” value=”#{sequenceGenerator2.suffix}”/&gt; 3.调用其他方法，还可以链式操作 &lt;!–通过value属性和SpEL配置 suffix属性值为另一个Bean的方法的返回值–&gt;&lt;property name=”suffix” value=”#{sequenceGenerator2.toString()}”/&gt; &lt;!–方法的连缀–&gt;&lt;property name=”suffix” value=”{sequenceGenerator2.toString().toUpperCase()}”/&gt; 4.调用静态方法或静态属性 通过T()调用一个类的静态方法，它将返回一个Class Object，然后再调用相应的方法或属性：&lt;property name=”initValue” value=”#{T(java.lang.Math).PI}”/&gt; 新建一个包com.leezp.spring.beans.spel。 在该包下新建Address.java。123456789101112131415161718192021222324252627282930``` bashpackage com.leezp.spring.beans.spel;public class Address &#123; private String city; private String street; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getStreet() &#123; return street; &#125; public void setStreet(String street) &#123; this.street = street; &#125; @Override public String toString() &#123; return &quot;Address [city=&quot; + city + &quot;, street=&quot; + street + &quot;]&quot;; &#125;&#125;``` 在该包下新建Car.java。123456789101112131415161718192021222324252627282930313233343536373839404142434445``` bashpackage com.leezp.spring.beans.spel;public class Car &#123; private String brand; private double price; // 轮胎周长 private double tyrePerimeter; public double getTyrePerimeter() &#123; return tyrePerimeter; &#125; public void setTyrePerimeter(double tyrePerimeter) &#123; this.tyrePerimeter = tyrePerimeter; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;, price=&quot; + price + &quot;, typePerimeter=&quot; + tyrePerimeter + &quot;]&quot;; &#125; public Car() &#123; // System.out.println(&quot;Car被初始化&quot;); &#125;&#125; 在该包下新建Person.java。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.leezp.spring.beans.spel;public class Person &#123; private String name; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; //引用 address bean的city属性 private String city; //根据car的price确定info:car的price&gt;=300000:金领；否则：白领 private String info; private Car car; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", city=" + city + ", info=" + info + ", car=" + car + "]"; &#125;&#125; 新建beans-spel.xml配置文件。 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="address" class="com.leezp.spring.beans.spel.Address"&gt; &lt;!-- 使用SpEL为属性赋一个字面值 --&gt; &lt;property name="city" value="#&#123;'ChengDu'&#125;"&gt;&lt;/property&gt; &lt;property name="street" value="#&#123;'YuLinLu'&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="car" class="com.leezp.spring.beans.spel.Car"&gt; &lt;property name="brand" value="Audi"&gt;&lt;/property&gt; &lt;property name="price" value="400000"&gt;&lt;/property&gt; &lt;!-- 使用SpEL引用类的静态属性 --&gt; &lt;property name="tyrePerimeter" value="#&#123;T(java.lang.Math).PI*2*30&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="person" class="com.leezp.spring.beans.spel.Person"&gt; &lt;!-- 使用SpEL来引用其他的Bean --&gt; &lt;property name="car" value="#&#123;car&#125;"&gt;&lt;/property&gt; &lt;!-- 使用SpEL来引用其他的Bean属性 --&gt; &lt;property name="city" value="#&#123;address.city&#125;"&gt;&lt;/property&gt; &lt;property name="info" value="#&#123;address.street&#125;"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 新建Main.java。12345678910111213141516171819202122``` bashpackage com.leezp.spring.beans.spel;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-spel.xml&quot;); Address a = (Address) ctx.getBean(&quot;address&quot;); System.out.println(a); Car car = (Car) ctx.getBean(&quot;car&quot;); System.out.println(car); Person p = (Person) ctx.getBean(&quot;person&quot;); System.out.println(p); &#125;&#125;``` 在控制台观察运行结果。12345``` bashAddress [city=ChengDu, street=YuLinLu]Car [brand=Audi, price=400000.0, typePerimeter=188.49555921538757]Person [name=null, city=ChengDu, info=YuLinLu, car=Car [brand=Audi, price=400000.0, typePerimeter=188.49555921538757]]``` 获取源代码 SpEL支持的运算符号1.算数运算符：+,-,*,/,%,^12345678``` bash&lt;property name=&quot;addition&quot; value=&quot;#&#123;counter.total+1&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;subtraction&quot; value=&quot;#&#123;counter.total-1&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;perimeter&quot; value=&quot;#&#123;2*T(java.lang.Math).PI*circle.radius&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;average&quot; value=&quot;#&#123;counter.total/counter.count&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;remainder&quot; value=&quot;#&#123;counter.total%counter.count&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;area&quot; value=&quot;#&#123;T(java.lang.Math).PI*circle.radius^2&#125;&quot;&gt;&lt;/property&gt;``` 2.加号还可以用作字符串连接：&lt;constructor-arg value=”#{performer.firstName+’’+performer.lastName}”/&gt; 3.比较运算符：&lt;,&gt;,==,&lt;=,&gt;=,lt,gt,eq,le,ge&lt;property name=”equal” value=”#{counter.total==100}”/&gt;&lt;property name=”hasCapacity” value=”#{counter.total le 10000}”/&gt; 4.逻辑运算符号 and,or,not,!&lt;property name=”largeCircle” value=”#{shape.kind==’circle’ and shape.perimeter gr&lt;10000}”/&gt;&lt;property name=”ww” value=”#{!product.available}”/&gt;&lt;property name=”zz” value=”#{not product.available}”/&gt; 5.if-else运算符（三目运算符） ?: 6.if-else的变体&lt;constructor-arg value=”#{lee.song} ?: ‘ChunHua’}”/&gt; 7.正则表达式：matches&lt;constructor-arg value=”#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}’}”/&gt; IOC容器中Bean的生命周期SpringIOC容器可以管理Bean的生命周期，Spring允许在Bean生命周期的特定点执行定制的任务。 SpringIOC容器对Bean的生命周期进行管理的过程：1.通过构造器或工厂方法创建Bean实例2.为Bean的属性设置值和对其他Bean的引用3.调用Bean的初始化方法4.Bean可以使用了5.当容器关闭时，调用Bean的销毁方法 在Bean的声明里设置init-method和destroy-method属性，为Bean指定初始化和销毁方法。 在src下创建包com.leezp.spring.beans.cycle。 在该包下创建Car.java。12345678910111213141516171819202122232425``` bashpackage com.leezp.spring.beans.cycle;public class Car &#123; public Car() &#123; System.out.println(&quot;Car&apos;s Constructor...&quot;); &#125; private String brand; public void setBrand(String brand) &#123; System.out.println(&quot;setBrand...&quot;); this.brand = brand; &#125; public void init() &#123; System.out.println(&quot;init...&quot;); &#125; public void destroy() &#123; System.out.println(&quot;destroy...&quot;); &#125;&#125;``` 创建beans-cycle.xml配置文件。12345678910111213``` bash&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;car&quot; class=&quot;com.leezp.spring.beans.cycle.Car&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt; &lt;property name=&quot;brand&quot; value=&quot;Audi&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;``` 创建Main.java。12345678910111213141516171819``` bashpackage com.leezp.spring.beans.cycle;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;beans-cycle.xml&quot;); Car car = (Car) ctx.getBean(&quot;car&quot;); System.out.println(car); ctx.destroy(); &#125;&#125;``` 在控制台观察运行结果。1234567``` bashCar&apos;s Constructor...setBrand...init...com.leezp.spring.beans.cycle.Car@22967f8edestroy...``` 创建Bean后置处理器Bean后置处理器允许在调用初始化方法前后对Bean进行额外的处理 Bean后置处理器对IOC容器里的所有Bean实例逐一处理，而非单一实例，其典型应用是：检查Bean属性的正确性或根据特定的标准更改Bean的属性。 对Bean后置处理器而言，需要实现Interface BeanPostProcessor接口。在初始化方法被调用前后，Spring将把每个Bean实例分别传递给上述接口的以下两个方法：postProcessBeforeInitialization和postProcessAfterInitialization。 添加Bean后置处理器后Bean的生命周期SpringIOC容器对Bean的生命周期进行管理的过程：1.通过构造器或工厂方法创建Bean实例2.为Bean的属性设置值和对其他Bean的引用3.将Bean实例传递给Bean后置处理器的postProcessBeforeInitialization方法4.调用Bean的初始化方法5.将Bean实例传递给Bean后置处理器的PostProcessAfterInitialization方法6.Bean可以使用了7.当容器关闭时，调用Bean的销毁方法 修改Car.java。1234567891011121314151617181920212223242526272829``` bashpackage com.leezp.spring.beans.cycle;public class Car &#123; public Car() &#123; System.out.println(&quot;Car&apos;s Constructor...&quot;); &#125; private String brand; public void setBrand(String brand) &#123; System.out.println(&quot;setBrand...&quot;); this.brand = brand; &#125; public void init() &#123; System.out.println(&quot;init...&quot;); &#125; public void destroy() &#123; System.out.println(&quot;destroy...&quot;); &#125; @Override public String toString() &#123; return &quot;Car [brand=&quot; + brand + &quot;]&quot;; &#125;&#125; 新建MyBeanPostProcessor.java。 123456789101112131415161718192021222324252627282930package com.leezp.spring.beans.cycle;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("postProcessBeforeInitialization" + bean + "," + beanName); if ("car".equals(beanName)) &#123; //可以在这里过滤bean &#125; return bean; &#125; @Override public Object postProcessAfterInitialization(Object arg0, String arg1) throws BeansException &#123; System.out .println("postProcessAfterInitialization" + arg0 + "," + arg1); // 在这里可以对Bean进行额外的配置 Car car = new Car(); car.setBrand("Ford"); return car; &#125;&#125; 修改beans-cycle.xml配置文件。 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="car" class="com.leezp.spring.beans.cycle.Car" init-method="init" destroy-method="destroy"&gt; &lt;property name="brand" value="Audi"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 实现BeanPostProcessor接口，并具体提供两个方法的实现 --&gt; &lt;!-- 配置Bean的后置处理器 --&gt; &lt;bean class="com.leezp.spring.beans.cycle.MyBeanPostProcessor"&gt;&lt;/bean&gt; &lt;/beans&gt; 在控制台观察运行结果。 Car's Constructor... setBrand... postProcessBeforeInitializationCar [brand=Audi],car init... postProcessAfterInitializationCar [brand=Audi],car Car's Constructor... setBrand... Car [brand=Ford] destroy... 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一起学习Spring4.0]]></title>
      <url>%2Fblog%2F2016%2F07%2F30%2F%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0Spring4.0%2F</url>
      <content type="text"><![CDATA[从今天起，准备陆续更新Spring4.0的博客，当做自己知识的巩固。 前言Spring 官网 开发工具：推荐使用Eclipse，我用的是Eclipse 4.3(KEPLER) 64bit 版本。 插件：springsource-tool-suite-3.4.0.RELEASE-e4.3.1-updatesite 注意要安装和自己Eclipse版本相对应的插件。 Spring4.0 jar包：spring-framework-4.0.4.RELEASE.rar,下载后解压使用。 正文Spring 简介Spring 是一个开源框架。也是一个 IOC (DI) 和 AOP 容器框架。IOC(反转控制)，DI（依赖注入）。 Spring 是轻量级，非侵入性的（使用Spring的时候不需要实现Spring提供的接口，也不需要继承它的任何父类，可以使用它提供的功能）。Spring 是一个容器，因为它包含并且管理应用对象的生命周期。 核心：1.依赖注入2.面向切面编程AOP Spring 模块：最底层：Beans,Core,Context,SpringEL IOC(Inversion of Control)：其思想是反转资源获取的方向。传统的资源查找要求组件向容器发起请求查找资源。作为回应，容器适时的返回资源。而应用了IOC之后，则是容器主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源。这种行为也被称为查找的被动形式。 DI(Dependency Injection)：IOC的另一种表述方式：即组件以一种预先定义好的方式（例如：setter方法）接受来自如容器的资源的注入。相对于IOC而言，这种表述更直接。 Spring4.0 简介Spring4.0是 Spring 推出的一个重大版本升级，进一步加强了 Spring 作为 Java 领域第一开源平台的地位。Spring4.0 引入了众多 Java 开发者期盼的新特性，如泛型依赖注入、SpEL、校验及格式化框架、Rest风格的 WEB 编程模型等。这些新功能实用性强、易用性高，可大幅降低 JavaEE 开发的难度，同时有效提升应用开发的优雅性。 安装Spring Tool SuiteSpring Tool Suite 是一个Eclipse插件，利用该插件可以更方便的在Eclipse平台上开发基于Spring的应用。 打开Eclipse-&gt; Help-&gt; Install New Software…-&gt; Add-&gt; Archive…。选中刚刚下载的压缩文件，点击打开。在弹出的Available Software 窗口将4个带 Spring IDE的项勾选，将下面“联网进行更新”复选框去掉。点击下一步…保存更改。重启Eclipse,点击 Help-&gt; Welcome 打开欢迎页面，显示Spring IDE 图样即为安装成功。点击 Window-&gt; Preferences,如果看到 Spring,则证明插件已经安装成功。 搭建Spring开发环境在Eclipse新建一个项目，命名为spring-01，新建一个bin文件夹，将所需jar包复制到bin目录下。选中导入的jar，右击build path-&gt; Add to Build Path。 新建一个package，命名为 com.leezp.spring.beans，在该包下新建一个类HelloWorld。 1234567891011121314151617181920package com.leezp.spring.beans;public class HelloWorld &#123; private String name; public void setName(String name) &#123; System.out.println("setName:" + name); this.name = name; &#125; // setValue 这里的value和xml 配置文件里 的property 的name属性的值对应 public void hello() &#123; System.out.println("hello:" + name); &#125; public HelloWorld() &#123; System.out.println("HelloWorld's Constructor"); &#125;&#125; src下new-&gt; Spring Bean Configuration File，命名为applicationContext.xml。 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置bean --&gt; &lt;bean id="helloWorld" class="com.leezp.spring.beans.HelloWorld"&gt; &lt;property name="name" value="Spring"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 新建一个Main.java 1234567891011121314151617181920212223242526package com.leezp.spring.beans;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args) &#123; /* * // 创建 HelloWorld 的一个对象 HelloWorld helloWorld = new HelloWorld(); * // 为name 属性赋值 helloWorld.setName("lee"); */ // 1. 创建Spring 的IOC 容器对象 // ApplicationContext代表IOC 容器 ApplicationContext ctx = new ClassPathXmlApplicationContext( "applicationContext.xml");// 创建对象时即调用它的set方法对属性赋值 // 2. 从IOC容器中获取Bean实例 // HelloWorld helloWorld = (HelloWorld) ctx.getBean("helloWorld"); // HelloWorld helloWorld = ctx.getBean(HelloWorld.class);//这样做有缺点，配置多个 // bean的时候它不知道访问哪一个，只适用于单个bean // 调用hello方法 // helloWorld.hello(); &#125;&#125; 运行该文件，在控制台观察结果。 发现不需要在main里对 helloWorld 赋值，只需创建一个Spring的IOC容器对象，自动进行了赋值。 获取源代码 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建博客之进阶篇]]></title>
      <url>%2Fblog%2F2016%2F07%2F23%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B9%8B%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
      <content type="text"><![CDATA[在上一节中，我们已经学会了对Hexo博客配置文件和Next主题配置文件进行配置以达到我们想要的效果。 在这一节中，将介绍一些Hexo博客的进阶设计，有了这些设计，博客看起来会美美哒。 前言之前的章节已经讲到如何搭建Hexo博客并选择自己喜欢的主题进行配置。那么如何添加自己喜欢的样式或效果来使自己的网站更加美观，在众多Hexo博客中脱颖而出呢？ 正文为Hexo博客添加一个主页跳转思路：可以直接把hexo部署到一个分支，比如blog，然后首页自己写个html（这里的首页不是hexo生成的），手动上传到master，在master下手动上传个CNAME绑定域名。 思维导图 总结Hexo博客可配置的地方还有很多，这里只是抛砖引玉。 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建博客之Next主题精析]]></title>
      <url>%2Fblog%2F2016%2F07%2F17%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B9%8BNext%E4%B8%BB%E9%A2%98%E7%B2%BE%E6%9E%90%2F</url>
      <content type="text"><![CDATA[在上一节中，我们已经学会了使用hexo搭建博客，并且可以使用hexo发布博文。 在这一节中，将介绍一些基于Next主题配置的实用功能，有了这些功能，博客看起来会更美观和充实。 准备配置Next主题 打开站点配置文件（这里要注意不是主题配置文件而是站点配置文件），将theme 后的主题改成你选择的主题，我的是Next。 正文下面开始配置主题配置文件_config.yml 配置网站的图标1favicon: /blog/images/favicon.ico 在favicon 后填写图标的路径 添加悬赏功能123reward_comment: 您的支持将鼓励我继续创作,我一直在期待那个最帅的人出现！wechatpay: /blog/images/wechat-image.pngalipay: /blog/images/alipay-image.png 配置主页显示的菜单可以根据自己喜好进行配置。 12345678menu: home: / categories: /categories about: /about archives: /archives tags: /tags #sitemap: /sitemap.xml #commonweal: /404.html 配置博客的字体12345678910111213141516171819202122232425262728293031323334353637font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: 配置代码高亮样式123# Available value:# normal | night | night eighties | night blue | night brighthighlight_theme: night eighties 添加百度统计注册并登陆百度统计。点击 管理-&gt;新增网站，添加自己网站的域名，添加成功以后点击获取代码，这里有两种情况。常规方法：在管理–&gt;获取代码-&gt;复制代码，复制到你的网站主页head标签内的script标签里。在Next主题中已经帮我们完成了这个步骤，只需要将你的Baidu Analytics ID 复制到主题配置文件中即可。 12# Baidu Analytics IDbaidu_analytics: 添加百度分享123456# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare: #type: slide 这里可以配置百度分享，但要注意百度分享会覆盖掉多说分享，所以如果你想使用多说分享，一定要把这段话注释掉。下面开始配置站点配置文件_config.yml。 多说和多说热评配置duoshuo_shortname为博客中显示的你的昵称。 12345# 多说shareduoshuo_shortname: leezpduoshuo_share: true# hot commentsduoshuo_hotartical: true 站点概览显示的栏目配置12345678 # Menu configuration menu: home: / archives: /archives tags: /tags categories: /categories![](/blog/images/img/160717/watch.png) 社交媒体配置123456social: GitHub: https://github.com/leezp #Twitter: your-twitter-url Weibo: your-weibo-url DouBan: your-douban-url ZhiHu: your-zhihu-url 总结Hexo博客和Next主题可配置的地方还有很多，这里只是抛砖引玉。 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Hexo从零开始搭建Blog]]></title>
      <url>%2Fblog%2F2016%2F07%2F16%2F%E4%BD%BF%E7%94%A8Hexo%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BABlog%2F</url>
      <content type="text"><![CDATA[今天是农历6月13，对我来说是一个特别的日子。 我们来使用hexo生成静态博客并架设在免费的github page平台，看看会发生什么。 准备我的电脑系统是win7 64bit，node.js 版本 v4.4.4，本教程只针对windows用户。 正文安装git安装方法请自行百度 安装Node.js安装方法请自行百度 安装hexo安装前先介绍几个hexo常用的命令,#后面为注释。 1234$ hexo g #完整命令为hexo generate，用于生成静态文件$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上$ hexo n #完整命令为hexo new，用于新建一篇文章 在电脑里选择一个目录建立一个文件夹（例如D:\hexo），双击建好的文件夹进入文件夹，鼠标右键任意地方，选择Git Bash，使用以下命令安装hexo（ps：以下命令中的$符号只为了让教程和实际看起来一致，实际输入命令只需输入$ 后面的命令即可） 1$ npm install hexo-cli -g 验证软件是否正确安装 123$ git --version$ node -v$ npm -v hexo初始化 1$ hexo init 安装依赖包 1$ npm install 让我们看看刚刚下载的hexo文件带来了什么，在D:\hexo内执行以下命令， 12$ hexo g$ hexo s 然后用浏览器访问 http://localhost:4000/ ，此时，你应该看到了一个漂亮的博客了，当然这个博客只是在本地的，别人是看不到的，hexo3.0使用的默认主题是landscape。 注册Github帐号已经有Github帐号跳过此步，首先进入Github进行注册，用户名、邮箱和密码之后都需要用到，自己记好。 创建repositoryrepository相当于一个仓库，用来放置你的代码文件。首先，登陆进入Github，并进入个人页面，选择Repositories(下图第一个红圈的地方)，然后New一个repository(下图第二个红圈的地方) 创建时，只需要填写Repository name即可，当然这个名字的格式必须为youname.github.io，例如我的为leezp.github.io 部署本地文件到github既然Repository已经创建了，当然是先把博客放到Github上去看看效果。编辑E：\hexo下的_config.yml文件，建议使用Notepad++。在_config.yml最下方，添加如下配置(命令中的第一个leezp为Github的用户名,第二个leezp为之前New的Repository的名字,记得改成自己的。另外记得一点，hexo的配置文件中任何’:’后面都是带一个空格的),如果配置以下命令出现ERROR Deployer not found : github，则$ npm install hexo-deployer-git –save 在_config.yml最下方，添加如下配置1234deploy: type: git repository: http://github.com/leezp/leezp.github.io.git branch: master 配置好_config.yml并保存后，执行以下命令部署到Github上。如果你是第一次使用Github或者是已经使用过，但没有配置过SSH，则可能需要配置一下，具体方法史上最全github使用方法：github入门到精通里面有介绍到。 12$ hexo g$ hexo d 执行上面的第二个命令，可能会要你输入用户名和密码，皆为注册Github时的数据，输入密码是不显示任何东西的，输入完毕回车即可。此时，我们的博客已经搭建起来，并发布到Github上了，在浏览器访问leezp.github.io就能看到自己的博客了。第一次访问刚地址，可能访问不了，您可以在几分钟后进行访问，一般不超过10分钟。 hexo的配置文件hexo里面有两个常用到的配置文件，分别是整个博客的配置文件D:\hexo_config.yml和主题的配置文件D:\hexo\themes\next_config.yml,此地址是对于我来说，hexo3.0使用的默认主题是landscape，因此你们的地址应该是D:\hexo\themes\landscape_config.yml，下文所有讲到next的地方，你们将之换为自己的主题名即可。接下来介绍整个博客的配置文件。D:\hexo_config.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思title: leezp #博客名subtitle: #副标题description: #用于搜索，没有直观表现author: lee #作者language: zh-Hans #语言timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值# URL 暂不配置，使用默认值## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://leezp.space #域名root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 暂不配置，使用默认值source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局等，使用默认值new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true tab_replace:# Category &amp; Tag 暂不配置，使用默认值default_category: uncategorizedcategory_map:tag_map:# Date / Time format 时间格式，使用默认值## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章数，0表示不分页pagination_dir: page# Extensions 插件配置，暂时不配置## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/#plugins:#- hexo-generator-feedtheme: next #使用的主题，即：E:\myblog\themes文件夹下的主题文件夹名feed: #之后配置rss会用，使用如下配置即可 type: atom path: atom.xml limit: 20 # Deployment 用于部署到github，之前已经配置过## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: http://github.com/leezp/leezp.github.io.git branch: master 按照自己的意愿修改完后，执行hexo g，hexo s，打开localhost:4000看看效果。 发表一篇文章1.在Git Bash执行命令：$ hexo new “my new post”2.在D:\hexo\source_post中打开my-new-post.md，打开方式使用记事本或notepad++。hexo中写文章使用的是Markdown，没接触过的可以看下Markdown语法说明。1234567title: my new post #可以改成中文的，如“新文章”date: 2016-07-16 22:00:00 #发表日期，一般不改动categories: blog #文章文类tags: [博客，文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上&lt;!--more--&gt; #在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，你可以使用1.$ hexo g生成静态文件。2.$ hexo s在本地预览效果。3.hexo d同步到github，然后使用http://leezp.github.io进行访问。 另一种发布到github的配置现在提供另一种配置方式，这种方式在发布时不需要同时输入用户名和邮箱账号，也是我目前使用的方法，配置代码如下。 1234deploy: type: git repository: git@github.com:leezp/leezp.github.io.git branch: master 这种配置方式，需要配置SSH key，教程如下：鼠标右键任意地方，选择Git Bash， 1$ ssh-keygen -t rsa -C "your_email@youremail.com" 后面的your_email@youremail.com改为你的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在C:\Users\Administrator下生成.ssh文件夹，进入该文件夹，打开id_rsa.pub，复制里面的key。回到github，进入Settings，选择SSH and GPG Keys -&gt; New SSH Key，title随便填，粘贴key。为了验证是否成功，在git bash下输入： 1$ ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated， but GitHub does not provide shell access ，这就表示已成功连上github。接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。12$ git config --global user.name "your name" $ git config --global user.email "your_email@youremail.com" 总结到目前为止，实现了用hexo搭建博客的基本功能。由于本文是博主工作之余写的，比较仓促，难免有错误，欢迎指正。后面的文章将介绍本博客使用到的一些实用的功能，如访问次数，新浪微博秀，RSS，多说评论等，喜欢这些功能的朋友可以继续跟随。 版权声明：本文为博主原创文章，转载请注明出处 Leezp’s Blog]]></content>
    </entry>

    
  
  
</search>
